<!DOCTYPE html>
<html lang="it">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0">
 <title>Editor Grafico Accessibile</title>
 
 <!--
 ═══════════════════════════════════════════════════════════════════════════════
 EDITOR GRAFICO ACCESSIBILE - PROGETTATO SECONDO WCAG 2.1 AA
 ═══════════════════════════════════════════════════════════════════════════════
 
 Versione standalone ottimizzata (zero dipendenze esterne critiche)
 
 FUNZIONALITÀ PRINCIPALI:
 • Pipeline WebGL GPU vera (glfx.js inline): brightness, contrast, hue, saturation, vibrance, noise, sepia, unsharp mask, vignette + effetti avanzati disponibili via GpuEffects
 • Disegno vettoriale con tastiera (Polilinea & Pennarello Smooth)
 • Template Social (Instagram, TikTok, Facebook, YouTube) con Safe Zone
 • Integrazione Gemini AI (analisi immagini, OCR, rimozione sfondo)
 • Gradienti personalizzabili con input HEX
 • Sistema Help contestuale (F2)
 
 ACCESSIBILITÀ - PROGETTATO SECONDO WCAG 2.1 AA:
 Navigazione 100% tastiera
 Screen reader NVDA completo
 Skip links navigazione rapida
 Live regions ARIA feedback
 Landmark regions semantiche
 Focus management modali
 Contrasto colori >= 4.5:1
 Label visive tutti i controlli
 
 NAVIGAZIONE TASTIERA:
 • F1: Guida completa
 • F2: Aiuto contestuale
 • Tab/Shift+Tab: Naviga controlli
 • Frecce: Naviga liste, muovi canvas
 • Enter/Space: Attiva pulsanti
 • Esc: Chiudi/annulla
 • Ctrl+Z/Y: Undo/Redo
 • Ctrl+P: Disegno vettoriale
 
 SCREEN READER:
 • Annunci su tutte le azioni
 • Descrizioni ARIA complete
 • Stati accurati
 • Focus visibile sempre
 
 ═══════════════════════════════════════════════════════════════════════════════
 -->
 
 <!-- 
 ═══════════════════════════════════════════════════════════════════
 SMART FONT LOADING - Online/Offline Adaptive
 ═══════════════════════════════════════════════════════════════════
 
 Sistema intelligente che si adatta alla connettività:
 
 ONLINE: Carica Google Fonts (900+ font disponibili)
 OFFLINE: Usa font di sistema (13 web-safe fonts garantiti)
 
 Benefici:
 - Massima flessibilità quando online
 - Funzionalità garantita quando offline
 - Rilevamento automatico dello stato connessione
 - Aggiornamento dinamico della lista font
 -->
 
 <!-- Google Fonts - Caricamento condizionale -->
 <script>
 (function() {
 'use strict';
 
 // Flag globale per tracciare disponibilità Google Fonts
 window.googleFontsAvailable = false;
 window.isOnline = navigator.onLine;
 
 /**
 * Tenta di caricare Google Fonts se online
 */
 function loadGoogleFonts() {
 if (!navigator.onLine) {
 console.log(' Offline: Usando font di sistema');
 return;
 }
 
 // Lista font Google da caricare
 const googleFonts = [
 'Montserrat:wght@300;400;500;600;700',
 'Open+Sans:wght@300;400;600;700',
 'Roboto:wght@300;400;500;700',
 'Lato:wght@300;400;700',
 'Poppins:wght@300;400;500;600;700',
 'Raleway:wght@300;400;500;600;700',
 'Oswald:wght@300;400;500;600;700',
 'Merriweather:wght@300;400;700',
 'Playfair+Display:wght@400;500;600;700'
 ];
 
 // Crea link preconnect per performance
 const preconnect1 = document.createElement('link');
 preconnect1.rel = 'preconnect';
 preconnect1.href = 'https://fonts.googleapis.com';
 
 const preconnect2 = document.createElement('link');
 preconnect2.rel = 'preconnect';
 preconnect2.href = 'https://fonts.gstatic.com';
 preconnect2.crossOrigin = 'anonymous';
 
 // Crea link ai font
 const fontLink = document.createElement('link');
 fontLink.rel = 'stylesheet';
 fontLink.href = `https://fonts.googleapis.com/css2?${googleFonts.map(f => `family=${f}`).join('&')}&display=swap`;
 
 // Timeout per fallback
 const timeout = setTimeout(() => {
 console.warn('️ Google Fonts timeout - Usando font di sistema');
 window.googleFontsAvailable = false;
 updateFontSelector();
 }, 3000);
 
 // Listener per successo caricamento
 fontLink.onload = () => {
 clearTimeout(timeout);
 window.googleFontsAvailable = true;
 console.log(' Google Fonts caricati - 900+ font disponibili');
 updateFontSelector();
 };
 
 fontLink.onerror = () => {
 clearTimeout(timeout);
 console.warn(' Google Fonts non disponibili - Usando font di sistema');
 window.googleFontsAvailable = false;
 updateFontSelector();
 };
 
 // Aggiungi al DOM
 document.head.appendChild(preconnect1);
 document.head.appendChild(preconnect2);
 document.head.appendChild(fontLink);
 }
 
 /**
 * Aggiorna il selettore font in base alla disponibilità
 */
 function updateFontSelector() {
 const selector = document.getElementById('ff');
 if (!selector) {
 // Selector non ancora nel DOM, riprova tra 100ms
 setTimeout(updateFontSelector, 100);
 return;
 }
 
 // Salva selezione corrente
 const currentValue = selector.value;
 
 // Pulisci opzioni esistenti
 selector.innerHTML = '';
 
 // Font di sistema (sempre disponibili)
 const systemFonts = [
 { value: 'Arial', label: 'Arial' },
 { value: 'Helvetica, Arial, sans-serif', label: 'Helvetica' },
 { value: "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif", label: 'Segoe UI' },
 { value: "-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif", label: 'System UI' },
 { value: 'Georgia, serif', label: 'Georgia' },
 { value: "'Times New Roman', Times, serif", label: 'Times New Roman' },
 { value: "'Courier New', Courier, monospace", label: 'Courier New' },
 { value: 'Verdana, Geneva, sans-serif', label: 'Verdana' },
 { value: 'Tahoma, Geneva, sans-serif', label: 'Tahoma' },
 { value: "'Trebuchet MS', sans-serif", label: 'Trebuchet MS' },
 { value: 'Impact, Charcoal, sans-serif', label: 'Impact' },
 { value: "'Comic Sans MS', cursive", label: 'Comic Sans MS' },
 { value: "'Brush Script MT', cursive", label: 'Brush Script' }
 ];
 
 // Google Fonts (solo se disponibili)
 const googleFontsList = window.googleFontsAvailable ? [
 { value: 'Montserrat, sans-serif', label: 'Montserrat ' },
 { value: 'Open Sans, sans-serif', label: 'Open Sans ' },
 { value: 'Roboto, sans-serif', label: 'Roboto ' },
 { value: 'Lato, sans-serif', label: 'Lato ' },
 { value: 'Poppins, sans-serif', label: 'Poppins ' },
 { value: 'Raleway, sans-serif', label: 'Raleway ' },
 { value: 'Oswald, sans-serif', label: 'Oswald ' },
 { value: 'Merriweather, serif', label: 'Merriweather ' },
 { value: 'Playfair Display, serif', label: 'Playfair Display ' }
 ] : [];
 
 // Aggiungi separatore se ci sono Google Fonts
 if (googleFontsList.length > 0) {
 const optgroup1 = document.createElement('optgroup');
 optgroup1.label = ' Google Fonts (Online)';
 googleFontsList.forEach(font => {
 const opt = document.createElement('option');
 opt.value = font.value;
 opt.textContent = font.label;
 optgroup1.appendChild(opt);
 });
 selector.appendChild(optgroup1);
 
 const optgroup2 = document.createElement('optgroup');
 optgroup2.label = ' Font di Sistema (Sempre Disponibili)';
 systemFonts.forEach(font => {
 const opt = document.createElement('option');
 opt.value = font.value;
 opt.textContent = font.label;
 if (font.value === 'Arial') opt.selected = true;
 optgroup2.appendChild(opt);
 });
 selector.appendChild(optgroup2);
 } else {
 // Solo font di sistema
 systemFonts.forEach(font => {
 const opt = document.createElement('option');
 opt.value = font.value;
 opt.textContent = font.label + ' ';
 if (font.value === 'Arial') opt.selected = true;
 selector.appendChild(opt);
 });
 }
 
 // Ripristina selezione se possibile
 if (currentValue && Array.from(selector.options).some(opt => opt.value === currentValue)) {
 selector.value = currentValue;
 }
 }
 
 // Listener per cambio connettività
 window.addEventListener('online', () => {
 console.log(' Connessione ripristinata - Carico Google Fonts');
 window.isOnline = true;
 loadGoogleFonts();
 });
 
 window.addEventListener('offline', () => {
 console.log(' Connessione persa - Usando font di sistema');
 window.isOnline = false;
 window.googleFontsAvailable = false;
 updateFontSelector();
 });
 
 // Avvia caricamento al load
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', () => {
 loadGoogleFonts();
 updateFontSelector();
 });
 } else {
 loadGoogleFonts();
 updateFontSelector();
 }
 
 // Esporta funzione per uso esterno
 window.updateFontSelector = updateFontSelector;
 })();
 </script>
 
 <!-- CSS Incorporato per deployment standalone -->
 <style id="minimal-base-styles">
/* Stili CSS minimi per Editor Grafico Accessibile */
:root {
 /* Colori primari */
 --primary-color: #3b82f6;
 --secondary-color: #8b5cf6;
 --success-color: #10b981;
 --warning-color: #f59e0b;
 --danger-color: #ef4444;
 --info-color: #06b6d4;
 
 /* Colori accent */
 --accent: #8b5cf6;
 --accent-hover: #7c3aed;
 
 /* Colori danger hover */
 --danger: #ef4444;
 --danger-hover: #dc2626;
 
 /* Backgrounds */
 --bg-color: #ffffff;
 --bg-main: #ffffff;
 --bg-secondary: #f9fafb;
 --bg-tertiary: #f3f4f6;
 --bg-input: #ffffff;
 
 /* Testo */
 --text-color: #1f2937;
 --text-primary: #1f2937;
 --text-secondary: #6b7280;
 
 /* Bordi e focus */
 --border-color: #d1d5db;
 --focus-ring: 0 0 0 3px rgba(59, 130, 246, 0.5);
 
 /* Border radius */
 --radius: 8px;
}

* {
 box-sizing: border-box;
}

body {
 font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
 background: var(--bg-color);
 color: var(--text-color);
 line-height: 1.6;
 margin: 0;
 padding: 0;
}

/* Focus visibile per accessibilità WCAG 2.1 AA */
*:focus {
 outline: 2px solid var(--primary-color);
 outline-offset: 2px;
}

button, input, select, textarea {
 font-family: inherit;
 font-size: 100%;
}

button {
 padding: 8px 16px;
 background: var(--primary-color);
 color: white;
 border: none;
 border-radius: 4px;
 cursor: pointer;
 transition: background 0.2s, opacity 0.2s;
}

button:hover:not(:disabled) {
 opacity: 0.9;
}

button:disabled {
 opacity: 0.5;
 cursor: not-allowed;
}

button:active:not(:disabled) {
 transform: translateY(1px);
}

input[type="range"] {
 width: 100%;
 margin: 8px 0;
}

input[type="text"],
input[type="number"],
input[type="color"],
select,
textarea {
 padding: 8px;
 border: 1px solid var(--border-color);
 border-radius: 4px;
 font-size: 14px;
}

input[type="text"]:focus,
input[type="number"]:focus,
input[type="color"]:focus,
select:focus,
textarea:focus {
 border-color: var(--primary-color);
 box-shadow: var(--focus-ring);
}

.container {
 max-width: 1400px;
 margin: 0 auto;
 padding: 20px;
}

.canvas-container {
 border: 2px solid var(--border-color);
 border-radius: 8px;
 overflow: hidden;
 background: #f9fafb;
 margin: 20px 0;
}

canvas {
 display: block;
 max-width: 100%;
 height: auto;
}

/* Accessibilità - Etichette visive */
label {
 display: block;
 margin-bottom: 4px;
 font-weight: 500;
 color: var(--text-color);
}

/* Layout pannelli controlli */
.controls-panel {
 background: white;
 border: 1px solid var(--border-color);
 border-radius: 8px;
 padding: 16px;
 margin-bottom: 16px;
}

.controls-panel h3 {
 margin-top: 0;
 margin-bottom: 12px;
 color: var(--primary-color);
}

/* Accordion per organizzazione controlli */
.accordion {
 border: 1px solid var(--border-color);
 border-radius: 4px;
 margin-bottom: 8px;
}

.accordion-header {
 background: #f9fafb;
 padding: 12px;
 cursor: pointer;
 font-weight: 600;
 display: flex;
 justify-content: space-between;
 align-items: center;
}

.accordion-header:hover {
 background: #f3f4f6;
}

.accordion-content {
 padding: 12px;
 display: none;
}

.accordion-content.active {
 display: block;
}

/* Stati feedback visivo */
.success-message {
 background: #d1fae5;
 color: #065f46;
 padding: 12px;
 border-radius: 4px;
 margin: 8px 0;
}

.error-message {
 background: #fee2e2;
 color: #991b1b;
 padding: 12px;
 border-radius: 4px;
 margin: 8px 0;
}

.warning-message {
 background: #fef3c7;
 color: #92400e;
 padding: 12px;
 border-radius: 4px;
 margin: 8px 0;
}

/* Loading spinner accessibile */
.loading-spinner {
 border: 4px solid #f3f4f6;
 border-top: 4px solid var(--primary-color);
 border-radius: 50%;
 width: 40px;
 height: 40px;
 animation: spin 1s linear infinite;
 margin: 20px auto;
}

@keyframes spin {
 0% { transform: rotate(0deg); }
 100% { transform: rotate(360deg); }
}

/* Tooltips accessibili */
[data-tooltip] {
 position: relative;
}

[data-tooltip]:hover::after,
[data-tooltip]:focus::after {
 content: attr(data-tooltip);
 position: absolute;
 bottom: 100%;
 left: 50%;
 transform: translateX(-50%);
 background: rgba(0, 0, 0, 0.9);
 color: white;
 padding: 8px 12px;
 border-radius: 4px;
 font-size: 14px;
 white-space: nowrap;
 z-index: 1000;
 pointer-events: none;
}

/* Responsive design */
@media (max-width: 768px) {
 .container {
 padding: 10px;
 }
 
 .controls-panel {
 padding: 12px;
 }
 
 button {
 padding: 10px 14px;
 font-size: 14px;
 }
}

/* High contrast mode support */
@media (prefers-contrast: high) {
 * {
 border-width: 2px !important;
 }
 
 button {
 border: 2px solid currentColor !important;
 }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
 * {
 animation-duration: 0.01ms !important;
 animation-iteration-count: 1 !important;
 transition-duration: 0.01ms !important;
 }
}

/* ========================================
 COSTRUTTORE PROMPT MODALE
 ======================================== */
.prompt-builder-modal {
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0, 0, 0, 0.7);
 z-index: 10000;
 display: flex;
 align-items: center;
 justify-content: center;
 padding: 20px;
}

.prompt-builder-content {
 background: white;
 border-radius: 12px;
 width: 100%;
 max-width: 700px;
 max-height: 90vh;
 overflow: hidden;
 display: flex;
 flex-direction: column;
 box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
}

.prompt-builder-header {
 background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
 color: white;
 padding: 20px 24px;
 display: flex;
 justify-content: space-between;
 align-items: center;
}

.prompt-builder-header h2 {
 margin: 0;
 font-size: 20px;
}

.prompt-builder-close {
 background: rgba(255, 255, 255, 0.2);
 border: none;
 color: white;
 font-size: 24px;
 width: 36px;
 height: 36px;
 border-radius: 50%;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: background 0.2s;
}

.prompt-builder-close:hover {
 background: rgba(255, 255, 255, 0.3);
}

.prompt-builder-body {
 padding: 24px;
 overflow-y: auto;
 flex: 1;
}

.pb-section {
 margin-bottom: 16px;
}

.pb-section label {
 display: block;
 margin-bottom: 6px;
 font-size: 14px;
}

.pb-section input[type="text"],
.pb-section select,
.pb-section textarea {
 font-family: inherit;
 font-size: 14px;
}

/* ═══════════════════════════════════════════════════════════
 PULSANTI SEMPRE UNO SOTTO L'ALTRO
 ═══════════════════════════════════════════════════════════ */
 
/* Forza TUTTI i gruppi di pulsanti ad essere verticali */
.btn-group {
 display: flex !important;
 flex-direction: column !important;
 gap: 8px !important;
 width: 100% !important;
}

.btn-group button,
.btn-group .btn {
 width: 100% !important;
 margin: 0 !important;
}
 </style>
 
 <!-- glfx.js WebGL Library - Inline Implementation with Fallback System -->
 <script>
/**
 * glfx.js Loader with Multi-Fallback System
 * Priority: 1) Inline code, 2) CDN Primary, 3) CDN Backup, 4) Graceful degradation
 */

(function() {
 'use strict';
 
 // Flag per indicare se glfx è disponibile
 window.glfxAvailable = false;
 window.glfxLoadAttempted = false;
 
 /**
 * Funzione per caricare glfx da URL esterno (CDN)
 */
 function loadGlfxFromCDN(url, fallbackCallback) {
 return new Promise((resolve, reject) => {
 const script = document.createElement('script');
 script.src = url;
 script.async = true;
 
 script.onload = () => {
 if (typeof fx !== 'undefined' && typeof fx.canvas === 'function') {
 console.log(` glfx.js loaded from: ${url}`);
 window.glfxAvailable = true;
 resolve(true);
 } else {
 console.warn(`️ glfx.js script loaded but fx not defined from: ${url}`);
 reject(new Error('fx not defined'));
 }
 };
 
 script.onerror = () => {
 console.warn(` Failed to load glfx.js from: ${url}`);
 reject(new Error(`Failed to load from ${url}`));
 };
 
 // Timeout di 5 secondi per CDN
 const timeout = setTimeout(() => {
 script.remove();
 reject(new Error(`Timeout loading from ${url}`));
 }, 5000);
 
 script.addEventListener('load', () => clearTimeout(timeout));
 script.addEventListener('error', () => clearTimeout(timeout));
 
 document.head.appendChild(script);
 });
 }
 
 /**
 * Fallback multipli: Inline → CDN Primary → CDN Backup → Graceful degradation
 */
 async function loadGlfxWithFallback() {
 window.glfxLoadAttempted = true;
 
 // TENTATIVO 1: Inline (già definito sotto)
 // Il codice inline viene eseguito subito dopo questa funzione
 
 // TENTATIVO 2: CDN Primary (jsDelivr)
 const cdnPrimary = 'https://cdn.jsdelivr.net/npm/glfx@0.0.4/glfx.min.js';
 
 // TENTATIVO 3: CDN Backup (unpkg)
 const cdnBackup = 'https://unpkg.com/glfx@0.0.4/glfx.min.js';
 
 // Attendi 100ms per dare tempo all'inline di caricare
 await new Promise(resolve => setTimeout(resolve, 100));
 
 // Verifica se inline ha funzionato
 if (typeof fx !== 'undefined' && typeof fx.canvas === 'function') {
 console.log(' glfx.js loaded successfully (inline version)');
 window.glfxAvailable = true;
 return true;
 }
 
 console.warn('️ glfx.js inline failed, trying CDN fallbacks...');
 
 // Prova CDN Primary
 try {
 await loadGlfxFromCDN(cdnPrimary);
 return true;
 } catch (err) {
 console.warn('️ CDN Primary failed:', err.message);
 }
 
 // Prova CDN Backup
 try {
 await loadGlfxFromCDN(cdnBackup);
 return true;
 } catch (err) {
 console.warn('️ CDN Backup failed:', err.message);
 }
 
 // FALLBACK FINALE: Graceful degradation
 console.error(' All glfx.js loading methods failed. GPU effects will be disabled.');
 window.glfxAvailable = false;
 
 // Crea stub per evitare errori
 window.fx = {
 canvas: function() {
 console.warn('️ glfx.canvas() called but WebGL is not available. Returning null.');
 return null;
 }
 };
 
 return false;
 }
 
 // Avvia il caricamento con fallback usando IIFE async per compatibilità
 (async function initGlfx() {
 try {
 const success = await loadGlfxWithFallback();
 if (!success) {
 // Notifica l'utente (opzionale, da gestire nell'UI principale)
 console.warn('️ GPU effects unavailable. Basic editing features will still work.');
 }
 } catch (error) {
 console.error(' Error during glfx initialization:', error);
 window.glfxAvailable = false;
 }
 })();
 
})();

/**
 * glfx.js WebGL Implementation - Inline Version
 * Based on https://github.com/evanw/glfx.js
 * Simplified but complete implementation for standalone deployment
 */

(function() {
 'use strict';
 
 // Se glfx è già stato caricato da CDN, non sovrascrivere
 if (typeof fx !== 'undefined') {
 console.log(' glfx already loaded, skipping inline version');
 window.glfxAvailable = true;
 return;
 }
 
 // Try-catch per catturare errori WebGL
 try {
 
 // Vertex shader for basic texture rendering
 const vertexShaderSource = `
 attribute vec2 a_position;
 attribute vec2 a_texCoord;
 varying vec2 v_texCoord;
 
 void main() {
 gl_Position = vec4(a_position, 0.0, 1.0);
 v_texCoord = a_texCoord;
 }
 `;
 
 // Utility function to create shader
 function createShader(gl, type, source) {
 const shader = gl.createShader(type);
 gl.shaderSource(shader, source);
 gl.compileShader(shader);
 
 if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
 console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
 gl.deleteShader(shader);
 return null;
 }
 
 return shader;
 }
 
 // Utility function to create program
 function createProgram(gl, vertexShader, fragmentShader) {
 const program = gl.createProgram();
 gl.attachShader(program, vertexShader);
 gl.attachShader(program, fragmentShader);
 gl.linkProgram(program);
 
 if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
 console.error('Program linking error:', gl.getProgramInfoLog(program));
 gl.deleteProgram(program);
 return null;
 }
 
 return program;
 }
 
 // Texture wrapper
 function Texture(gl, image) {
 this.gl = gl;
 this.texture = gl.createTexture();
 gl.bindTexture(gl.TEXTURE_2D, this.texture);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
 gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
 
 if (image) {
 this.width = image.width || image.videoWidth || image.naturalWidth;
 this.height = image.height || image.videoHeight || image.naturalHeight;
 gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
 }
 }
 
 Texture.prototype.destroy = function() {
 this.gl.deleteTexture(this.texture);
 this.texture = null;
 };
 
 Texture.prototype.use = function(unit) {
 this.gl.activeTexture(this.gl.TEXTURE0 + (unit || 0));
 this.gl.bindTexture(this.gl.TEXTURE_2D, this.texture);
 };
 
 // Canvas wrapper with WebGL context
 function Canvas() {
 const canvas = document.createElement('canvas');
 const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
 
 if (!gl) {
 throw new Error('WebGL not supported');
 }
 
 canvas._ = {
 gl: gl,
 isWebGL: true,
 texture: null,
 flippedShader: null
 };
 
 // Setup basic geometry
 const vertices = new Float32Array([
 -1, -1, 0, 1,
 1, -1, 1, 1,
 -1, 1, 0, 0,
 1, 1, 1, 0
 ]);
 
 const buffer = gl.createBuffer();
 gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
 gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
 canvas._.vertexBuffer = buffer;
 
 // Create basic shader for rendering
 const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
 const fs = createShader(gl, gl.FRAGMENT_SHADER, `
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 
 void main() {
 gl_FragColor = texture2D(u_texture, v_texCoord);
 }
 `);
 
 canvas._.basicProgram = createProgram(gl, vs, fs);
 canvas._.programCache = {};
 
 // Add filter methods directly to canvas instance
 canvas.texture = function(element) {
 return new Texture(this._.gl, element);
 };
 
 canvas.draw = function(texture) {
 if (!texture || !texture.texture) {
 console.error('Invalid texture');
 return this;
 }
 
 const gl = this._.gl;
 
 // Cleanup old texture to prevent memory leak
 if (this._.texture && this._.texture !== texture) {
 if (typeof this._.texture.destroy === 'function') {
 this._.texture.destroy();
 } else if (this._.texture.texture) {
 gl.deleteTexture(this._.texture.texture);
 }
 }
 
 this._.texture = texture;
 
 this.width = texture.width;
 this.height = texture.height;
 gl.viewport(0, 0, this.width, this.height);
 
 return this;
 };
 
 canvas.update = function() {
 return this;
 };
 
 canvas.getPixelArray = function() {
 const gl = this._.gl;
 const pixels = new Uint8Array(this.width * this.height * 4);
 gl.readPixels(0, 0, this.width, this.height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
 return pixels;
 };
 
 // Helper to compile and use shader with caching
 canvas._compileShader = function(fragmentSource) {
 const gl = this._.gl;
 
 // Generate secure hash of entire shader source to prevent collisions
 // Using FNV-1a hash algorithm (fast, good distribution, zero collision risk)
 let hash = 2166136261; // FNV offset basis
 for (let i = 0; i < fragmentSource.length; i++) {
 hash ^= fragmentSource.charCodeAt(i);
 hash = Math.imul(hash, 16777619); // FNV prime
 }
 const cacheKey = (hash >>> 0).toString(36); // Convert to unsigned and base36
 
 if (this._.programCache[cacheKey]) {
 return this._.programCache[cacheKey];
 }
 
 const vs = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
 const fs = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
 const program = createProgram(gl, vs, fs);
 
 // Cleanup shaders after linking (not needed anymore)
 gl.deleteShader(vs);
 gl.deleteShader(fs);
 
 // Cache program
 this._.programCache[cacheKey] = program;
 
 // Limit cache size to prevent unbounded growth
 const cacheKeys = Object.keys(this._.programCache);
 if (cacheKeys.length > 20) {
 // Delete oldest program (first in cache)
 const oldestKey = cacheKeys[0];
 gl.deleteProgram(this._.programCache[oldestKey]);
 delete this._.programCache[oldestKey];
 }
 
 return program;
 };
 
 canvas._applyShader = function(program, uniforms) {
 const gl = this._.gl;
 const texture = this._.texture;
 
 if (!texture) {
 console.error('No texture loaded');
 return this;
 }
 
 gl.useProgram(program);
 
 // Set up attributes
 const buffer = this._.vertexBuffer;
 gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
 
 const aPosition = gl.getAttribLocation(program, 'a_position');
 const aTexCoord = gl.getAttribLocation(program, 'a_texCoord');
 
 gl.enableVertexAttribArray(aPosition);
 gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 16, 0);
 
 gl.enableVertexAttribArray(aTexCoord);
 gl.vertexAttribPointer(aTexCoord, 2, gl.FLOAT, false, 16, 8);
 
 // Bind texture
 texture.use(0);
 gl.uniform1i(gl.getUniformLocation(program, 'u_texture'), 0);
 
 // Set custom uniforms
 if (uniforms) {
 for (let name in uniforms) {
 const location = gl.getUniformLocation(program, name);
 const value = uniforms[name];
 
 if (Array.isArray(value)) {
 switch(value.length) {
 case 1: gl.uniform1fv(location, value); break;
 case 2: gl.uniform2fv(location, value); break;
 case 3: gl.uniform3fv(location, value); break;
 case 4: gl.uniform4fv(location, value); break;
 }
 } else {
 gl.uniform1f(location, value);
 }
 }
 }
 
 // Draw
 gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
 
 return this;
 };
 
 // Cleanup method to free GPU resources
 canvas.destroy = function() {
 const gl = this._.gl;
 
 // Delete all cached programs
 for (let key in this._.programCache) {
 gl.deleteProgram(this._.programCache[key]);
 }
 this._.programCache = {};
 
 // Delete basic program
 if (this._.basicProgram) {
 gl.deleteProgram(this._.basicProgram);
 }
 
 // Delete vertex buffer
 if (this._.vertexBuffer) {
 gl.deleteBuffer(this._.vertexBuffer);
 }
 
 // Delete current texture
 if (this._.texture && this._.texture.texture) {
 gl.deleteTexture(this._.texture.texture);
 }
 
 console.log('GPU resources cleaned up');
 };
 
 // ============= FILTER IMPLEMENTATIONS =============
 
 canvas.brightnessContrast = function(brightness, contrast) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float brightness;
 uniform float contrast;
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 color.rgb += brightness;
 if (contrast > 0.0) {
 color.rgb = (color.rgb - 0.5) / (1.0 - contrast) + 0.5;
 } else {
 color.rgb = (color.rgb - 0.5) * (1.0 + contrast) + 0.5;
 }
 gl_FragColor = color;
 }
 `);
 
 return this._applyShader(program, {
 brightness: brightness,
 contrast: contrast
 });
 };
 
 canvas.hueSaturation = function(hue, saturation) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float hue;
 uniform float saturation;
 
 vec3 rgb2hsv(vec3 c) {
 vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
 vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
 vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
 float d = q.x - min(q.w, q.y);
 float e = 1.0e-10;
 return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
 }
 
 vec3 hsv2rgb(vec3 c) {
 vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
 vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
 return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
 }
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 vec3 hsv = rgb2hsv(color.rgb);
 hsv.x += hue / 360.0;
 hsv.y *= 1.0 + saturation;
 gl_FragColor = vec4(hsv2rgb(hsv), color.a);
 }
 `);
 
 return this._applyShader(program, {
 hue: hue,
 saturation: saturation
 });
 };
 
 canvas.vibrance = function(amount) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float amount;
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 float max_val = max(color.r, max(color.g, color.b));
 float min_val = min(color.r, min(color.g, color.b));
 float sat = (max_val - min_val) / max_val;
 float amt = (sat - 1.0) * amount;
 color.rgb = mix(color.rgb, vec3(max_val), amt);
 gl_FragColor = color;
 }
 `);
 
 return this._applyShader(program, { amount: amount });
 };
 
 canvas.noise = function(amount) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float amount;
 
 float rand(vec2 co) {
 return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
 }
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 float noise = (rand(v_texCoord) - 0.5) * amount;
 color.rgb += noise;
 gl_FragColor = color;
 }
 `);
 
 return this._applyShader(program, { amount: amount });
 };
 
 canvas.sepia = function(amount) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float amount;
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 vec3 sepia = vec3(
 dot(color.rgb, vec3(0.393, 0.769, 0.189)),
 dot(color.rgb, vec3(0.349, 0.686, 0.168)),
 dot(color.rgb, vec3(0.272, 0.534, 0.131))
 );
 color.rgb = mix(color.rgb, sepia, amount);
 gl_FragColor = color;
 }
 `);
 
 return this._applyShader(program, { amount: amount });
 };
 
 canvas.vignette = function(size, amount) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float size;
 uniform float amount;
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 vec2 center = v_texCoord - vec2(0.5);
 float dist = length(center);
 float vignette = smoothstep(size, size - amount, dist);
 color.rgb *= vignette;
 gl_FragColor = color;
 }
 `);
 
 return this._applyShader(program, {
 size: size,
 amount: amount
 });
 };
 
 canvas.unsharpMask = function(radius, strength) {
 // Simplified unsharp mask using contrast
 return this.brightnessContrast(0, strength * 0.5);
 };
 
 // ============= ADVANCED EFFECTS =============
 
 canvas.triangleBlur = function(radius) {
 // Clamp radius to max 10 for WebGL 1 compatibility
 const actualRadius = Math.min(radius, 10.0);
 
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float radius;
 uniform vec2 resolution;
 
 void main() {
 vec2 texelSize = 1.0 / resolution;
 vec4 color = vec4(0.0);
 float total = 0.0;
 
 // Fixed loop bounds for WebGL 1 compatibility
 // Loop must have constant bounds in GLSL ES 1.00
 const float MAX_RADIUS = 10.0;
 
 for (float x = -MAX_RADIUS; x <= MAX_RADIUS; x += 1.0) {
 for (float y = -MAX_RADIUS; y <= MAX_RADIUS; y += 1.0) {
 // Skip samples outside actual radius
 if (abs(x) > radius || abs(y) > radius) continue;
 
 float weight = (radius - abs(x)) * (radius - abs(y));
 vec2 offset = vec2(x, y) * texelSize;
 color += texture2D(u_texture, v_texCoord + offset) * weight;
 total += weight;
 }
 }
 
 gl_FragColor = total > 0.0 ? color / total : texture2D(u_texture, v_texCoord);
 }
 `);
 
 return this._applyShader(program, {
 radius: actualRadius,
 resolution: [this.width, this.height]
 });
 };
 
 canvas.zoomBlur = function(centerX, centerY, strength) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform vec2 center;
 uniform float strength;
 
 void main() {
 vec4 color = vec4(0.0);
 float total = 0.0;
 vec2 toCenter = center - v_texCoord;
 
 for (float i = 0.0; i < 20.0; i += 1.0) {
 float t = i / 20.0;
 float weight = 1.0 - t;
 vec2 offset = toCenter * t * strength;
 color += texture2D(u_texture, v_texCoord + offset) * weight;
 total += weight;
 }
 
 gl_FragColor = color / total;
 }
 `);
 
 return this._applyShader(program, {
 center: [centerX, centerY],
 strength: strength
 });
 };
 
 canvas.tiltShift = function(blurRadius, gradientRadius, startX, startY, endX, endY) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform float blurRadius;
 uniform float gradientRadius;
 uniform vec2 start;
 uniform vec2 end;
 uniform vec2 resolution;
 
 void main() {
 vec2 delta = end - start;
 vec2 normal = normalize(vec2(-delta.y, delta.x));
 float dist = abs(dot(v_texCoord - start, normal));
 
 float t = smoothstep(gradientRadius - blurRadius, gradientRadius, dist);
 
 if (t < 0.01) {
 gl_FragColor = texture2D(u_texture, v_texCoord);
 } else {
 vec2 texelSize = 1.0 / resolution;
 vec4 color = vec4(0.0);
 float total = 0.0;
 float blur = blurRadius * t;
 
 for (float i = -10.0; i <= 10.0; i += 1.0) {
 float weight = 1.0 - abs(i / 10.0);
 vec2 offset = normal * i * blur * texelSize;
 color += texture2D(u_texture, v_texCoord + offset) * weight;
 total += weight;
 }
 
 gl_FragColor = color / total;
 }
 }
 `);
 
 return this._applyShader(program, {
 blurRadius: blurRadius,
 gradientRadius: gradientRadius,
 start: [startX, startY],
 end: [endX, endY],
 resolution: [this.width, this.height]
 });
 };
 
 canvas.lensBlur = function(radius, brightness, angle) {
 // Hexagonal bokeh blur (simplified as triangle blur)
 return this.triangleBlur(radius);
 };
 
 canvas.swirl = function(centerX, centerY, radius, angle) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform vec2 center;
 uniform float radius;
 uniform float angle;
 
 void main() {
 vec2 coord = v_texCoord - center;
 float dist = length(coord);
 
 if (dist < radius) {
 float percent = (radius - dist) / radius;
 float theta = percent * percent * angle;
 float s = sin(theta);
 float c = cos(theta);
 coord = vec2(
 coord.x * c - coord.y * s,
 coord.x * s + coord.y * c
 );
 }
 
 gl_FragColor = texture2D(u_texture, coord + center);
 }
 `);
 
 return this._applyShader(program, {
 center: [centerX, centerY],
 radius: radius,
 angle: angle
 });
 };
 
 canvas.bulgePinch = function(centerX, centerY, radius, strength) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform vec2 center;
 uniform float radius;
 uniform float strength;
 
 void main() {
 vec2 coord = v_texCoord - center;
 float dist = length(coord);
 
 if (dist < radius) {
 float percent = dist / radius;
 if (strength > 0.0) {
 coord *= mix(1.0, smoothstep(0.0, radius / dist, percent), strength * 0.75);
 } else {
 coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / dist, 1.0 - percent);
 }
 }
 
 gl_FragColor = texture2D(u_texture, coord + center);
 }
 `);
 
 return this._applyShader(program, {
 center: [centerX, centerY],
 radius: radius,
 strength: strength
 });
 };
 
 canvas.hexagonalPixelate = function(centerX, centerY, scale) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform vec2 center;
 uniform float scale;
 uniform vec2 resolution;
 
 vec2 hexagon(vec2 p) {
 vec2 q = vec2(p.x * 2.0 * 0.5773503, p.y + p.x * 0.5773503);
 vec2 pi = floor(q);
 vec2 pf = fract(q);
 
 float v = mod(pi.x + pi.y, 3.0);
 float ca = step(1.0, v);
 float cb = step(2.0, v);
 vec2 ma = step(pf.xy, pf.yx);
 
 return pi + ca - cb*ma + cb;
 }
 
 void main() {
 vec2 uv = (v_texCoord - center) * resolution / scale;
 vec2 hex = hexagon(uv);
 vec2 hexUV = (hex * scale / resolution) + center;
 gl_FragColor = texture2D(u_texture, hexUV);
 }
 `);
 
 return this._applyShader(program, {
 center: [centerX, centerY],
 scale: scale,
 resolution: [this.width, this.height]
 });
 };
 
 canvas.dotScreen = function(centerX, centerY, angle, size) {
 const program = this._compileShader(`
 precision mediump float;
 varying vec2 v_texCoord;
 uniform sampler2D u_texture;
 uniform vec2 center;
 uniform float angle;
 uniform float size;
 uniform vec2 resolution;
 
 float pattern() {
 float s = sin(angle), c = cos(angle);
 vec2 tex = v_texCoord * resolution - center;
 vec2 point = vec2(
 c * tex.x - s * tex.y,
 s * tex.x + c * tex.y
 ) * size;
 return (sin(point.x) * sin(point.y)) * 4.0;
 }
 
 void main() {
 vec4 color = texture2D(u_texture, v_texCoord);
 float average = (color.r + color.g + color.b) / 3.0;
 gl_FragColor = vec4(vec3(average * 10.0 - 5.0 + pattern()), color.a);
 }
 `);
 
 return this._applyShader(program, {
 center: [centerX, centerY],
 angle: angle,
 size: size,
 resolution: [this.width, this.height]
 });
 };
 
 
 return canvas;
 }
 
 // Export to global namespace
 window.fx = {
 canvas: function() {
 return Canvas(); // Factory function, not a constructor
 }
 };
 
 window.glfxAvailable = true;
 console.log(' glfx.js WebGL library loaded (inline version)');
 
 } catch (error) {
 // Cattura errori WebGL (es. browser troppo vecchio, WebGL disabilitato)
 console.error(' glfx.js inline initialization failed:', error);
 window.glfxAvailable = false;
 
 // Crea stub per evitare errori downstream
 window.fx = {
 canvas: function() {
 console.warn('️ glfx.canvas() called but initialization failed');
 return null;
 }
 };
 }
 
})();

 </script>
 <style>
 .sr-only {
 position: absolute !important;
 width: 1px !important;
 height: 1px !important;
 padding: 0 !important;
 margin: -1px !important;
 overflow: hidden !important;
 clip: rect(0, 0, 0, 0) !important;
 white-space: nowrap !important;
 border: 0 !important;
 }
 
 /* ═══════════════════════════════════════════════════════════════
 COSTRUTTORE PROMPT - Radio Options Interattivi
 ═══════════════════════════════════════════════════════════════ */
 
 .radio-option {
 transition: all 0.2s ease;
 }
 
 .radio-option:hover {
 border-color: #94a3b8 !important;
 background: #f8fafc !important;
 }
 
 .radio-option:focus-within,
 .radio-option:focus {
 border-color: #3b82f6 !important;
 background: #eff6ff !important;
 outline: 2px solid #3b82f6;
 outline-offset: 2px;
 }
 
 .radio-option input[type="radio"]:checked ~ div {
 color: #1e293b;
 }
 
 .radio-option input[type="radio"] {
 cursor: pointer;
 flex-shrink: 0;
 }
 
 /* Effetto visivo quando è selezionato */
 .radio-option:has(input:checked) {
 border-color: #3b82f6 !important;
 background: #eff6ff !important;
 box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
 }
 
 /* ═══════════════════════════════════════════════════════════════
 UTILITY CLASSES - Riduzione stili inline per manutenibilità
 ═══════════════════════════════════════════════════════════════ */
 
 /* Display utilities */
 .hidden { display: none !important; }
 .block { display: block !important; }
 .flex { display: flex !important; }
 .inline-block { display: inline-block !important; }
 .flex-1 { flex: 1; }
 
 /* Help table utilities */
 .help-table {
 width: 100%;
 border-collapse: collapse;
 margin: 8px 0;
 }
 
 .help-table-cell {
 padding: 6px;
 border: 1px solid #cbd5e1;
 }
 
 .help-table-header {
 padding: 6px;
 text-align: center;
 }
 
 /* Info boxes per help (F2) */
 .help-box-danger {
 background: #fee2e2;
 padding: 12px;
 border-radius: 6px;
 margin: 12px 0;
 }
 
 .help-box-success {
 background: #dcfce7;
 padding: 12px;
 border-radius: 6px;
 margin: 12px 0;
 }
 
 .help-box-info {
 background: #dbeafe;
 padding: 12px;
 border-radius: 6px;
 margin: 12px 0;
 }
 
 .help-box-warning {
 background: #fff7ed;
 padding: 12px;
 border-radius: 6px;
 margin: 12px 0;
 }
 
 .help-list {
 margin: 8px 0;
 padding-left: 20px;
 }
 
 /* Text utilities */
 .text-white { color: #fff; }
 .text-white-90 { color: rgba(255,255,255,0.9); }
 .text-white-80 { color: rgba(255,255,255,0.8); }
 .text-red { color: #d84315; }
 
 /* Background utilities */
 .bg-white-30 { background: rgba(255,255,255,0.3); }
 
 /* Spacing utilities */
 .mt-8 { margin-top: 8px; }
 .mt-12 { margin-top: 12px; }
 
 /* Button utilities */
 .btn-full-width {
 border: none;
 width: 100%;
 text-align: left;
 cursor: pointer;
 }
 
 .btn-full {
 width: 100%;
 display: block;
 }
 
 /* Margin utilities */
 .mt-8 { margin-top: 8px; }
 .mt-12 { margin-top: 12px; }
 .mt-16 { margin-top: 16px; }
 .mb-8 { margin-bottom: 8px; }
 .mb-12 { margin-bottom: 12px; }
 .my-12 { margin-top: 12px; margin-bottom: 12px; }
 
 /* Padding utilities */
 .p-12 { padding: 12px; }
 .p-16 { padding: 16px; }
 
 /* Width utilities */
 .w-full { width: 100%; }
 
 /* Gap utilities */
 .gap-8 { gap: 8px; }
 .gap-12 { gap: 12px; }
 
 /* Border radius utilities */
 .rounded { border-radius: 4px; }
 .rounded-md { border-radius: 6px; }
 .rounded-lg { border-radius: 8px; }
 
 /* Background utilities */
 .bg-input { background: var(--bg-input); }
 .bg-secondary { background: var(--bg-secondary); }
 
 /* Text utilities */
 .text-center { text-align: center; }
 .text-left { text-align: left; }
 .font-bold { font-weight: 600; }
 
 /* Flex utilities */
 .flex-col { flex-direction: column; }
 .items-center { align-items: center; }
 .justify-between { justify-content: space-between; }
 
 /* Opacity utilities */
 .opacity-50 { opacity: 0.5; }
 
 /* Cursor utilities */
 .cursor-pointer { cursor: pointer; }
 .cursor-not-allowed { cursor: not-allowed; }
 
 /* ═══════════════════════════════════════════════════════════════ */
 
 /* Skip Navigation Links - Visibili solo al focus */
 .skip-links {
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 z-index: 10000;
 pointer-events: none; /* Evita interferenze quando non visibile */
 }
 
 .skip-link {
 position: absolute;
 left: -9999px;
 top: 0;
 z-index: 10001;
 padding: 12px 20px;
 background: var(--primary-color);
 color: white;
 text-decoration: none;
 font-weight: 600;
 border-radius: 4px;
 font-size: 16px;
 pointer-events: auto;
 }
 
 .skip-link:focus {
 position: fixed;
 left: 10px;
 top: 10px;
 outline: 3px solid white;
 outline-offset: 2px;
 }
 
 /* Posizionamento sequenziale per link multipli al focus */
 .skip-link:nth-child(1):focus {
 left: 10px;
 }
 
 .skip-link:nth-child(2):focus {
 left: 200px; /* Offset per secondo link */
 }
 
 .skip-link:nth-child(3):focus {
 left: 390px; /* Offset per terzo link */
 }
 </style>

</head>
<body>
 
 <!-- Skip Navigation Links -->
 <nav class="skip-links" aria-label="Collegamenti di navigazione rapida">
 <a href="#main-canvas" class="skip-link">Vai al canvas principale</a>
 <a href="#sidebar-controls" class="skip-link">Vai ai controlli</a>
 <a href="#layer-list" class="skip-link">Vai all'elenco livelli</a>
 </nav>
 
 <!-- ARIA Live Regions per NVDA (da v20) -->
 <div id="sr-polite" class="sr-only" role="status" aria-live="polite" aria-atomic="true"></div>
 <div id="sr-assert" class="sr-only" role="alert" aria-live="assertive" aria-atomic="true"></div>
 
 <!-- Modale aiuto F2 -->
 <div class="f2-help-modal" id="f2-help-modal" role="dialog" aria-labelledby="f2-help-title" aria-modal="true">
 <div class="f2-help-content">
 <h2 class="f2-help-title" id="f2-help-title">Aiuto Elemento</h2>
 <div id="f2-help-body">
 <!-- Il contenuto verrà inserito dinamicamente -->
 </div>
 <div class="f2-help-close-hint">
 Usa le <strong>FRECCE ↑↓</strong> per scorrere il testo • Premi <strong>ESC</strong> per chiudere
 </div>
 </div>
 </div>
 
 <!-- Modale Costruttore Prompt COMPLETO -->
 <div class="prompt-builder-modal" id="prompt-builder-modal" role="dialog" aria-labelledby="prompt-builder-title" aria-modal="true" style="display: none;">
 <div class="prompt-builder-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">
 <div class="prompt-builder-header">
 <h2 id="prompt-builder-title"> Costruttore Prompt AI - Guida Completa</h2>
 <button class="prompt-builder-close" id="btn-close-prompt-builder" aria-label="Chiudi costruttore prompt"></button>
 </div>
 
 <div class="prompt-builder-body">
 <p style="margin-bottom: 1.5rem; color: #64748b; font-size: 14px; line-height: 1.6;">
 Questo strumento ti guida passo-passo nella creazione di prompt perfetti per generatori AI.
 <strong>Ogni opzione è spiegata in dettaglio</strong> per aiutarti a capire esattamente cosa succede quando la attivi.
 </p>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 1. SOGGETTO -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #f8fafc; border-radius: 8px; border-left: 4px solid #3b82f6;">
 <label style="display: block; font-weight: 600; font-size: 16px; margin-bottom: 8px; color: #1e293b;">
 Cosa vuoi creare?
 </label>
 <p style="font-size: 13px; color: #475569; margin: 8px 0 12px 0; line-height: 1.5;">
 Descrivi il soggetto principale dell'immagine. Esempi: "una donna con cappello rosso", "un gatto che dorme", "una pizza margherita", "paesaggio montano al tramonto"
 </p>
 <input type="text" id="pb-subject" placeholder="es: una donna sorridente con vestito blu" style="width: 100%; padding: 10px; border: 2px solid #cbd5e1; border-radius: 4px; font-size: 14px;">
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 2. STILE ARTISTICO -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #fef3c7; border-radius: 8px; border-left: 4px solid #f59e0b;">
 <label style="display: block; font-weight: 600; font-size: 16px; margin-bottom: 8px; color: #1e293b;">
 Stile Artistico
 </label>
 <p style="font-size: 13px; color: #78350f; margin: 8px 0 12px 0; line-height: 1.5;">
 Scegli come vuoi che appaia l'immagine. Lo stile determina se sembra una foto vera, un dipinto, un disegno, ecc.
 </p>
 <select id="pb-style" style="width: 100%; padding: 10px; border: 2px solid #cbd5e1; border-radius: 4px; font-size: 14px;">
 <option value="photo_real"> Fotografia Realistica</option>
 <option value="cinematic"> Cinematografica</option>
 <option value="digital_illustration"> Illustrazione Digitale</option>
 </select>
 <div id="pb-style-help" style="margin-top: 10px; padding: 12px; background: white; border-radius: 4px; font-size: 13px; color: #1e293b; line-height: 1.6;"></div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 3. INQUADRATURA -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #dbeafe; border-radius: 8px; border-left: 4px solid #3b82f6;">
 <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #1e293b; font-weight: 600;">
 INQUADRATURA - Quanto del soggetto vuoi vedere?
 </h3>
 <p style="font-size: 13px; color: #1e40af; margin-bottom: 15px; line-height: 1.6;">
 L'inquadratura decide quanto è grande il soggetto nell'immagine e quanto si vede dello sfondo.
 </p>
 
 <div style="display: grid; gap: 12px;">
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="extreme_closeup" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Primissimo piano (Extreme Close-up)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Solo un dettaglio: un occhio, una mano, un fiore<br>
 → Lo sfondo NON si vede per niente<br>
 <strong>Perfetto per:</strong> emozioni intense, texture, dettagli<br>
 <strong>Sensazione:</strong> intimità massima, focus totale
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="closeup" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Primo piano (Close-up)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Solo il viso o l'oggetto riempie l'immagine (80-90%)<br>
 → Lo sfondo è pochissimo e sfocato<br>
 <strong>Perfetto per:</strong> ritratti emotivi, espressioni, dettagli prodotti<br>
 <strong>Sensazione:</strong> connessione personale, intimità
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="medium_shot" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Mezzo busto / Piano medio</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Dalla vita in su (60-70% dell'immagine)<br>
 → Sfondo visibile ma secondario<br>
 <strong>Perfetto per:</strong> ritratti professionali, presentazioni<br>
 <strong>Sensazione:</strong> professionale ma personale
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: #eff6ff; border-radius: 6px; cursor: pointer; border: 2px solid #3b82f6;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="full_body" checked style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Figura intera PREDEFINITO</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Tutto il soggetto dai piedi alla testa (50/50 con sfondo)<br>
 → Sfondo occupa circa metà immagine<br>
 <strong>Perfetto per:</strong> vestiti completi, azioni, contesto<br>
 <strong>Sensazione:</strong> equilibrato, narrativo, completo
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="wide_shot" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Campo lungo (Wide Shot)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Soggetto da lontano (30-40% dell'immagine)<br>
 → Sfondo molto importante<br>
 <strong>Perfetto per:</strong> mostrare il luogo, stabilire la scena<br>
 <strong>Sensazione:</strong> senso di spazio, contesto chiaro
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-framing" value="extreme_wide" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;">️ Panoramica (Extreme Wide)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Soggetto molto piccolo (meno del 20%)<br>
 → Paesaggio domina l'immagine<br>
 <strong>Perfetto per:</strong> paesaggi maestosi, grandiosità, solitudine<br>
 <strong>Sensazione:</strong> magnificenza, epicità
 </span>
 </div>
 </label>
 
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 4. ILLUMINAZIONE -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #fef9c3; border-radius: 8px; border-left: 4px solid #eab308;">
 <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #1e293b; font-weight: 600;">
 ILLUMINAZIONE - Che tipo di luce?
 </h3>
 <p style="font-size: 13px; color: #713f12; margin-bottom: 15px; line-height: 1.6;">
 La luce crea l'atmosfera! Scegli il tipo di illuminazione per definire il mood dell'immagine.
 </p>
 
 <div style="display: grid; gap: 12px;">
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="golden_hour" checked style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Golden Hour (Ora d'oro) PREDEFINITO</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Luce calda e dorata di tramonto/alba<br>
 → Ombre lunghe e delicate<br>
 <strong>Perfetto per:</strong> ritratti romantici, atmosfere magiche<br>
 <strong>Sensazione:</strong> come essere avvolti in una coperta dorata
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="natural_daylight" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;">️ Luce naturale diurna</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Luce chiara e uniforme del giorno<br>
 → Colori vivaci e naturali<br>
 <strong>Perfetto per:</strong> foto realistiche, prodotti, colori fedeli<br>
 <strong>Sensazione:</strong> energico, pulito, positivo
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="soft_diffused" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;">️ Luce diffusa (Giornata nuvolosa)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Luce morbida e uniforme senza ombre dure<br>
 → Colori tenui e delicati<br>
 <strong>Perfetto per:</strong> ritratti delicati, pelle perfetta<br>
 <strong>Sensazione:</strong> calmo, melanconico, riflessivo
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="blue_hour" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Blue Hour (Ora blu)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Luce blu profonda dopo tramonto/prima alba<br>
 → Atmosfera misteriosa e eterea<br>
 <strong>Perfetto per:</strong> scene urbane notturne, atmosfere magiche<br>
 <strong>Sensazione:</strong> misterioso, sereno, contemplativo
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="dramatic" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Luce drammatica (Hard Light)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Contrasti forti, ombre molto nere<br>
 → Tensione e intensità visiva<br>
 <strong>Perfetto per:</strong> suspense, ritratti caratteriali, drama<br>
 <strong>Sensazione:</strong> drammatico, intenso, teatrale
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-lighting" value="backlight" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Controluce (Backlight)</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Luce da dietro crea alone luminoso (rim light)<br>
 → Effetto sagoma o etereo<br>
 <strong>Perfetto per:</strong> silhouette drammatiche, effetti angelici<br>
 <strong>Sensazione:</strong> drammatico, etereo, trascendente
 </span>
 </div>
 </label>
 
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 5. ATMOSFERA / MOOD -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #fae8ff; border-radius: 8px; border-left: 4px solid #a855f7;">
 <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #1e293b; font-weight: 600;">
 ATMOSFERA - Che emozione vuoi trasmettere?
 </h3>
 <p style="font-size: 13px; color: #581c87; margin-bottom: 15px; line-height: 1.6;">
 L'atmosfera definisce l'emozione principale che l'immagine deve comunicare.
 </p>
 
 <div style="display: grid; gap: 12px;">
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-mood" value="cheerful" checked style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Allegra e luminosa </strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Colori brillanti, luce abbondante<br>
 <strong>Emozione:</strong> felicità, energia, ottimismo, gioia<br>
 <strong>Perfetto per:</strong> feste, bambini, contenuti positivi
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-mood" value="dramatic" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Drammatica e intensa</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Contrasti forti, ombre profonde<br>
 <strong>Emozione:</strong> suspense, potenza, conflitto<br>
 <strong>Perfetto per:</strong> scene d'azione, storytelling potente
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-mood" value="serene" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Calma e serena</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Colori tenui, luce morbida<br>
 <strong>Emozione:</strong> pace, tranquillità, meditazione<br>
 <strong>Perfetto per:</strong> wellness, spa, momenti di relax
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-mood" value="energetic" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Energica e dinamica</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Movimento, colori saturi<br>
 <strong>Emozione:</strong> azione, velocità, eccitazione<br>
 <strong>Perfetto per:</strong> sport, fitness, eventi, gioventù
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-mood" value="mysterious" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Misteriosa e oscura</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Poca luce, ombre dominanti<br>
 <strong>Emozione:</strong> mistero, suspense, curiosità<br>
 <strong>Perfetto per:</strong> thriller, horror, atmosfere gotiche
 </span>
 </div>
 </label>
 
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 6. COLORI -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #ffedd5; border-radius: 8px; border-left: 4px solid #f97316;">
 <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #1e293b; font-weight: 600;">
 PALETTE COLORI - Che colori predominano?
 </h3>
 <p style="font-size: 13px; color: #7c2d12; margin-bottom: 15px; line-height: 1.6;">
 I colori influenzano fortemente le emozioni. Scegli la palette dominante.
 </p>
 
 <div style="display: grid; gap: 12px;">
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-colors" value="warm" checked style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Colori caldi </strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Rosso, arancione, giallo, marrone<br>
 <strong>Sensazione:</strong> calore, comfort, accoglienza<br>
 <strong>Perfetto per:</strong> cibo, casa, autunno, intimità
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-colors" value="cool" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;">️ Colori freddi</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Blu, verde, viola, turchese<br>
 <strong>Sensazione:</strong> freschezza, calma, professionalità<br>
 <strong>Perfetto per:</strong> acqua, inverno, tecnologia, spa
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-colors" value="neutral" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Neutri e monocromatici</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Bianco, grigio, nero, beige<br>
 <strong>Sensazione:</strong> eleganza, minimalismo, senza tempo<br>
 <strong>Perfetto per:</strong> moda, design moderno, eleganza
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-colors" value="vibrant" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Colori vibranti e saturi</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Versioni intense di qualsiasi colore<br>
 <strong>Sensazione:</strong> energia esplosiva, attenzione<br>
 <strong>Perfetto per:</strong> pubblicità, youth marketing, pop art
 </span>
 </div>
 </label>
 
 <label style="display: flex; gap: 10px; padding: 12px; background: white; border-radius: 6px; cursor: pointer; border: 2px solid #e2e8f0;" class="radio-option" tabindex="0">
 <input type="radio" name="pb-colors" value="pastel" style="margin-top: 3px;">
 <div>
 <strong style="display: block; color: #1e293b; margin-bottom: 4px;"> Colori pastello</strong>
 <span style="font-size: 13px; color: #475569; line-height: 1.5;">
 → Versioni delicate e schiarite<br>
 <strong>Sensazione:</strong> dolcezza, delicatezza, morbidezza<br>
 <strong>Perfetto per:</strong> bambini, matrimoni, primavera, beauty
 </span>
 </div>
 </label>
 
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- 7. TESTO -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-bottom: 25px; padding: 20px; background: #f0fdf4; border-radius: 8px; border-left: 4px solid #22c55e;">
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="pb-text-enabled" style="width: 18px; height: 18px;">
 <strong style="font-size: 16px; color: #1e293b;">️ Voglio del testo scritto nell'immagine</strong>
 </label>
 <div id="pb-text-container" style="display: none; margin-top: 12px;">
 <label style="display: block; font-size: 13px; color: #166534; margin-bottom: 6px;">
 Scrivi il testo esatto che deve apparire (max 3-4 parole per migliori risultati):
 </label>
 <input type="text" id="pb-text-content" placeholder="es: BENVENUTO" maxlength="50" style="width: 100%; padding: 10px; border: 2px solid #cbd5e1; border-radius: 4px; font-size: 14px;">
 <p style="font-size: 12px; color: #166534; margin-top: 6px; line-height: 1.5;">
 ℹ️ Il sistema automaticamente chiederà all'AI di scrivere questo testo in modo chiaro, leggibile e senza errori.
 </p>
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- INFO SISTEMA QUALITÀ -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div style="margin: 25px 0; padding: 16px; background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%); border-radius: 8px; border: 2px solid #3b82f6;">
 <h3 style="margin: 0 0 10px 0; font-size: 16px; color: #1e40af; display: flex; align-items: center; gap: 8px;">
 <span>Sistema Qualità Professionale Attivo</span>
 </h3>
 <p style="font-size: 13px; color: #1e40af; margin: 0; line-height: 1.6;">
 Ogni immagine include automaticamente <strong>40+ controlli di qualità professionali</strong>:
 anatomia corretta (se ci sono persone/animali), zero watermark/loghi, massima nitidezza,
 illuminazione perfetta, testo accurato (se richiesto), proporzioni realistiche, e molto altro.
 <br><strong>Zero configurazione richiesta!</strong> Il sistema applica automaticamente gli standard più alti dell'industria.
 </p>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- PROMPT GENERATO -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 
 <div class="pb-section" style="margin-top: 25px;">
 <label style="display: block; font-weight: 600; font-size: 16px; margin-bottom: 8px; color: #1e293b;">
 Prompt generato (pronto per copiare):
 </label>
 <textarea id="pb-final-prompt" readonly style="width: 100%; min-height: 150px; padding: 12px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 13px; background: #f9fafb; line-height: 1.6; resize: vertical;"></textarea>
 </div>
 
 <button class="btn btn-success btn-full" onclick="copyPromptToClipboard()" style="margin-top: 16px; padding: 14px; font-size: 16px; font-weight: 600;">
 Copia prompt negli appunti
 </button>
 
 <p style="margin-top: 16px; font-size: 13px; color: #64748b; text-align: center; line-height: 1.5;">
 <strong>Suggerimento:</strong> Copia questo prompt e incollalo in ChatGPT, Gemini, DALL·E, Copilot, Midjourney o qualsiasi altro generatore AI!
 </p>
 
 </div>
 </div>
 </div>
 
 <main aria-label="Editor grafico accessibile">
 <div class="app-container">
 <!-- SIDEBAR -->
 <aside class="sidebar" id="sidebar-controls" role="complementary" aria-label="Pannello controlli editor">
 <header class="header">
 <h1>Editor Grafico Accessibile</h1>
 <p>Editor di immagini gestibile completamente da tastiera</p>
 </header>
 
 <!-- CONFIGURAZIONE API GEMINI - PULSANTE -->
 <section class="section-panel" style="margin-bottom: 20px;">
 <div style="display: flex; flex-direction: column; gap: 12px;">
 <button class="btn btn-success btn-full" id="btn-open-api-config" style="background: linear-gradient(to right, #10b981, #059669); font-size: 15px; padding: 14px; width: 100%;">
 Configura API Gemini
 </button>
 
 <!-- COSTRUTTORE PROMPT - PULSANTE -->
 <button class="btn btn-primary btn-full" id="btn-open-prompt-builder" style="background: linear-gradient(to right, #3b82f6, #2563eb); font-size: 15px; padding: 14px; width: 100%;">
 Crea prompt per immagini AI
 </button>
 </div>
 </section>
 
 <!-- PANNELLO 1: TEMPLATE CANVAS -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">1</span>
 <h2 class="section-heading">Templates</h2>
 </div>
 <div class="section-content" id="canvas-section">
 <p class="section-description">Configura le dimensioni del canvas</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div class="control-group">
 <strong class="control-group-title">Formato</strong>
 <select id="tpl">
 <option value="instagram-post" selected>Post Instagram (1080x1080)</option>
 <option value="instagram-story">Storia Instagram (1080x1920)</option>
 <option value="instagram-reel">Reel Instagram (1080x1920)</option>
 <option value="tiktok">TikTok Video (1080x1920)</option>
 <option value="facebook-post">Post Facebook (1200x630)</option>
 <option value="twitter-post">Post Twitter (1600x900)</option>
 <option value="youtube-thumb">Miniatura YouTube (1280x720)</option>
 <option value="youtube-shorts">YouTube Shorts (1080x1920)</option>
 <option value="linkedin-post">Post LinkedIn (1200x627)</option>
 <option value="custom">Personalizzato</option>
 </select>
 <div id="tplCustom" class="row" style="display:none; margin-top:12px">
 <div class="input-with-label"><label for="canvas-width">Larghezza</label><input id="canvas-width" type="number" min="100" value="1080" /></div>
 <div class="input-with-label"><label for="canvas-height">Altezza</label><input id="canvas-height" type="number" min="100" value="1080" /></div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-canvas" style="margin-top:12px;">
 Applica Dimensioni Canvas
 </button>
 </div>
 </div>
 
 <!-- PULSANTE TOGGLE AVANZATE -->
 <button class="btn btn-toggle-advanced" id="toggle-canvas-advanced" aria-expanded="false" aria-controls="canvas-advanced">
 <span class="icon">▼</span>
 <span>Impostazioni Avanzate</span>
 </button>
 
 <!-- OPZIONI AVANZATE -->
 <div class="advanced-section collapsed" id="canvas-advanced">
 <div class="control-group">
 <strong class="control-group-title">Griglia di Aiuto</strong>
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="show-grid">
 <span>Mostra griglia di aiuto</span>
 </label>
 <div id="grid-controls" style="display: none; margin-top: 12px;">
 <input type="number" id="grid-size" min="10" max="100" value="20" placeholder="Dimensione griglia (px)">
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Safe Zone Social</strong>
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="show-safe-zone">
 <span>Mostra margini sicuri social</span>
 </label>
 <p style="margin-top: 8px; font-size: 12px; color: #6b7280; line-height: 1.5;">
 Evidenzia in rosso le zone pericolose dove il testo potrebbe essere coperto da UI Instagram, TikTok, etc.
 </p>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Snap alla Griglia</strong>
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
 <input type="checkbox" id="snap-to-grid">
 <span>Attiva snap alla griglia</span>
 </label>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 2: SFONDO -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">2</span>
 <h2 class="section-heading">Sfondo</h2>
 </div>
 <div class="section-content" id="bg-section">
 <p class="section-description">Configura lo sfondo del canvas</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <fieldset style="border: none; padding: 0; margin: 0;">
 <legend style="font-weight: 600; font-size: 14px; margin-bottom: 8px;">Tipo di Sfondo Canvas</legend>
 <div class="control-group">
 <select id="bg-type">
 <option value="color">Colore solido</option>
 <option value="gradient">Gradiente</option>
 <option value="image">Immagine</option>
 </select>
 </div>
 </fieldset>
 
 <div class="control-group" id="bg-color-controls">
 <strong class="control-group-title">Colore</strong>
 <select id="c">
 <option value="white" selected>Bianco</option>
 <option value="transparent">Trasparente</option>
 <option value="black">Nero</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 <option value="gray">Grigio</option>
 <option value="brown">Marrone</option>
 <option value="custom">Personalizzato...</option>
 </select>
 
 <!-- Sezione colore personalizzato (nascosta inizialmente) -->
 <div id="bg-color-custom-section" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-input); border-radius: 6px;">
 <h4 style="font-size: 14px; margin-bottom: 8px;">Colore Personalizzato</h4>
 <div class="control-row" style="gap: 8px;">
 <div class="input-with-label flex-1" >
 <label for="bg-color-hex">Codice HEX</label>
 <input type="text" id="bg-color-hex" placeholder="#ffffff" maxlength="7" pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="control-row" style="gap: 8px; margin-top: 8px;">
 <div class="input-with-label flex-1" >
 <label for="bg-color-r">R (Rosso)</label>
 <input type="number" id="bg-color-r" min="0" max="255" value="255">
 </div>
 <div class="input-with-label flex-1" >
 <label for="bg-color-g">G (Verde)</label>
 <input type="number" id="bg-color-g" min="0" max="255" value="255">
 </div>
 <div class="input-with-label flex-1" >
 <label for="bg-color-b">B (Blu)</label>
 <input type="number" id="bg-color-b" min="0" max="255" value="255">
 </div>
 </div>
 <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px; text-align: center;">
 <div id="bg-color-preview" style="width: 100%; height: 40px; border-radius: 4px; background: #ffffff;"></div>
 <span id="bg-color-preview-text" style="font-size: 12px; color: var(--text-secondary);">Anteprima colore</span>
 </div>
 </div>
 </div>
 </div>
 
 <!-- CONTROLLI GRADIENTE (mostrati quando si seleziona gradiente) -->
 <div class="control-group" id="bg-gradient-controls" style="display:none; margin-top: 16px;">
 
 <!-- Toggle HEX/RGB (FUORI dal fieldset per non confondere NVDA) -->
 <div role="radiogroup" aria-label="Formato colore" style="margin-bottom: 12px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="bg-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="bg-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <fieldset style="border: none; padding: 0; margin: 0;">
 <legend style="font-weight: 600; font-size: 14px; margin-bottom: 12px;">Configurazione Gradiente</legend>
 
 <!-- Colore 1 -->
 <strong class="control-group-title">Colore 1</strong>
 <div class="control-row">
 <div class="input-with-label" id="bg-gradient-hex-controls">
 <label for="bg-gradient-color1-hex" class="sr-only">Codice HEX Colore 1</label>
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="bg-gradient-color1" value="#3b82f6" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="bg-gradient-color1-hex" value="#3b82f6"
 placeholder="#000000" maxlength="7"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="input-with-label" id="bg-gradient-rgb-controls" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="bg-gradient-color1-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="bg-gradient-color1-r" min="0" max="255" value="59" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="bg-gradient-color1-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="bg-gradient-color1-g" min="0" max="255" value="130" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="bg-gradient-color1-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="bg-gradient-color1-b" min="0" max="255" value="246" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <!-- Colore 2 -->
 <strong class="control-group-title" style="margin-top: 16px; display: block;">Colore 2</strong>
 <div class="control-row">
 <div class="input-with-label" id="bg-gradient-hex-controls-2">
 <label for="bg-gradient-color2-hex" class="sr-only">Codice HEX Colore 2</label>
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="bg-gradient-color2" value="#8b5cf6" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="bg-gradient-color2-hex" value="#8b5cf6"
 placeholder="#ffffff" maxlength="7"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="input-with-label" id="bg-gradient-rgb-controls-2" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="bg-gradient-color2-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="bg-gradient-color2-r" min="0" max="255" value="139" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="bg-gradient-color2-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="bg-gradient-color2-g" min="0" max="255" value="92" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="bg-gradient-color2-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="bg-gradient-color2-b" min="0" max="255" value="246" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <!-- Tipo Sfumatura con Radio Buttons -->
 <strong class="control-group-title" style="margin-top: 16px; display: block;">Tipo di Sfumatura</strong>
 <div style="display: flex; flex-direction: column; gap: 8px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="bg-gradient-type" id="bg-gradient-linear" value="linear" checked style="margin-right: 8px;">
 <span>Lineare: sfumatura dritta da un punto all'altro</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="bg-gradient-type" id="bg-gradient-radial" value="radial" style="margin-right: 8px;">
 <span>Radiale: sfumatura circolare dal centro ai bordi</span>
 </label>
 </div>
 
 <!-- Angolo (solo lineare) -->
 <div class="input-with-label" style="margin-top:12px;" id="bg-gradient-angle-container">
 <label for="bg-gradient-angle">Angolo (solo lineare)</label>
 <div class="slider-group">
 <input type="range" id="bg-gradient-angle" min="0" max="360" value="90">
 <span class="slider-value" id="bg-gradient-angle-value">90°</span>
 </div>
 </div>
 </fieldset>
 </div>
 
 <!-- CONTROLLI IMMAGINE -->
 <div class="control-group" id="bg-image-controls" style="display:none; margin-top: 16px;">
 <strong class="control-group-title">Immagine</strong>
 <input type="file" id="bg-image-upload" accept="image/*">
 <button class="btn btn-success btn-full" id="btn-describe-bg-upload" style="margin-top: 12px; display: none;" aria-describedby="describe-bg-help">
 Descrivi questa Immagine con AI
 </button>
 <p id="describe-bg-help" class="sr-only">Usa Gemini AI per ottenere una descrizione dell'immagine di sfondo</p>
 <div class="input-with-label" style="margin-top:12px;">
 <label for="bg-image-fit">Adattamento</label>
 <select id="bg-image-fit">
 <option value="cover" selected>Copri tutto</option>
 <option value="contain">Contenuto</option>
 <option value="stretch">Allunga</option>
 <option value="tile">Ripeti</option>
 </select>
 </div></div>

 <!-- NOTA INFORMATIVA -->
 <div style="margin-top: 12px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 6px;">
 <p style="margin: 0; font-size: 14px; line-height: 1.5; color: #1e3a8a;">
 <strong> Nota:</strong> Per modificare l'immagine di sfondo (dimensioni, posizione, filtri, effetti), selezionala nel pannello <strong>"Livelli"</strong> e usa <strong>"Modifica Livello"</strong> (sezione 8).
 </p>
 </div>
 </div>
 
 <!-- PULSANTE APPLICA SFONDO -->
 <button class="btn btn-primary btn-full" id="btn-apply-bg" style="margin-top:16px;">Applica Sfondo</button>
 </div>
 </section>
 
 <!-- PANNELLO 3: IMMAGINI -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">3</span>
 <h2 class="section-heading">Immagini</h2>
 </div>
 <div class="section-content" id="image-section">
 <p class="section-description">Carica e configura immagini</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div class="control-group">
 <strong class="control-group-title">Carica</strong>
 <input type="file" id="image-upload" accept="image/*">
 <button class="btn btn-success btn-full" id="btn-describe-upload" style="margin-top: 12px; display: none;" aria-describedby="describe-upload-help">
 Descrivi questa Immagine con AI
 </button>
 <p id="describe-upload-help" class="sr-only">Usa Gemini AI per ottenere una descrizione dettagliata dell'immagine caricata</p>
 </div>
 
 <div class="control-group" id="new-image-size-controls">
 <strong class="control-group-title">Dimensioni</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-img-width">Larghezza (px)</label>
 <input type="number" id="new-img-width" min="10" max="2000" value="200">
 </div>
 <div class="input-with-label">
 <label for="new-img-height">Altezza (px)</label>
 <input type="number" id="new-img-height" min="10" max="2000" value="200">
 </div>
 </div>
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 8px;">
 <input type="checkbox" id="new-img-lock-ratio" checked>
 <span>Mantieni proporzioni</span>
 </label>
 </div>
 
 <div class="control-group" id="new-image-position-controls">
 <strong class="control-group-title">Posizione</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-img-x">Posizione X</label>
 <input type="number" id="new-img-x" value="100">
 </div>
 <div class="input-with-label">
 <label for="new-img-y">Posizione Y</label>
 <input type="number" id="new-img-y" value="100">
 </div>
 </div>
 </div>
 
 <!-- NOTA INFORMATIVA -->
 <div style="margin-top: 16px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 6px;">
 <p style="margin: 0; font-size: 14px; line-height: 1.5; color: #1e3a8a;">
 <strong> Nota:</strong> Dopo aver aggiunto l'immagine, usa il pannello <strong>"Modifica Livello"</strong> (sezione 8) per applicare filtri, effetti, rotazione, opacità e ritaglio.
 </p>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 4: TESTO -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">4</span>
 <h2 class="section-heading">Testo</h2>
 </div>
 <div class="section-content" id="text-section">
 <p class="section-description">Scrivi e formatta il testo</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div class="control-group">
 <strong class="control-group-title">Contenuto</strong>
 <textarea id="text-input" placeholder="Inserisci il tuo testo qui..." rows="3"></textarea>
 <div id="text-lines-info" style="margin-top: 8px; font-size: 13px; color: var(--text-secondary);"></div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Font</strong>
 <select id="nff">
 <option value="Arial" selected>Arial</option>
 <option value="Montserrat">Montserrat</option>
 <option value="Open Sans">Open Sans</option>
 <option value="Roboto">Roboto</option>
 <option value="Lato">Lato</option>
 <option value="Poppins">Poppins</option>
 <option value="Raleway">Raleway</option>
 <option value="Oswald">Oswald</option>
 <option value="Merriweather">Merriweather</option>
 <option value="Playfair Display">Playfair Display</option>
 <option value="Georgia">Georgia</option>
 <option value="Times New Roman">Times New Roman</option>
 <option value="Courier New">Courier New</option>
 <option value="Verdana">Verdana</option>
 <option value="Trebuchet MS">Trebuchet MS</option>
 <option value="Impact">Impact</option>
 <option value="Comic Sans MS">Comic Sans MS</option>
 </select>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Dimensioni</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-font-size">Dimensione</label>
 <input type="number" id="new-font-size" min="8" max="200" value="32">
 </div>
 <div class="input-with-label">
 <label for="nfw">Peso</label>
 <select id="nfw">
 <option value="100">Thin 100</option>
 <option value="200">Extra Light 200</option>
 <option value="300">Light 300</option>
 <option value="400" selected>Regular 400</option>
 <option value="500">Medium 500</option>
 <option value="600">Semi Bold 600</option>
 <option value="700">Bold 700</option>
 <option value="800">Extra Bold 800</option>
 <option value="900">Black 900</option>
 </select>
 </div>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Colore</strong>
 <label for="tc" class="sr-only">Seleziona colore testo</label>
 <select id="tc">
 <option value="black">Nero</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 <option value="gray">Grigio</option>
 <option value="brown">Marrone</option>
 <option value="gold">Oro</option>
 <option value="silver">Argento</option>
 <option value="custom">Personalizzato...</option>
 </select>
 
 <!-- Sezione colore personalizzato (nascosta inizialmente) -->
 <div id="text-color-custom-section" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-input); border-radius: 6px;">
 <h4 style="font-size: 14px; margin-bottom: 8px;">Colore Personalizzato</h4>
 <div class="control-row" style="gap: 8px;">
 <div class="input-with-label flex-1" >
 <label for="text-color-hex">Codice HEX</label>
 <input type="text" id="text-color-hex" placeholder="#000000" maxlength="7" pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="control-row" style="gap: 8px; margin-top: 8px;">
 <div class="input-with-label flex-1" >
 <label for="text-color-r">R (Rosso)</label>
 <input type="number" id="text-color-r" min="0" max="255" value="0">
 </div>
 <div class="input-with-label flex-1" >
 <label for="text-color-g">G (Verde)</label>
 <input type="number" id="text-color-g" min="0" max="255" value="0">
 </div>
 <div class="input-with-label flex-1" >
 <label for="text-color-b">B (Blu)</label>
 <input type="number" id="text-color-b" min="0" max="255" value="0">
 </div>
 </div>
 <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px; text-align: center;">
 <div id="text-color-preview" style="width: 100%; height: 40px; border-radius: 4px; background: #000000;"></div>
 <span id="text-color-preview-text" style="font-size: 12px; color: var(--text-secondary);">Anteprima colore</span>
 </div>
 </div>
 </div>
 
 <!-- NOTA INFORMATIVA -->
 <div style="margin-top: 16px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 6px;">
 <p style="margin: 0; font-size: 14px; line-height: 1.5; color: #1e3a8a;">
 <strong> Nota:</strong> Dopo aver aggiunto il testo, usa il pannello <strong>"Modifica Livello"</strong> (sezione 8) per cambiare posizione, rotazione, opacità, ombra e altri effetti avanzati.
 </p>
 </div>
 
 <div style="margin-top: 32px; padding-top: 20px; border-top: 2px solid var(--border-color);">
 <button class="btn btn-primary btn-full" id="btn-add-text" aria-describedby="add-text-help">
 ️ Aggiungi Testo al Canvas
 </button>
 <p id="add-text-help" class="sr-only">Clicca per aggiungere il testo configurato sopra al canvas</p>
 </div>
 </div>
 
 <!-- PULSANTE TOGGLE AVANZATE -->
 <button class="btn btn-toggle-advanced" id="toggle-text-advanced" aria-expanded="false" aria-controls="text-advanced">
 <span class="icon">▼</span>
 <span>Impostazioni Avanzate</span>
 </button>
 
 <!-- OPZIONI AVANZATE -->
 <div class="advanced-section collapsed" id="text-advanced">
 <div class="control-group">
 <strong class="control-group-title">Spaziatura</strong>
 <div class="input-with-label">
 <label for="new-line-height">Interlinea</label>
 <div class="slider-group">
 <input type="range" id="new-line-height" min="0.5" max="3" value="1.2" step="0.1">
 <span class="slider-value" id="new-line-height-value">1.2</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="new-letter-spacing">Spaziatura lettere</label>
 <div class="slider-group">
 <input type="range" id="new-letter-spacing" min="-5" max="20" value="0" step="0.5">
 <span class="slider-value" id="new-letter-spacing-value">0 px</span>
 </div>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Allineamento Testo</strong>
 <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
 <strong>IMPORTANTE:</strong> Questo controlla come il testo si allinea rispetto alla coordinata X che imposti. <strong>Sinistra</strong> = X è il bordo sinistro, <strong>Centro</strong> = X è il centro del testo, <strong>Destra</strong> = X è il bordo destro. Influenza anche come si allineano le righe tra loro.
 </p>
 <div class="btn-group">
 <button class="btn btn-secondary" id="new-btn-align-left" title="X rappresenta il bordo sinistro del testo">Sinistra</button>
 <button class="btn btn-secondary" id="new-btn-align-center" title="X rappresenta il centro del testo">Centro</button>
 <button class="btn btn-secondary" id="new-btn-align-right" title="X rappresenta il bordo destro del testo">Destra</button>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Posizione</strong>
 <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
 Dove vuoi mettere il testo nel canvas. Usa il pulsante "Centra nel Canvas" per posizionarlo automaticamente al centro.
 </p>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-text-x">Posizione X</label>
 <input type="number" id="new-text-x" value="100">
 </div>
 <div class="input-with-label">
 <label for="new-text-y">Posizione Y</label>
 <input type="number" id="new-text-y" value="100">
 </div>
 </div>
 <button class="btn btn-info btn-full mt-8" id="btn-center-text-position" >
 Centra nel Canvas
 </button>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 5: FORME -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">5</span>
 <h2 class="section-heading">Forme</h2>
 </div>
 <div class="section-content" id="shapes-section">
 <p class="section-description">Aggiungi forme geometriche</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div class="control-group">
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-add-rect">Rettangolo</button>
 <button class="btn btn-secondary" id="btn-add-circle">Cerchio</button>
 <button class="btn btn-secondary" id="btn-add-triangle">Triangolo</button>
 </div>
 </div>
 
 <div class="control-group" id="new-shape-colors">
 <strong class="control-group-title">Colori</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-shape-fill">Riempimento</label>
 <select id="new-shape-fill">
 <option value="#3b82f6" selected>Blu</option>
 <option value="#000000">Nero</option>
 <option value="#ffffff">Bianco</option>
 <option value="#ff0000">Rosso</option>
 <option value="#00ff00">Verde</option>
 <option value="#ffff00">Giallo</option>
 <option value="#ff00ff">Magenta</option>
 <option value="#00ffff">Ciano</option>
 <option value="#ffa500">Arancione</option>
 <option value="#800080">Viola</option>
 <option value="#ffc0cb">Rosa</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="new-shape-stroke">Bordo</label>
 <select id="new-shape-stroke">
 <option value="#1e40af">Blu Scuro</option>
 <option value="#000000">Nero</option>
 <option value="#ffffff">Bianco</option>
 <option value="#ff0000">Rosso</option>
 <option value="#00ff00">Verde</option>
 <option value="#0000ff">Blu</option>
 <option value="#ffff00">Giallo</option>
 <option value="#ff00ff">Magenta</option>
 <option value="#ffa500">Arancione</option>
 <option value="#800080">Viola</option>
 </select>
 </div>
 </div>
 </div>
 
 <!-- NOTA INFORMATIVA -->
 <div style="margin-top: 16px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 6px;">
 <p style="margin: 0; font-size: 14px; line-height: 1.5; color: #1e3a8a;">
 <strong> Nota:</strong> Dopo aver aggiunto la forma, usa il pannello <strong>"Modifica Livello"</strong> (sezione 8) per cambiare dimensioni, posizione, rotazione e opacità.
 </p>
 </div>
 </div>
 
 <!-- PULSANTE TOGGLE AVANZATE -->
 <button class="btn btn-toggle-advanced" id="toggle-shapes-advanced" aria-expanded="false" aria-controls="shapes-advanced">
 <span class="icon">▼</span>
 <span>Impostazioni Avanzate</span>
 </button>
 
 <!-- OPZIONI AVANZATE -->
 <div class="advanced-section collapsed" id="shapes-advanced">
 <div class="control-group">
 <strong class="control-group-title">Avanzate</strong>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-add-star">Stella 5</button>
 <button class="btn btn-secondary" id="btn-add-star8">Stella 8</button>
 <button class="btn btn-secondary" id="btn-add-heart">Cuore</button>
 <button class="btn btn-secondary" id="btn-add-speech">Fumetto</button>
 <button class="btn btn-secondary" id="btn-add-line">Linea</button>
 <button class="btn btn-secondary" id="btn-add-hexagon">Esagono</button>
 <button class="btn btn-secondary" id="btn-add-arrow">Freccia</button>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Stile</strong>
 <select id="new-line-style">
 <option value="solid" selected>Solida</option>
 <option value="dashed">Tratteggiata</option>
 <option value="dotted">Puntinata</option>
 </select>
 </div>
 
 <div class="control-group" id="new-rect-corner-group" style="display:none;">
 <strong class="control-group-title">Angoli</strong>
 <div class="slider-group">
 <input type="range" id="new-corner-radius" min="0" max="50" value="0">
 <span class="slider-value" id="new-corner-radius-value">0%</span>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Posizione</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="new-shape-x">Posizione X</label>
 <input type="number" id="new-shape-x" value="100">
 </div>
 <div class="input-with-label">
 <label for="new-shape-y">Posizione Y</label>
 <input type="number" id="new-shape-y" value="100">
 </div>
 </div>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 6: DISEGNO VETTORIALE -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">6</span>
 <h2 class="section-heading">Disegno Vettoriale</h2>
 </div>
 <div class="section-content" id="vector-section">
 <p class="section-description">Disegna forme personalizzate usando solo la tastiera</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div class="vector-status">
 <div class="vector-status-indicator" id="vector-status-indicator"></div>
 <span class="vector-status-text" id="vector-status-text">Modalità disattivata</span>
 </div>
 
 <button class="btn btn-primary btn-full" id="btn-toggle-vector">
 Attiva Disegno Vettoriale (Ctrl+P)
 </button>
 
 <div id="vector-active-controls">
 <div class="control-group" style="margin-top: 16px;">
 <strong class="control-group-title">Area Disegno Attiva</strong>
 <div style="background: #dbeafe; padding: 16px; border-radius: var(--radius); border: 2px solid var(--primary-color);">
 <p style="font-weight: 600; color: var(--primary-color); margin-bottom: 12px;">
 Clicca qui sotto o usa Tab per entrare in modalità disegno
 </p>
 <div id="vector-focus-area" 
 tabindex="0" 
 role="button"
 aria-label="Area disegno vettoriale. Premi Invio per attivare, poi usa frecce per disegnare"
 style="background: white; padding: 20px; border-radius: 6px; border: 2px dashed var(--primary-color); min-height: 80px; display: flex; align-items: center; justify-content: center; font-weight: 600; color: var(--text-secondary); cursor: pointer;">
 Premi Invio per attivare il disegno
 </div>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Istruzioni Tasti</strong>
 <div style="background: var(--bg-input); padding: 12px; border-radius: var(--radius); font-size: 13px; line-height: 1.6;">
 <strong>Frecce:</strong> Muovi cursore<br>
 <strong>Shift + Frecce:</strong> Movimento veloce<br>
 <strong>Ctrl + Frecce:</strong> Movimento lento/preciso<br>
 <strong>Invio:</strong> Posiziona punto<br>
 <strong>C:</strong> Chiudi forma (min 3 punti)<br>
 <strong>O:</strong> Tracciato aperto (min 2 punti)<br>
 <strong>G:</strong> Prepara area per immagine (min 3 punti)<br>
 <strong>I:</strong> Leggi posizione corrente e numero punti<br>
 <strong>Ctrl+Z:</strong> Rimuovi ultimo punto<br>
 <strong>Esc:</strong> Annulla disegno
 </div>
 <div style="background: #dbeafe; padding: 12px; border-radius: var(--radius); font-size: 12px; margin-top: 8px; border: 1px solid #3b82f6;">
 <strong> Nuova Modalità Manuale:</strong> Dopo aver disegnato un'area (min 3 punti), premi <strong>G</strong> per prepararla. Ti verrà mostrata la dimensione esatta necessaria. Genera l'immagine con la tua AI preferita (ChatGPT, Midjourney, ecc.) e caricala!
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Velocità Movimento</strong>
 <div class="slider-group">
 <input type="range" id="vector-step" min="1" max="20" value="5">
 <span class="slider-value" id="vector-step-value">5 px</span>
 </div>
 </div>
 </div>
 
 <div class="vector-info" id="vector-points-info">
 <div class="vector-info-title">Punti posizionati</div>
 <div class="vector-info-text" id="vector-points-count">Nessun punto</div>
 </div>
 
 <!-- NOTA INFORMATIVA -->
 <div style="margin-top: 16px; padding: 12px; background: #dbeafe; border-left: 4px solid #3b82f6; border-radius: 6px;">
 <p style="margin: 0; font-size: 14px; line-height: 1.5; color: #1e3a8a;">
 <strong> Nota:</strong> Dopo aver creato il disegno, usa il pannello <strong>"Modifica Livello"</strong> (sezione 8) per cambiare colori, dimensioni, posizione, rotazione e opacità.
 </p>
 </div>
 </div>
 
 <!-- PULSANTE TOGGLE AVANZATE -->
 <button class="btn btn-toggle-advanced" id="toggle-vector-advanced" aria-expanded="false" aria-controls="vector-advanced">
 <span class="icon">▼</span>
 <span>Impostazioni Avanzate</span>
 </button>
 
 <!-- OPZIONI AVANZATE -->
 <div class="advanced-section collapsed" id="vector-advanced">
 <div class="control-group">
 <strong class="control-group-title">Colori</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="vfc" class="sr-only">Riempimento</label>
 <select id="vfc">
 <option value="lightblue" selected>Blu</option>
 <option value="black">Nero</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="vsc" class="sr-only">Bordo</label>
 <select id="vsc">
 <option value="darkblue" selected>Blu Scuro</option>
 <option value="black">Nero</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="purple">Viola</option>
 <option value="orange">Arancione</option>
 </select>
 </div>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Bordo</strong>
 <input type="number" id="vector-stroke-width" min="0" max="20" value="2">
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Tipo Forma</strong>
 <div style="display: flex; align-items: center; gap: 8px; padding: 8px; background: var(--bg-input); border-radius: var(--radius);">
 <input type="checkbox" id="vector-close-path" checked aria-describedby="vector-close-path-help">
 <label for="vector-close-path" style="cursor: pointer; user-select: none;">
 Chiudi forma automaticamente (unisce ultimo punto al primo)
 </label>
 </div>
 <p id="vector-close-path-help" style="font-size: 12px; color: var(--text-secondary); margin-top: 6px; line-height: 1.5;">
 <strong>Attivo:</strong> Forme chiuse (triangolo, quadrato, stella, ecc.)<br>
 <strong>Disattivo:</strong> Forme aperte (linee, frecce, croci, lettere come "L" o "T")
 </p>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 7: MODIFICA LIVELLO -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">7</span>
 <h2 class="section-heading">Modifica Livello</h2>
 </div>
 <div class="section-content" id="edit-section">
 <p class="section-description" id="edit-description">Seleziona un livello per modificarlo</p>
 
 <!-- BOX DIMENSIONI TESTO - sempre visibile, aggiornato dinamicamente -->
 <div class="text-dimensions-info" id="text-dimensions-box" style="margin: 16px 0; padding: 16px; background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #3b82f6; border-radius: 8px; font-size: 14px; line-height: 1.8; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.2);" role="region" aria-label="Informazioni dimensioni testo sul canvas">
 <div>
 <strong>Spazio occupato sul canvas:</strong><br>
 <span id="text-dim-width" style="display: inline-block; margin: 4px 0;">Larghezza: 2595 pixel</span><br>
 <span id="text-dim-height" style="display: inline-block; margin: 4px 0;">Altezza: 288 pixel</span><br>
 <span id="text-dim-lines" style="display: inline-block; margin: 4px 0; font-weight: 600; color: #1e40af;">Righe di testo: 3</span><br>
 <button onclick="window.showTextDimensions && window.showTextDimensions(); console.log('Aggiornamento dimensioni forzato');" 
 style="margin-top: 8px; padding: 6px 12px; background: #3b82f6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
 Aggiorna Dimensioni
 </button>
 </div>
 </div>
 
 <div class="control-group hidden" id="layer-name-controls" >
 <strong class="control-group-title">Nome</strong>
 <div style="display: flex; gap: 8px;">
 <input type="text" id="layer-name-input" placeholder="Nome livello..." class="flex-1">
 <button class="btn btn-primary" id="btn-rename-layer">Rinomina</button>
 </div>
 </div>
 
 <div class="control-group hidden" id="text-edit-controls" >
 <strong class="control-group-title">Contenuto</strong>
 <div style="margin-bottom: 12px;">
 <textarea id="text-edit" placeholder="Modifica il testo..."></textarea>
 <button class="btn btn-full" id="btn-apply-text-edit" style="margin-top:8px;">Applica Modifiche</button>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Anteprima</strong>
 <div class="live-preview" id="text-preview">Testo di prova</div>
 </div>
 </div>
 
 <div class="control-group hidden" id="font-controls" >
 <strong class="control-group-title">Font</strong>
 <!-- Select popolato dinamicamente in base a connettività -->
 <select id="ff">
 <option value="Arial">Caricamento font...</option>
 </select>
 
 <div class="control-row mt-12" >
 <div class="input-with-label">
 <label for="font-size">Dimensione</label>
 <input type="number" id="font-size" min="8" max="200" value="32">
 </div>
 <div class="input-with-label">
 <label for="fw">Peso</label>
 <select id="fw">
 <option value="100">Thin 100</option>
 <option value="200">Extra Light 200</option>
 <option value="300">Light 300</option>
 <option value="400" selected>Regular 400</option>
 <option value="500">Medium 500</option>
 <option value="600">Semi Bold 600</option>
 <option value="700">Bold 700</option>
 <option value="800">Extra Bold 800</option>
 <option value="900">Black 900</option>
 </select>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="text-spacing-controls" >
 <strong class="control-group-title">Spaziatura</strong>
 <div class="input-with-label">
 <label for="letter-spacing">Spaziatura lettere</label>
 <div class="slider-group">
 <input type="range" id="letter-spacing" min="-5" max="20" value="0" step="0.5" title="Regola lo spazio tra le lettere">
 <span class="slider-value" id="letter-spacing-value">0 px</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="line-height">Altezza riga</label>
 <div class="slider-group">
 <input type="range" id="line-height" min="0.5" max="3" value="1.2" step="0.1" title="Regola l'altezza delle righe">
 <span class="slider-value" id="line-height-value">1.2</span>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="text-style-controls" >
 <strong class="control-group-title">Stili</strong>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-italic" title="Corsivo">
 I
 </button>
 <button class="btn btn-secondary" id="btn-underline" title="Sottolineato">
 U
 </button>
 <button class="btn btn-secondary" id="btn-line-through" title="Barrato">
 S
 </button>
 </div>
 </div>
 
 <div class="control-group hidden" id="text-align-controls" >
 <strong class="control-group-title">Allineamento Righe</strong>
 <div class="alignment-grid">
 <button class="btn btn-secondary alignment-btn" id="btn-align-left" title="Allinea righe a sinistra">Sinistra</button>
 <button class="btn btn-secondary alignment-btn" id="btn-align-center" title="Allinea righe al centro">Centro</button>
 <button class="btn btn-secondary alignment-btn" id="btn-align-right" title="Allinea righe a destra">Destra</button>
 </div>
 
 <strong class="control-group-title" style="margin-top: 16px; display: block;">Posizione nel Canvas</strong>
 <div style="display: grid; gap: 8px;">
 <button class="btn btn-primary" id="btn-center-in-canvas" title="Centra il blocco testo nel canvas">
 Centra nel Canvas
 </button>
 <div style="font-size: 11px; color: var(--text-secondary); padding: 4px 8px; background: var(--bg-input); border-radius: 4px;">
 Posiziona il testo al centro visivo del canvas
 </div>
 <button class="btn btn-success" id="btn-center-social" 
 title="Centra considerando le safe zone di tutti i social" 
 style="margin-top: 8px;">
 Centra per Social
 </button>
 <div style="font-size: 11px; color: #059669; padding: 4px 8px; background: #d1fae5; border-radius: 4px; margin-top: 4px;">
 Safe zone universale (Instagram, TikTok, Facebook, YouTube, Twitter, ecc.)
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="color-controls" >
 <strong class="control-group-title">Colore</strong>
 <select id="lc">
 <option value="black">Nero</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 <option value="gray">Grigio</option>
 <option value="brown">Marrone</option>
 <option value="custom">Personalizzato...</option>
 <option value="eyedropper">Usa Contagocce</option>
 </select>
 
 <div id="layer-color-custom-section" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-input); border-radius: 6px;">
 <h4 style="font-size: 14px; margin-bottom: 8px;">Colore Personalizzato</h4>
 <div class="control-row" style="gap: 8px;">
 <div class="input-with-label flex-1" >
 <label for="layer-color-hex">HEX</label>
 <input type="text" id="layer-color-hex" placeholder="#000000" maxlength="7" pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="control-row" style="gap: 8px; margin-top: 8px;">
 <div class="input-with-label flex-1" >
 <label for="layer-color-r">R</label>
 <input type="number" id="layer-color-r" min="0" max="255" value="0">
 </div>
 <div class="input-with-label flex-1" >
 <label for="layer-color-g">G</label>
 <input type="number" id="layer-color-g" min="0" max="255" value="0">
 </div>
 <div class="input-with-label flex-1" >
 <label for="layer-color-b">B</label>
 <input type="number" id="layer-color-b" min="0" max="255" value="0">
 </div>
 </div>
 <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px;">
 <div id="layer-color-preview" style="width: 100%; height: 40px; border-radius: 4px; background: #000000;"></div>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="gradient-panel" >
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 12px;">
 <input type="checkbox" id="use-gradient">
 <strong class="control-group-title" style="margin: 0;">Usa Gradiente</strong>
 </label>
 
 <div id="gradient-controls" class="hidden">
 <div class="gradient-preview" id="gradient-preview"></div>
 
 <div class="input-with-label">
 <label for="gradient-type">
 <strong>Tipo di Gradiente Layer</strong>
 </label>
 <select id="gradient-type" aria-label="Tipo di gradiente">
 <option value="linear">Lineare</option>
 <option value="radial">Radiale</option>
 </select>
 </div>
 
 <!-- Toggle HEX/RGB per gradiente forme -->
 <div role="radiogroup" aria-label="Formato colore gradiente" style="margin-bottom: 12px; margin-top: 12px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="layer-gradient-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="layer-gradient-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Colore 1 -->
 <strong class="control-group-title">Colore 1</strong>
 <div class="control-row">
 <div class="input-with-label" id="layer-gradient-hex-controls-1">
 <label for="gradient-color1-hex" class="sr-only">Codice HEX Colore 1</label>
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="gradient-color1" value="#ff0000" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="gradient-color1-hex" value="#ff0000" 
 placeholder="#000000" maxlength="7"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="input-with-label" id="layer-gradient-rgb-controls-1" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="gradient-color1-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="gradient-color1-r" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradient-color1-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="gradient-color1-g" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradient-color1-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="gradient-color1-b" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <!-- Colore 2 -->
 <strong class="control-group-title" style="margin-top: 16px; display: block;">Colore 2</strong>
 <div class="control-row">
 <div class="input-with-label" id="layer-gradient-hex-controls-2">
 <label for="gradient-color2-hex" class="sr-only">Codice HEX Colore 2</label>
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="gradient-color2" value="#0000ff" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="gradient-color2-hex" value="#0000ff"
 placeholder="#ffffff" maxlength="7"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 <div class="input-with-label" id="layer-gradient-rgb-controls-2" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="gradient-color2-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="gradient-color2-r" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradient-color2-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="gradient-color2-g" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradient-color2-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="gradient-color2-b" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <div class="input-with-label" style="margin-top: 12px;">
 <label for="gradient-angle">Angolo (solo lineare)</label>
 <div class="slider-group">
 <input type="range" id="gradient-angle" min="0" max="360" value="0">
 <span class="slider-value" id="gradient-angle-value">0°</span>
 </div>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="stroke-panel" >
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 12px;">
 <input type="checkbox" id="use-stroke">
 <strong style="margin: 0;">Bordo</strong>
 </label>
 
 <div id="stroke-controls" class="hidden">
 <div class="control-row">
 <div class="input-with-label">
 <label for="sc">Colore Bordo</label>
 <select id="sc">
 <option value="black" selected>Nero</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 <option value="custom">Personalizzato...</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="stroke-width">Spessore</label>
 <input type="number" id="stroke-width" min="1" max="50" value="2">
 </div>
 </div>
 
 <!-- Sezione colore personalizzato bordo -->
 <div id="stroke-color-custom-section" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-input); border-radius: 6px;">
 <h4 style="font-size: 14px; margin-bottom: 8px;">Colore Bordo Personalizzato</h4>
 
 <!-- Toggle HEX/RGB per Bordo -->
 <div role="radiogroup" aria-label="Formato colore bordo" style="margin-bottom: 8px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="stroke-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="stroke-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Controlli HEX -->
 <div id="stroke-hex-controls">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="stroke-color-picker" value="#000000" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="stroke-color-hex" value="#000000" 
 placeholder="#000000" maxlength="7" aria-label="Codice HEX colore bordo"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="stroke-rgb-controls" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="stroke-color-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="stroke-color-r" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="stroke-color-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="stroke-color-g" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="stroke-color-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="stroke-color-b" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 
 <!-- Preview colore -->
 <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px;">
 <div id="stroke-color-preview" style="width: 100%; height: 40px; border-radius: 4px; background: #000000;"></div>
 </div>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="transform-controls" >
 <strong class="control-group-title">Posizione</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="pos-x">X</label>
 <input type="number" id="pos-x" value="0">
 </div>
 <div class="input-with-label">
 <label for="pos-y">Y</label>
 <input type="number" id="pos-y" value="0">
 </div>
 </div>
 
 <strong class="control-group-title">Dimensione</strong>
 <div class="control-row">
 <div class="input-with-label">
 <label for="width">Larghezza</label>
 <input type="number" id="width" min="1" value="100">
 </div>
 <div class="input-with-label">
 <label for="height">Altezza</label>
 <input type="number" id="height" min="1" value="100">
 </div>
 </div>
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-top: 8px;">
 <input type="checkbox" id="maintain-aspect" checked>
 <span>Mantieni proporzioni</span>
 </label>
 
 <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color);">
 <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Scala Percentuale</h4>
 <div class="control-row">
 <div class="input-with-label">
 <label for="scale-percent">Scala al %</label>
 <input type="number" id="scale-percent" min="1" max="500" value="100" style="width: 100%;">
 </div>
 <button class="btn btn-primary flex-1" id="btn-apply-scale" >Applica</button>
 </div>
 <div class="btn-group mt-8" >
 <button class="btn btn-secondary" id="btn-scale-50">50%</button>
 <button class="btn btn-secondary" id="btn-scale-75">75%</button>
 <button class="btn btn-secondary" id="btn-scale-150">150%</button>
 <button class="btn btn-secondary" id="btn-scale-200">200%</button>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="corner-radius-group" >
 <strong class="control-group-title">Angoli</strong>
 <div class="slider-group">
 <input type="range" id="corner-radius" min="0" max="100" value="0" title="Arrotonda gli angoli dei rettangoli">
 <span class="slider-value" id="corner-radius-value">0 px</span>
 </div>
 </div>
 
 <div class="control-group hidden" id="rotation-controls" >
 <strong class="control-group-title">Rotazione</strong>
 <div class="slider-group">
 <input type="range" id="rotation" min="0" max="360" value="0">
 <span class="slider-value" id="rotation-value">0°</span>
 </div>
 <div class="btn-group mt-8" >
 <button class="btn btn-secondary" id="btn-rotate-90">↻ 90°</button>
 <button class="btn btn-secondary" id="btn-rotate-180">↻ 180°</button>
 <button class="btn btn-secondary" id="btn-rotate-270">↻ 270°</button>
 <button class="btn btn-secondary" id="btn-rotate-reset">⟲ 0°</button>
 </div>
 </div>
 
 <div class="control-group hidden" id="flip-controls" >
 <strong class="control-group-title">Rifletti</strong>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-flip-h">Orizzontale</button>
 <button class="btn btn-secondary" id="btn-flip-v">Verticale</button>
 </div>
 </div>
 
 <div class="control-group hidden" id="crop-group" >
 <strong class="control-group-title">Ritaglia & Posizionamento</strong>
 <button class="btn btn-primary btn-full" id="btn-center-canvas" 
 style="margin-bottom: 8px;"
 role="button" 
 aria-label="Centra immagine nel canvas completo">
 Centra nel Canvas
 </button>
 <button class="btn btn-success btn-full" id="btn-center-social-img" 
 style="margin-bottom: 8px; display: none;"
 role="button" 
 aria-label="Centra immagine nella zona sicura per social">
 Centra per Social
 </button>
 <button class="btn btn-secondary btn-full" id="btn-crop">Ritaglia Immagine</button>
 </div>
 
 <div class="control-group hidden" id="opacity-controls" >
 <strong class="control-group-title">Opacità</strong>
 <div class="slider-group">
 <input type="range" id="opacity" min="0" max="100" value="100">
 <span class="slider-value" id="opacity-value">100%</span>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 9: GESTIONE LIVELLI -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">8</span>
 <h2 class="section-heading">Gestione Livelli</h2>
 </div>
 <div class="section-content" id="layers-section">
 <p class="section-description">Organizza i livelli del tuo progetto</p>
 
 <!-- OPZIONI BASE -->
 <div class="section-basic">
 <div id="layer-list" role="list">
 <!-- Popolato dinamicamente -->
 </div>
 
 <div class="btn-group mt-12" >
 <button class="btn btn-secondary" id="btn-move-up" title="Sposta su">Sposta Su</button>
 <button class="btn btn-secondary" id="btn-move-down" title="Sposta giù">Sposta Giù</button>
 <button class="btn btn-warning" id="btn-lock" title="Blocca/Sblocca">Blocca</button>
 <button class="btn btn-danger" id="btn-delete" title="Elimina">Elimina</button>
 </div>
 </div>
 
 <!-- PULSANTE TOGGLE AVANZATE -->
 <button class="btn btn-toggle-advanced" id="toggle-layers-advanced" aria-expanded="false" aria-controls="layers-advanced">
 <span class="icon">▼</span>
 <span>Impostazioni Avanzate</span>
 </button>
 
 <!-- OPZIONI AVANZATE -->
 <div class="advanced-section collapsed" id="layers-advanced">
 <div class="control-group">
 <strong class="control-group-title">Duplica con Offset</strong>
 <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 8px;">
 Crea una copia spostata di X/Y pixel
 </p>
 <div class="control-row">
 <div class="input-with-label">
 <label for="duplicate-offset-x">Offset X</label>
 <input type="number" id="duplicate-offset-x" value="20" style="width: 100%;">
 </div>
 <div class="input-with-label">
 <label for="duplicate-offset-y">Offset Y</label>
 <input type="number" id="duplicate-offset-y" value="20" style="width: 100%;">
 </div>
 </div>
 <button class="btn btn-primary btn-full mt-8" id="btn-duplicate-offset" >
 Duplica e Sposta
 </button>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 10: ALLINEAMENTO -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">9</span>
 <h2 class="section-heading">Allineamento & Distribuzione</h2>
 </div>
 <div class="section-content" id="align-section">
 <p class="section-description">Allinea e distribuisci elementi in modo professionale</p>
 
 <div class="control-group">
 <strong class="control-group-title">Allinea al Canvas</strong>
 <div class="alignment-grid">
 <button class="btn btn-secondary" id="btn-align-tl">⬉ Alto-Sx</button>
 <button class="btn btn-secondary" id="btn-align-tc">⬆ Alto</button>
 <button class="btn btn-secondary" id="btn-align-tr">⬈ Alto-Dx</button>
 <button class="btn btn-secondary" id="btn-align-ml">⬅ Sinistra</button>
 <button class="btn btn-secondary" id="btn-align-center-2">⊞ Centro</button>
 <button class="btn btn-secondary" id="btn-align-mr"> Destra</button>
 <button class="btn btn-secondary" id="btn-align-bl">⬋ Basso-Sx</button>
 <button class="btn btn-secondary" id="btn-align-bc">⬇ Basso</button>
 <button class="btn btn-secondary" id="btn-align-br">⬊ Basso-Dx</button>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Allinea Elementi tra Loro</strong>
 <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
 Seleziona 2+ elementi (Ctrl+Click) e allineali tra loro
 </p>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-align-left-rel" title="Allinea i bordi sinistri">
 ⬅ Sinistra
 </button>
 <button class="btn btn-secondary" id="btn-align-center-h-rel" title="Allinea i centri orizzontali">
 ↔ Centro H
 </button>
 <button class="btn btn-secondary" id="btn-align-right-rel" title="Allinea i bordi destri">
 Destra
 </button>
 </div>
 <div class="btn-group mt-8" >
 <button class="btn btn-secondary" id="btn-align-top-rel" title="Allinea i bordi superiori">
 ⬆ Alto
 </button>
 <button class="btn btn-secondary" id="btn-align-center-v-rel" title="Allinea i centri verticali">
 ↕ Centro V
 </button>
 <button class="btn btn-secondary" id="btn-align-bottom-rel" title="Allinea i bordi inferiori">
 ⬇ Basso
 </button>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Distribuzione Uniforme</strong>
 <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
 Seleziona 3+ elementi e distribuiscili equidistanti
 </p>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-distribute-h" title="Distribuisci orizzontalmente">
 ↔ Orizzontale
 </button>
 <button class="btn btn-secondary" id="btn-distribute-v" title="Distribuisci verticalmente">
 ↕ Verticale
 </button>
 </div>
 </div>
 </div>
 </section>
 
 <!-- PANNELLO 11: PALETTE COLORI -->
 <!-- PANNELLO 8: EFFETTI & STILI -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">10</span>
 <h2 class="section-heading">Effetti & Stili</h2>
 </div>
 <div class="section-content" id="effects-section">
 <p class="section-description">Applica effetti visivi al livello selezionato</p>
 
 <details style="margin-bottom: 16px; border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; background: var(--bg-secondary);">
 <summary style="cursor: pointer; font-weight: 600; font-size: 16px; user-select: none; list-style: none; outline: none;">
 Stili & Trasformazioni
 </summary>
 <div style="margin-top: 12px;">
 <div class="control-group">
 <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; margin-bottom: 12px;">
 <input type="checkbox" id="shadow-enabled">
 <strong class="control-group-title" style="margin: 0;">Ombra (Drop Shadow)</strong>
 </label>
 
 <div id="shadow-controls" class="hidden">
 <div class="input-with-label">
 <label for="shc">Colore Ombra</label>
 <select id="shc">
 <option value="black" selected>Nero</option>
 <option value="gray">Grigio</option>
 <option value="white">Bianco</option>
 <option value="red">Rosso</option>
 <option value="green">Verde</option>
 <option value="blue">Blu</option>
 <option value="yellow">Giallo</option>
 <option value="magenta">Magenta</option>
 <option value="cyan">Ciano</option>
 <option value="orange">Arancione</option>
 <option value="purple">Viola</option>
 <option value="pink">Rosa</option>
 <option value="custom">Personalizzato...</option>
 </select>
 </div>
 
 <!-- Sezione colore personalizzato Drop Shadow -->
 <div id="shadow-color-custom-section" style="display: none; margin-top: 12px; padding: 12px; background: var(--bg-input); border-radius: 6px;">
 <h4 style="font-size: 14px; margin-bottom: 8px;">Colore Ombra Personalizzato</h4>
 
 <!-- Toggle HEX/RGB per Drop Shadow -->
 <div role="radiogroup" aria-label="Formato colore ombra" style="margin-bottom: 8px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="shadow-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="shadow-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Controlli HEX -->
 <div id="shadow-hex-controls">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="shadow-color-picker" value="#000000" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="shadow-color-hex" value="#000000" 
 placeholder="#000000" maxlength="7" aria-label="Codice HEX colore ombra"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="shadow-rgb-controls" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="shadow-color-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="shadow-color-r" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="shadow-color-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="shadow-color-g" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="shadow-color-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="shadow-color-b" min="0" max="255" value="0" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 
 <!-- Preview colore -->
 <div style="margin-top: 8px; padding: 8px; background: white; border: 1px solid var(--border-color); border-radius: 4px;">
 <div id="shadow-color-preview" style="width: 100%; height: 40px; border-radius: 4px; background: #000000;"></div>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="shadow-blur">Sfocatura</label>
 <div class="slider-group">
 <input type="range" id="shadow-blur" min="0" max="50" value="10">
 <span class="slider-value" id="shadow-blur-value">10 px</span>
 </div>
 </div>
 
 <div class="control-row">
 <div class="input-with-label">
 <label for="shadow-x">Offset X</label>
 <div class="slider-group">
 <input type="range" id="shadow-x" min="-50" max="50" value="5">
 <span class="slider-value" id="shadow-x-value">5 px</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="shadow-y">Offset Y</label>
 <div class="slider-group">
 <input type="range" id="shadow-y" min="-50" max="50" value="5">
 <span class="slider-value" id="shadow-y-value">5 px</span>
 </div>
 </div>
 </div>
 </div>
 </div>
 
 <div class="control-group">
 <div class="input-with-label"><label for="blend-mode">Modalità Fusione</label><select id="blend-mode">
 <option value="source-over" selected>Normale</option>
 <option value="multiply">Moltiplica</option>
 <option value="screen">Scolora</option>
 <option value="overlay">Sovrapponi</option>
 <option value="darken">Scurisci</option>
 <option value="lighten">Schiarisci</option>
 <option value="color-dodge">Scherma Colore</option>
 <option value="color-burn">Brucia Colore</option>
 <option value="hard-light">Luce Intensa</option>
 <option value="soft-light">Luce Soffusa</option>
 <option value="difference">Differenza</option>
 <option value="exclusion">Esclusione</option>
 <option value="hue">Tonalità</option>
 <option value="saturation">Saturazione</option>
 <option value="color">Colore</option>
 <option value="luminosity">Luminosità</option>
 </select>
 </div>
 
 <div class="control-group hidden" id="image-transform-controls" >
 <h4 style="font-size: 14px; font-weight: 600; margin: 16px 0 8px 0;">Gestione Immagine</h4>
 <label class="btn btn-primary btn-full" style="text-align: center; cursor: pointer; margin-bottom: 8px;">
 Sostituisci Immagine
 <input type="file" id="replace-image" accept="image/*" class="hidden">
 </label>
 
 <h4 style="font-size: 14px; font-weight: 600; margin: 16px 0 8px 0;">Trasformazioni</h4>
 <div class="btn-group">
 <button class="btn btn-secondary" id="btn-flip-h-2" title="Specchia orizzontalmente">⇄ Flip H</button>
 <button class="btn btn-secondary" id="btn-flip-v-2" title="Specchia verticalmente">⇅ Flip V</button>
 </div>
 </div>
 
 <div class="control-group hidden" id="mask-clipping-controls" >
 <h4 style="font-size: 14px; font-weight: 600; margin: 16px 0 8px 0;">Maschera di Ritaglio</h4>
 <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">
 Ritaglia l'immagine con una forma geometrica
 </p>
 <div class="input-with-label">
 <label for="mask-shape">Forma Maschera</label>
 <select id="mask-shape">
 <option value="none" selected>Nessuna (Rettangolo)</option>
 <option value="circle">Cerchio</option>
 <option value="rounded">Rettangolo Arrotondato</option>
 <option value="triangle">Triangolo</option>
 <option value="star">Stella</option>
 <option value="heart">Cuore</option>
 <option value="hexagon">Esagono</option>
 </select>
 </div>
 <button class="btn btn-primary btn-full mt-12" id="btn-apply-mask" >
 Applica Maschera
 </button>
 <button class="btn btn-secondary btn-full mt-8" id="btn-remove-mask" >
 Rimuovi Maschera
 </button>
 </div>
 
 <div class="control-group hidden" id="image-crop-controls" >
 <h4 style="font-size: 14px; font-weight: 600; margin: 16px 0 8px 0;">Ritaglia Immagine</h4>
 <p style="font-size: 12px; color: var(--text-secondary); margin-bottom: 12px;">
 Scegli un preset o ritaglia manualmente
 </p>
 
 <div class="input-with-label">
 <label for="crop-preset">Preset Ritaglio</label>
 <select id="crop-preset">
 <option value="none" selected>Nessuno</option>
 <option value="square">Quadrato Centrale</option>
 <option value="16:9">16:9 Orizzontale</option>
 <option value="9:16">9:16 Verticale</option>
 <option value="4:3">4:3 Classico</option>
 <option value="1:1">1:1 Quadrato</option>
 </select>
 </div>
 
 <button class="btn btn-secondary btn-full" id="btn-apply-crop-preset" style="margin-top:8px;">Applica Preset</button>
 
 <div style="margin-top: 16px;">
 <h4 style="font-size: 13px; font-weight: 600; margin-bottom: 8px;">Ritaglio Manuale (in pixel)</h4>
 <div class="control-row">
 <div class="input-with-label">
 <label for="crop-left">Taglia Sinistra</label>
 <input type="number" id="crop-left" min="0" value="0">
 </div>
 <div class="input-with-label">
 <label for="crop-right">Taglia Destra</label>
 <input type="number" id="crop-right" min="0" value="0">
 </div>
 </div>
 <div class="control-row">
 <div class="input-with-label">
 <label for="crop-top">Taglia Alto</label>
 <input type="number" id="crop-top" min="0" value="0">
 </div>
 <div class="input-with-label">
 <label for="crop-bottom">Taglia Basso</label>
 <input type="number" id="crop-bottom" min="0" value="0">
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-crop-manual" style="margin-top:8px;">Applica Ritaglio Manuale</button>
 </div>
 </div>
 
 <div class="control-group hidden" id="filters-panel" >
 <h4 style="font-size: 14px; font-weight: 600; margin: 16px 0 8px 0;">Filtri Immagine</h4>
 
 <div class="input-with-label">
 <label for="filter-preset">Preset</label>
 <select id="filter-preset">
 <option value="none" selected>Nessuno</option>
 <option value="grayscale">Bianco e Nero</option>
 <option value="vintage">Vintage</option>
 <option value="warm">Caldo</option>
 <option value="cool">Freddo</option>
 </select>
 </div>
 
 <div class="input-with-label">
 <label for="filter-brightness">Luminosità</label>
 <div class="slider-group">
 <input type="range" id="filter-brightness" min="-100" max="100" value="0" step="5">
 <span class="slider-value" id="filter-brightness-value">0</span>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="filter-contrast">Contrasto</label>
 <div class="slider-group">
 <input type="range" id="filter-contrast" min="-100" max="100" value="0" step="5">
 <span class="slider-value" id="filter-contrast-value">0</span>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="filter-saturation">Saturazione</label>
 <div class="slider-group">
 <input type="range" id="filter-saturation" min="-100" max="100" value="0" step="5">
 <span class="slider-value" id="filter-saturation-value">0</span>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="filter-hue">Tonalità (Hue)</label>
 <div class="slider-group">
 <input type="range" id="filter-hue" min="-180" max="180" value="0" step="5">
 <span class="slider-value" id="filter-hue-value">0°</span>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="filter-sepia">Seppia</label>
 <div class="slider-group">
 <input type="range" id="filter-sepia" min="0" max="100" value="0" step="5">
 <span class="slider-value" id="filter-sepia-value">0%</span>
 </div>
 </div>
 
 <div class="input-with-label">
 <label for="filter-blur">Sfocatura</label>
 <div class="slider-group">
 <input type="range" id="filter-blur" min="0" max="20" value="0" step="1">
 <span class="slider-value" id="filter-blur-value">0 px</span>
 </div>
 </div>
 </div>
 
 <div class="control-group hidden" id="mask-controls" >
 <strong class="control-group-title">Maschera</strong>
 <select id="mask-shape-2">
 <option value="none" selected>Nessuna</option>
 <option value="circle">Cerchio</option>
 <option value="rounded">Arrotondato</option>
 </select>
 </div>
 
                        </div>
                    </details>

 <!-- ESTRAZIONE OGGETTO CON AI - FASE 3 -->
 
 <!-- NUOVI EFFETTI AVANZATI v34.1 -->
 <div class="control-group hidden" id="advanced-effects-panel" >
 <details open style="margin-bottom: 16px; border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; background: var(--bg-secondary);">
 <summary style="cursor: pointer; font-weight: 600; font-size: 16px; user-select: none; list-style: none; outline: none;">
 Effetti Avanzati
 </summary>
 <div style="margin-top: 12px;">
<!-- NAVIGAZIONE RAPIDA EFFETTI AVANZATI -->
<nav aria-label="Navigazione rapida effetti avanzati" style="margin-bottom: 16px; padding: 12px; background: #fef3c7; border-radius: 6px; border: 2px solid #f59e0b;">
<p style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: #78350f;">Vai direttamente a:</p>
<div style="display: flex; flex-wrap: wrap; gap: 8px;">
<a href="#effect-pixelate" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Pixelate</a>
<a href="#effect-glow" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Glow</a>
<a href="#effect-vignette" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Vignette</a>
<a href="#effect-sharpen" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Sharpen</a>
<a href="#effect-autolevels" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Auto Levels</a>
<a href="#effect-levels" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Levels</a>
<a href="#effect-noise" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Noise</a>
<a href="#effect-temperature" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Temperature</a>
<a href="#effect-duotone" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Duotone</a>
<a href="#effect-hsl" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">HSL Shift</a>
<a href="#effect-oil" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Oil Painting</a>
<a href="#effect-blur" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Blur</a>
<a href="#effect-emboss" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Emboss</a>
<a href="#effect-edge" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Edge Detect</a>
<a href="#effect-clarity" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Clarity</a>
<a href="#effect-denoise" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Denoise</a>
<a href="#effect-gradmap" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Gradient Map</a>
<a href="#gpu-motionblur" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Motion Blur</a>
<a href="#gpu-gaussianblur" style="padding: 6px 12px; background: white; border: 1px solid #f59e0b; border-radius: 4px; text-decoration: none; color: #92400e; font-size: 13px;">Gaussian Blur</a>
</div>
</nav>


 
 <!-- PIXELATE -->
 <div class="control-group" id="effect-pixelate" style="background: #ddd6fe; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #8b5cf6;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Pixelate (Pixelizzazione)</div>
 <div class="input-with-label">
 <label for="pixelate-size">Dimensione Pixel (1-50)</label>
 <div class="slider-group">
 <input type="range" id="pixelate-size" min="1" max="50" value="10" step="1" 
 aria-describedby="pixelate-help">
 <span class="slider-value" id="pixelate-size-value">10 px</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-pixelate"
 style="margin-top: 12px; background: linear-gradient(to right, #8b5cf6, #7c3aed);">
 Applica Pixelate
 </button>
 <p id="pixelate-help" style="font-size: 11px; color: #7c3aed; margin-top: 8px;">
 Crea effetto mosaico/pixel art. Valori bassi = pixelazione leggera, alti = blocchi grandi.
 </p>
 </div>
 
 </div>
 
 <!-- GLOW -->
 <div class="control-group" id="effect-glow" style="background: #fef3c7; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #f59e0b;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Glow (Bagliore)</div>
 <div class="input-with-label">
 <label for="glow-intensity">Intensità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="glow-intensity" min="0" max="100" value="30" step="5"
 aria-describedby="glow-help">
 <span class="slider-value" id="glow-intensity-value">30</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="glow-color"><strong>Colore Bagliore</strong></label>
 
 <!-- Toggle HEX/RGB per Glow -->
 <div role="radiogroup" aria-label="Formato colore bagliore" style="margin-bottom: 8px; margin-top: 8px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="glow-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="glow-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Controlli HEX -->
 <div id="glow-hex-controls">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="glow-color" value="#ffffff" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="glow-color-hex" value="#ffffff" 
 placeholder="#ffffff" maxlength="7" aria-label="Codice HEX colore bagliore"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="glow-rgb-controls" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="glow-color-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="glow-color-r" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="glow-color-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="glow-color-g" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="glow-color-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="glow-color-b" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-glow"
 style="margin-top: 12px; background: linear-gradient(to right, #f59e0b, #d97706);">
 Applica Glow
 </button>
 <p id="glow-help" style="font-size: 11px; color: #d97706; margin-top: 8px;">
 Crea alone luminoso attorno all'immagine. Perfetto per effetti dream/ethereal.
 
 </p>
 </div>
 
 <!-- VIGNETTE -->
 <div class="control-group" id="effect-vignette" style="background: #f3e8ff; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #a855f7;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Vignette (Vignettatura)</div>
 <div class="input-with-label">
 <label for="vignette-intensity">Intensità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="vignette-intensity" min="0" max="100" value="50" step="5"
 aria-describedby="vignette-help">
 <span class="slider-value" id="vignette-intensity-value">50</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="vignette-size">Dimensione (10-90)</label>
 <div class="slider-group">
 <input type="range" id="vignette-size" min="10" max="90" value="50" step="5">
 <span class="slider-value" id="vignette-size-value">50</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-vignette"
 style="margin-top: 12px; background: linear-gradient(to right, #a855f7, #7e22ce);">
 Applica Vignette
 </button>
 <p id="vignette-help" style="font-size: 11px; color: #7e22ce; margin-top: 8px;">
 Scurisce gli angoli creando focus al centro. Simula obiettivi fotografici vintage.
 
 </p>
 </div>
 
 <!-- SHARPEN -->
 <div class="control-group" id="effect-sharpen" style="background: #dcfce7; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #22c55e;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Sharpen (Nitidezza)</div>
 <div class="input-with-label">
 <label for="sharpen-preset">Preset Rapido</label>
 <select id="sharpen-preset">
 <option value="custom">Personalizzato</option>
 <option value="light">Leggero</option>
 <option value="medium" selected>Medio</option>
 <option value="strong">Forte</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="sharpen-amount">Intensità (0-200)</label>
 <div class="slider-group">
 <input type="range" id="sharpen-amount" min="0" max="200" value="100" step="10"
 aria-describedby="sharpen-help">
 <span class="slider-value" id="sharpen-amount-value">100</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-sharpen"
 style="margin-top: 12px; background: linear-gradient(to right, #22c55e, #15803d);">
 Applica Sharpen
 </button>
 <p id="sharpen-help" style="font-size: 11px; color: #15803d; margin-top: 8px;">
 Aumenta la nitidezza e i dettagli. Usa con moderazione per evitare artefatti.
 
 </p>
 </div>
 
 <!-- AUTO LEVELS -->
 <div class="control-group" id="effect-autolevels" style="background: #fef2f2; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #ef4444;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Auto Levels (Correzione Automatica)</div>
 <div class="input-with-label">
 <label for="autolevels-strength">Intensità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="autolevels-strength" min="0" max="100" value="100" step="10"
 aria-describedby="autolevels-help">
 <span class="slider-value" id="autolevels-strength-value">100</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-autolevels"
 style="margin-top: 12px; background: linear-gradient(to right, #ef4444, #b91c1c);">
 Applica Auto Levels
 </button>
 <p id="autolevels-help" style="font-size: 11px; color: #b91c1c; margin-top: 8px;">
 Corregge automaticamente luminosità e contrasto espandendo l'istogramma.
 
 </p>
 </div>
 
 <!-- LEVELS MANUALE -->
 <div class="control-group" style="background: #fff7ed; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #fb923c;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">️ Levels (Controllo Manuale Precisione)</div>
 
 <div class="input-with-label">
 <label for="levels-blacks">Neri / Shadows (0-255)</label>
 <div class="slider-group">
 <input type="range" id="levels-blacks" min="0" max="255" value="0" step="1"
 aria-describedby="levels-help">
 <span class="slider-value" id="levels-blacks-value">0</span>
 </div>
 </div>
 
 <div class="input-with-label mt-12" >
 <label for="levels-gamma">Gamma / Mezzitoni (0.1-3.0)</label>
 <div class="slider-group">
 <input type="range" id="levels-gamma" min="0.1" max="3.0" value="1.0" step="0.1"
 aria-describedby="levels-help">
 <span class="slider-value" id="levels-gamma-value">1.0</span>
 </div>
 </div>
 
 <div class="input-with-label mt-12" >
 <label for="levels-whites">Bianchi / Highlights (0-255)</label>
 <div class="slider-group">
 <input type="range" id="levels-whites" min="0" max="255" value="255" step="1"
 aria-describedby="levels-help">
 <span class="slider-value" id="levels-whites-value">255</span>
 </div>
 </div>
 
 <button class="btn btn-primary btn-full" id="btn-apply-levels"
 style="margin-top: 12px; background: linear-gradient(to right, #fb923c, #c2410c);">
 ️ Applica Levels
 </button>
 
 <button class="btn btn-secondary btn-full mt-8" id="btn-reset-levels"
 >
 Reset Valori
 </button>
 
 <p id="levels-help" style="font-size: 11px; color: #c2410c; margin-top: 8px;">
 Controllo chirurgico su ombre, mezzitoni e luci. Più preciso di Auto Levels.
 <strong> con esempi</strong>
 </p>
 </div>
 
 <!-- NOISE/GRAIN -->
 <div class="control-group" id="effect-noise" style="background: #f5f3ff; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #8b5cf6;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">️ Noise/Grain (Grana Fotografica)</div>
 <div class="input-with-label">
 <label for="noise-type">Tipo Grana</label>
 <select id="noise-type">
 <option value="mono">Monocromatica</option>
 <option value="color">Colorata</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="noise-amount">Quantità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="noise-amount" min="0" max="100" value="20" step="5"
 aria-describedby="noise-help">
 <span class="slider-value" id="noise-amount-value">20</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-noise"
 style="margin-top: 12px; background: linear-gradient(to right, #8b5cf6, #6d28d9);">
 ️ Applica Noise/Grain
 </button>
 <p id="noise-help" style="font-size: 11px; color: #6d28d9; margin-top: 8px;">
 Aggiunge texture granulosa come pellicola fotografica vintage.
 
 </p>
 </div>
 
 <!-- TEMPERATURE -->
 <div class="control-group" id="effect-temperature" style="background: #fff7ed; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #fb923c;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">️ Temperature (Temperatura Colore)</div>
 <div class="input-with-label">
 <label for="temperature-value">Temperatura (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="temperature-value" min="-100" max="100" value="0" step="5"
 aria-describedby="temperature-help">
 <span class="slider-value" id="temperature-value-display">0</span>
 </div>
 <div style="display: flex; justify-content: space-between; font-size: 10px; color: #9a3412; margin-top: 4px;">
 <span>️ Freddo (Blu)</span>
 <span> Caldo (Arancio)</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="tint-value">Tinta (-50 a +50)</label>
 <div class="slider-group">
 <input type="range" id="tint-value" min="-50" max="50" value="0" step="5">
 <span class="slider-value" id="tint-value-display">0</span>
 </div>
 <div style="display: flex; justify-content: space-between; font-size: 10px; color: #9a3412; margin-top: 4px;">
 <span> Verde</span>
 <span> Magenta</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-temperature"
 style="margin-top: 12px; background: linear-gradient(to right, #fb923c, #c2410c);">
 ️ Applica Temperature
 </button>
 <p id="temperature-help" style="font-size: 11px; color: #c2410c; margin-top: 8px;">
 Regola la tonalità caldo/freddo dell'immagine simulando diverse temperature di luce.
 
 </p>
 </div>
 
<!-- NUOVO v37\.0: Levels Manuale -->
 <div class="control-group" id="effect-levels" style="background:#fef3c7;padding:16px;border-radius:8px;margin-top:20px;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Levels Manuale (Professionale)</div>
 <p style="font-size:11px;color:#78350f;margin-bottom:12px;line-height:1.5;">
 Controllo preciso dei toni. Premi F2 su questi controlli per guida dettagliata.
 </p>
 
 <div class="control-group">
 <label>
 Input Blacks: <span class="value-display" id="levels-input-black-value">0</span>
 </label>
 <input type="range" id="levels-input-black" min="0" max="255" value="0" step="1">
 </div>

 <div class="control-group">
 <label>
 Input Whites: <span class="value-display" id="levels-input-white-value">255</span>
 </label>
 <input type="range" id="levels-input-white" min="0" max="255" value="255" step="1">
 </div>

 <div class="control-group">
 <label>
 Gamma (Mezzi Toni): <span class="value-display" id="levels-gamma-value-2">1.00</span>
 </label>
 <input type="range" id="levels-gamma-2" min="0.1" max="3.0" value="1.0" step="0.01">
 </div>

 <div class="control-group">
 <label>
 Output Blacks: <span class="value-display" id="levels-output-black-value">0</span>
 </label>
 <input type="range" id="levels-output-black" min="0" max="255" value="0" step="1">
 </div>

 <div class="control-group">
 <label>
 Output Whites: <span class="value-display" id="levels-output-white-value">255</span>
 </label>
 <input type="range" id="levels-output-white" min="0" max="255" value="255" step="1">
 </div>

 <button onclick="applyLevels()" class="success" style="font-size:13px;padding:10px;margin-top:8px">
 Applica Levels
 </button>
 <button onclick="resetLevels()" class="secondary" style="font-size:13px;padding:8px;margin-top:4px">
 ↺ Reset Levels
 </button>
 </div>

 <!-- GRADIENT TEXT -->
 <div class="control-group" style="background: #fce7f3; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #ec4899;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Gradient Text (Testo Sfumato)</div>
 <div class="input-with-label">
 <label for="gradient-text-input">Testo da creare</label>
 <input type="text" id="gradient-text-input" placeholder="Il tuo testo qui..." maxlength="50">
 </div>
 <div class="input-with-label">
 <label for="gradient-text-color1">Colore Inizio</label>
 <input type="color" id="gradient-text-color1" value="#ff0080" aria-hidden="true" tabindex="-1">
 </div>
 <div class="input-with-label">
 <label for="gradient-text-color2">Colore Fine</label>
 <input type="color" id="gradient-text-color2" value="#7928ca" aria-hidden="true" tabindex="-1">
 </div>
 <div class="input-with-label">
 <label for="gradient-text-angle">Angolo Sfumatura (0-360°)</label>
 <div class="slider-group">
 <input type="range" id="gradient-text-angle" min="0" max="360" value="90" step="15"
 aria-describedby="gradient-help">
 <span class="slider-value" id="gradient-text-angle-value">90°</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="gradient-text-font-size">Dimensione Font</label>
 <div class="slider-group">
 <input type="range" id="gradient-text-font-size" min="20" max="200" value="60" step="10">
 <span class="slider-value" id="gradient-text-font-size-value">60px</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-create-gradient-text"
 style="margin-top: 12px; background: linear-gradient(to right, #ec4899, #be185d);">
 Crea Testo Gradient
 </button>
 <p id="gradient-help" style="font-size: 11px; color: #be185d; margin-top: 8px;">
 Crea un nuovo livello di testo con sfumatura di colore personalizzata.
 
 </p>
 </div>
 
 <!-- DUOTONE -->
 <div class="control-group" id="effect-duotone" style="background: #fce7f3; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #ec4899;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Duotone (Due Tonalità)</div>
 <!-- Toggle HEX/RGB per Duotone -->
 <div role="radiogroup" aria-label="Formato colore duotone" style="margin-bottom: 12px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="duotone-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="duotone-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Colore 1 - Ombre -->
 <div class="input-with-label">
 <label for="duotone-color1"><strong>Colore Ombre (toni scuri)</strong></label>
 
 <!-- Controlli HEX -->
 <div id="duotone-hex-controls-1">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="duotone-color1" value="#1e3a8a" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="duotone-color1-hex" value="#1e3a8a" 
 placeholder="#000000" maxlength="7" aria-label="Codice HEX colore ombre"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="duotone-rgb-controls-1" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="duotone-color1-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="duotone-color1-r" min="0" max="255" value="30" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="duotone-color1-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="duotone-color1-g" min="0" max="255" value="58" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="duotone-color1-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="duotone-color1-b" min="0" max="255" value="138" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <!-- Colore 2 - Luci -->
 <div class="input-with-label" style="margin-top: 12px;">
 <label for="duotone-color2"><strong>Colore Luci (toni chiari)</strong></label>
 
 <!-- Controlli HEX -->
 <div id="duotone-hex-controls-2">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="duotone-color2" value="#fb923c" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="duotone-color2-hex" value="#fb923c"
 placeholder="#ffffff" maxlength="7" aria-label="Codice HEX colore luci"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="duotone-rgb-controls-2" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="duotone-color2-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="duotone-color2-r" min="0" max="255" value="251" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="duotone-color2-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="duotone-color2-g" min="0" max="255" value="146" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="duotone-color2-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="duotone-color2-b" min="0" max="255" value="60" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 <div class="input-with-label">
 <label for="duotone-intensity">Intensità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="duotone-intensity" min="0" max="100" value="100" step="10"
 aria-describedby="duotone-help">
 <span class="slider-value" id="duotone-intensity-value">100</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-duotone"
 style="margin-top: 12px; background: linear-gradient(to right, #ec4899, #be185d);">
 Applica Duotone
 </button>
 <p id="duotone-help" style="font-size: 11px; color: #be185d; margin-top: 8px;">
 Effetto bicolore trendy stile Instagram. Le ombre prendono un colore, le luci un altro.
 
 </p>
 </div>
 
 <!-- HSL SHIFT -->
 <div class="control-group" id="effect-hsl" style="background: #e0f2fe; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #06b6d4;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">HSL Shift (Tonalità/Saturazione/Luminosità)</div>
 <div class="input-with-label">
 <label for="hsl-hue">Tonalità (Hue) -180° a 180°</label>
 <div class="slider-group">
 <input type="range" id="hsl-hue" min="-180" max="180" value="0" step="10"
 aria-describedby="hsl-help">
 <span class="slider-value" id="hsl-hue-value">0°</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="hsl-saturation">Saturazione -100% a 100%</label>
 <div class="slider-group">
 <input type="range" id="hsl-saturation" min="-100" max="100" value="0" step="10">
 <span class="slider-value" id="hsl-saturation-value">0%</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="hsl-lightness">Luminosità -100% a 100%</label>
 <div class="slider-group">
 <input type="range" id="hsl-lightness" min="-100" max="100" value="0" step="10">
 <span class="slider-value" id="hsl-lightness-value">0%</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-hsl"
 style="margin-top: 12px; background: linear-gradient(to right, #06b6d4, #0e7490);">
 Applica HSL Shift
 </button>
 <p id="hsl-help" style="font-size: 11px; color: #0e7490; margin-top: 8px;">
 Controllo preciso sui colori. Hue cambia i colori, Saturazione l'intensità, Luminosità la brillantezza.
 
 </p>
 </div>
 
 <!-- OIL PAINTING -->
 <div class="control-group" id="effect-oil" style="background: #fef9c3; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #eab308;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">️ Oil Painting (Pittura a Olio)</div>
 <div class="input-with-label">
 <label for="oil-brush-size">Dimensione Pennellata (1-10)</label>
 <div class="slider-group">
 <input type="range" id="oil-brush-size" min="1" max="10" value="4" step="1"
 aria-describedby="oil-help">
 <span class="slider-value" id="oil-brush-size-value">4</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="oil-intensity">Intensità (1-5)</label>
 <div class="slider-group">
 <input type="range" id="oil-intensity" min="1" max="5" value="3" step="1">
 <span class="slider-value" id="oil-intensity-value">3</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-oil"
 style="margin-top: 12px; background: linear-gradient(to right, #eab308, #a16207);">
 ️ Applica Oil Painting
 </button>
Trasforma la foto in dipinto ad olio. Pennellate grandi = effetto più pittorico.
 
 </p>
 </div>
 
 <!-- BLUR -->
 <div class="control-group" id="effect-blur" style="background: #e0f2fe; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #0284c7;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Blur (Sfocatura Gaussiana)</div>
 <div class="input-with-label">
 <label for="blur-radius">Raggio Sfocatura (0-50)</label>
 <div class="slider-group">
 <input type="range" id="blur-radius" min="0" max="50" value="10" step="1"
 aria-describedby="blur-help">
 <span class="slider-value" id="blur-radius-value">10</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-blur"
 style="margin-top: 12px; background: linear-gradient(to right, #0284c7, #075985);">
 Applica Blur
 </button>
 <p id="blur-help" style="font-size: 11px; color: #075985; margin-top: 8px;">
 Sfocatura morbida stile fotografico. Basso = sottile, alto = effetto dream.
 
 </p>
 </div>
 
 <!-- EMBOSS -->
 <div class="control-group" id="effect-emboss" style="background: #fce7f3; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #db2777;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Emboss (Rilievo 3D)</div>
 <div class="input-with-label">
 <label for="emboss-strength">Intensità (0-200)</label>
 <div class="slider-group">
 <input type="range" id="emboss-strength" min="0" max="200" value="100" step="10"
 aria-describedby="emboss-help">
 <span class="slider-value" id="emboss-strength-value">100</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-emboss"
 style="margin-top: 12px; background: linear-gradient(to right, #db2777, #9f1239);">
 Applica Emboss
 </button>
 
 </div>
 
 <!-- EDGE DETECT -->
 <div class="control-group" id="effect-edge" style="background: #ddd6fe; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #7c3aed;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Edge Detect (Contorni)</div>
 <div class="input-with-label">
 <label for="edge-threshold">Soglia Sensibilità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="edge-threshold" min="0" max="100" value="30" step="5"
 aria-describedby="edge-help">
 <span class="slider-value" id="edge-threshold-value">30</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="edge-invert">Stile Output</label>
 <select id="edge-invert">
 <option value="false" selected>Bordi Neri su Bianco (classico)</option>
 <option value="true">Bordi Bianchi su Nero (artistico)</option>
 </select>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-edge"
 style="margin-top: 12px; background: linear-gradient(to right, #7c3aed, #5b21b6);">
 Applica Edge Detect
 </button>
 <p id="edge-help" style="font-size: 11px; color: #5b21b6; margin-top: 8px;">
 Estrae i contorni dell'immagine. Perfetto per disegni tecnici e arte lineare.
 
 </p>
 </div>
 
 <!-- CLARITY / LOCAL CONTRAST (NUOVO!) -->
 <div class="control-group" id="effect-clarity" style="background: #fef9c3; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #eab308;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Clarity / Local Contrast (Micro-Contrasto)</div>
 <div class="input-with-label">
 <label for="clarity-preset">Preset Rapido</label>
 <select id="clarity-preset">
 <option value="custom">Personalizzato</option>
 <option value="subtle">Sottile</option>
 <option value="moderate" selected>Moderato</option>
 <option value="strong">Forte</option>
 <option value="extreme">Estremo</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="clarity-amount">Intensità (0-150)</label>
 <div class="slider-group">
 <input type="range" id="clarity-amount" min="0" max="150" value="50" step="5"
 aria-describedby="clarity-help">
 <span class="slider-value" id="clarity-amount-value">50</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="clarity-radius">Raggio Effetto (1-10)</label>
 <div class="slider-group">
 <input type="range" id="clarity-radius" min="1" max="10" value="5" step="1">
 <span class="slider-value" id="clarity-radius-value">5</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-clarity"
 style="margin-top: 12px; background: linear-gradient(to right, #eab308, #a16207);">
 Applica Clarity
 </button>
 <p id="clarity-help" style="font-size: 11px; color: #a16207; margin-top: 8px;">
 Aumenta la definizione locale senza toccare contrasto globale. Ideale per texture e dettagli.
 
 </p>
 </div>
 
 <!-- DENOISE (NUOVO!) -->
 <div class="control-group" id="effect-denoise" style="background: #f0fdf4; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #16a34a;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Denoise (Riduzione Rumore)</div>
 <div class="input-with-label">
 <label for="denoise-preset">Preset Rapido</label>
 <select id="denoise-preset">
 <option value="custom">Personalizzato</option>
 <option value="light">Leggero</option>
 <option value="moderate" selected>Moderato</option>
 <option value="strong">Forte</option>
 <option value="aggressive">Aggressivo</option>
 </select>
 </div>
 <div class="input-with-label">
 <label for="denoise-luminance">Riduzione Luminanza (0-100)</label>
 <div class="slider-group">
 <input type="range" id="denoise-luminance" min="0" max="100" value="50" step="5"
 aria-describedby="denoise-help">
 <span class="slider-value" id="denoise-luminance-value">50</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="denoise-color">Riduzione Colore (0-100)</label>
 <div class="slider-group">
 <input type="range" id="denoise-color" min="0" max="100" value="30" step="5">
 <span class="slider-value" id="denoise-color-value">30</span>
 </div>
 </div>
 <div class="input-with-label">
 <label for="denoise-sharpen">Recupero Dettagli (0-100)</label>
 <div class="slider-group">
 <input type="range" id="denoise-sharpen" min="0" max="100" value="20" step="5">
 <span class="slider-value" id="denoise-sharpen-value">20</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-denoise"
 style="margin-top: 12px; background: linear-gradient(to right, #16a34a, #166534);">
 Applica Denoise
 </button>
 <p id="denoise-help" style="font-size: 11px; color: #166534; margin-top: 8px;">
 Rimuove rumore da foto ISO alto preservando i dettagli. Algoritmo avanzato luma+chroma.
 
 </p>
 </div>
 
 <!-- GRADIENT MAP (NUOVO!) -->
 <div class="control-group" id="effect-gradmap" style="background: #fae8ff; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #c026d3;">
 <div style="font-weight: 600; font-size: 15px; margin-bottom: 12px;">Gradient Map (Rimappa Tonalità)</div>
 <div class="input-with-label">
 <label for="gradmap-preset">Preset Creativi</label>
 <select id="gradmap-preset">
 <option value="custom">Personalizzato</option>
 <option value="goldenblue">Golden Hour</option>
 <option value="cyanred">Cinema Teal</option>
 <option value="purpleorange">Sunset Dream</option>
 <option value="greenmint">Nature Fresh</option>
 <option value="retrowarm">Retro Warm</option>
 </select>
 </div>
 
 <!-- Toggle HEX/RGB per Gradient Map -->
 <div role="radiogroup" aria-label="Formato colore gradient map" style="margin-bottom: 12px; margin-top: 12px; display: flex; gap: 10px;">
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="gradmap-color-format" value="hex" checked style="margin-right: 6px;">
 <span>Codice HEX</span>
 </label>
 <label style="display: flex; align-items: center; cursor: pointer;">
 <input type="radio" name="gradmap-color-format" value="rgb" style="margin-right: 6px;">
 <span>Valori RGB</span>
 </label>
 </div>
 
 <!-- Colore Ombre -->
 <div class="input-with-label">
 <label for="gradmap-shadow"><strong>Colore Ombre (scuro)</strong></label>
 
 <!-- Controlli HEX -->
 <div id="gradmap-hex-controls-1">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="gradmap-shadow" value="#1a1a2e" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="gradmap-shadow-hex" value="#1a1a2e" 
 placeholder="#000000" maxlength="7" aria-label="Codice HEX colore ombre"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="gradmap-rgb-controls-1" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="gradmap-shadow-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="gradmap-shadow-r" min="0" max="255" value="26" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradmap-shadow-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="gradmap-shadow-g" min="0" max="255" value="26" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradmap-shadow-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="gradmap-shadow-b" min="0" max="255" value="46" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 
 <!-- Colore Luci -->
 <div class="input-with-label" style="margin-top: 12px;">
 <label for="gradmap-highlight"><strong>Colore Luci (chiaro)</strong></label>
 
 <!-- Controlli HEX -->
 <div id="gradmap-hex-controls-2">
 <div style="display: flex; gap: 8px; align-items: center;">
 <input type="color" id="gradmap-highlight" value="#eef4ff" aria-hidden="true" tabindex="-1"
 style="width: 50px; height: 36px; border: 2px solid #cbd5e1; border-radius: 6px; cursor: pointer;">
 <input type="text" id="gradmap-highlight-hex" value="#eef4ff"
 placeholder="#ffffff" maxlength="7" aria-label="Codice HEX colore luci"
 style="flex: 1; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px; font-family: monospace; font-size: 13px;"
 pattern="^#[0-9A-Fa-f]{6}$">
 </div>
 </div>
 
 <!-- Controlli RGB -->
 <div id="gradmap-rgb-controls-2" style="display: none;">
 <div style="display: flex; gap: 8px;">
 <div style="flex: 1;">
 <label for="gradmap-highlight-r" style="font-size: 12px; color: var(--text-secondary);">R</label>
 <input type="number" id="gradmap-highlight-r" min="0" max="255" value="238" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradmap-highlight-g" style="font-size: 12px; color: var(--text-secondary);">G</label>
 <input type="number" id="gradmap-highlight-g" min="0" max="255" value="244" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 <div style="flex: 1;">
 <label for="gradmap-highlight-b" style="font-size: 12px; color: var(--text-secondary);">B</label>
 <input type="number" id="gradmap-highlight-b" min="0" max="255" value="255" 
 style="width: 100%; padding: 8px; border: 2px solid #cbd5e1; border-radius: 6px;">
 </div>
 </div>
 </div>
 </div>
 <div class="input-with-label">
 <label for="gradmap-intensity">Intensità Mix (0-100)</label>
 <div class="slider-group">
 <input type="range" id="gradmap-intensity" min="0" max="100" value="80" step="5"
 aria-describedby="gradmap-help">
 <span class="slider-value" id="gradmap-intensity-value">80</span>
 </div>
 </div>
 <button class="btn btn-primary btn-full" id="btn-apply-gradmap"
 style="margin-top: 12px; background: linear-gradient(to right, #c026d3, #86198f);">
 Applica Gradient Map
 </button>
 <p id="gradmap-help" style="font-size: 11px; color: #86198f; margin-top: 8px;">
 Rimappa i toni dall'ombra alla luce usando un gradiente. Effetti color grading professionali.
 
 </p>
 </div>
 </div>

 </div>
 </details>
 </div>

 <div class="control-group" id="ai-extract-controls" style="display: none; margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%); border: 2px solid #10b981; border-radius: 8px;">
 <strong class="control-group-title" style="color: #065f46;">
 Estrai Oggetto con AI
 </strong>
 <p style="font-size: 13px; color: #047857; margin-bottom: 16px; line-height: 1.5;">
 Usa l'intelligenza artificiale per estrarre un oggetto specifico dall'immagine e crearlo come livello separato. L'oggetto sarà ritagliato con precisione e lo sfondo originale verrà riempito automaticamente.
 </p>
 
 <div class="input-with-label" style="margin-bottom: 12px;">
 <label for="extract-prompt" style="font-weight: 600; color: #065f46;">Cosa vuoi estrarre?</label>
 <input type="text" id="extract-prompt" placeholder="es. il gatto nero, la persona a destra, l'auto rossa..." 
 aria-describedby="extract-prompt-help" style="background: white;">
 <p id="extract-prompt-help" style="font-size: 11px; color: #047857; margin-top: 6px;">
 Descrivi l'oggetto in modo specifico. Esempi: "il sasso grande a sinistra", "la persona con giacca rossa", "l'albero centrale"
 </p>
 </div>
 
 <button class="btn btn-success btn-full" id="btn-extract-object" aria-describedby="extract-help" 
 style="background: linear-gradient(to right, #10b981, #059669); font-weight: 600;">
 Estrai e Crea Nuovo Livello
 </button>
 <p id="extract-help" class="sr-only">Estrae l'oggetto descritto dall'immagine corrente, rimuove lo sfondo e lo aggiunge come nuovo livello separato che puoi spostare liberamente</p>
 
 <div style="margin-top: 12px; padding: 12px; background: white; border-radius: 6px; font-size: 12px; color: #047857;">
 <strong>️ Nota:</strong> Questa operazione usa 2 chiamate AI (segmentazione + riempimento) e può richiedere 30-60 secondi. Assicurati che entrambe le API key siano configurate.
 </div>
 </div>
 
 <!-- OCR - ESTRAZIONE TESTO DA IMMAGINE -->
 <div class="control-group" id="ai-ocr-controls" style="display: none; margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%); border: 2px solid #3b82f6; border-radius: 8px;">
 <strong class="control-group-title" style="color: #1e40af;">
 Estrai Testo con OCR
 </strong>
 <p style="font-size: 13px; color: #1e3a8a; margin-bottom: 16px; line-height: 1.5;">
 Usa Google Vision API per estrarre automaticamente tutto il testo presente nell'immagine. Il testo verrà aggiunto come livelli separati nelle posizioni corrette.
 </p>
 
 <button class="btn btn-primary btn-full" id="btn-ocr-extract" aria-describedby="ocr-help" 
 style="background: linear-gradient(to right, #3b82f6, #2563eb); font-weight: 600;">
 Estrai Tutto il Testo
 </button>
 <p id="ocr-help" class="sr-only">Analizza l'immagine e crea automaticamente livelli di testo per ogni blocco di testo trovato</p>
 
 <div style="margin-top: 12px; padding: 12px; background: white; border-radius: 6px; font-size: 12px; color: #1e3a8a;">
 <strong> Consiglio:</strong> Funziona meglio con immagini chiare e testo leggibile. Il testo estratto sarà modificabile come normale testo.
 </div>
 </div>
 
 <!-- BACKGROUND REMOVAL -->
 <div class="control-group" id="ai-rembg-controls" style="display: none; margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border: 2px solid #f59e0b; border-radius: 8px;">
 <strong class="control-group-title" style="color: #92400e;">
 Rimuovi Sfondo
 </strong>
 <p style="font-size: 13px; color: #78350f; margin-bottom: 16px; line-height: 1.5;">
 Rimuove automaticamente lo sfondo dall'immagine, lasciando solo il soggetto principale con trasparenza. Perfetto per ritratti e prodotti.
 </p>
 
 <button class="btn btn-warning btn-full" id="btn-remove-background" aria-describedby="rembg-help" 
 style="background: linear-gradient(to right, #f59e0b, #d97706); color: white; font-weight: 600;">
 ️ Rimuovi Sfondo Automaticamente
 </button>
 <p id="rembg-help" class="sr-only">Rimuove automaticamente lo sfondo dell'immagine lasciando il soggetto principale con sfondo trasparente</p>
 
 <div style="margin-top: 12px; padding: 12px; background: white; border-radius: 6px; font-size: 12px; color: #78350f;">
 <strong> Veloce:</strong> Richiede solo 10-15 secondi. Lo sfondo diventerà trasparente automaticamente.
 </div>
 </div>
 
 <!-- UPSCALING AI -->
 <div class="control-group" id="ai-upscale-controls" style="display: none; margin-top: 20px; padding: 20px; background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border: 2px solid #ec4899; border-radius: 8px;">
 <strong class="control-group-title" style="color: #9f1239;">
 Migliora Qualità (Upscaling)
 </strong>
 <p style="font-size: 13px; color: #831843; margin-bottom: 16px; line-height: 1.5;">
 Aumenta la risoluzione dell'immagine fino a 4x usando l'intelligenza artificiale. Perfetto per immagini piccole o a bassa risoluzione.
 </p>
 
 <div class="input-with-label" style="margin-bottom: 12px;">
 <label for="upscale-factor" style="font-weight: 600; color: #9f1239;">Fattore di Ingrandimento</label>
 <select id="upscale-factor" style="background: white;">
 <option value="2">2x (doppia risoluzione)</option>
 <option value="3">3x (tripla risoluzione)</option>
 <option value="4">4x (quadrupla risoluzione)</option>
 </select>
 </div>
 
 <button class="btn btn-full" id="btn-upscale-image" aria-describedby="upscale-help" 
 style="background: linear-gradient(to right, #ec4899, #db2777); color: white; font-weight: 600;">
 Migliora Risoluzione
 </button>
 <p id="upscale-help" class="sr-only">Aumenta la risoluzione dell'immagine mantenendo la qualità usando intelligenza artificiale</p>
 
 <div style="margin-top: 12px; padding: 12px; background: white; border-radius: 6px; font-size: 12px; color: #831843;">
 <strong>️ Tempo:</strong> 20-40 secondi a seconda della dimensione. Migliora nitidezza e dettagli automaticamente.
 </div>
 </div>
 </div>
 </section>
 
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <!-- PANNELLO 8B: EFFETTI GPU GLOBALI (Pipeline Unificata) -->
 <!-- ═══════════════════════════════════════════════════════════════ -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">14</span>
 <h2 class="section-heading">Effetti GPU Avanzati</h2>
 </div>
 <div class="section-content" id="gpu-global-section">
 <!-- NAVIGAZIONE RAPIDA -->
 <nav aria-label="Navigazione rapida effetti GPU" style="margin-bottom: 16px; padding: 12px; background: #f0f9ff; border-radius: 6px; border: 2px solid #0ea5e9;">
 <p style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: #0c4a6e;">Vai direttamente a:</p>
 <div style="display: flex; flex-wrap: wrap; gap: 8px;">
 <a href="#gpu-brightness" style="padding: 6px 12px; background: white; border: 1px solid #0ea5e9; border-radius: 4px; text-decoration: none; color: #0369a1; font-size: 13px;"> Luminosità</a>
 <a href="#gpu-contrast" style="padding: 6px 12px; background: white; border: 1px solid #0ea5e9; border-radius: 4px; text-decoration: none; color: #0369a1; font-size: 13px;">◐ Contrasto</a>
 <a href="#gpu-hue" style="padding: 6px 12px; background: white; border: 1px solid #0ea5e9; border-radius: 4px; text-decoration: none; color: #0369a1; font-size: 13px;"> Tonalità</a>
 <a href="#gpu-saturation" style="padding: 6px 12px; background: white; border: 1px solid #0ea5e9; border-radius: 4px; text-decoration: none; color: #0369a1; font-size: 13px;"> Saturazione</a>
 <a href="#gpu-vibrance" style="padding: 6px 12px; background: white; border: 1px solid #0ea5e9; border-radius: 4px; text-decoration: none; color: #0369a1; font-size: 13px;"> Vivacità</a>
 </div>
 </nav>
 
 <div style="margin-bottom:16px; padding:12px; background:#e0f2fe; border-left:4px solid #0ea5e9; border-radius:6px;">
 <p style="font-size: 13px; color: #0c4a6e; margin:0; line-height:1.6;">
 <strong> Pipeline Unificata:</strong> Gli effetti GPU vengono applicati all'intero canvas <strong>dopo</strong> il rendering di tutti i layer. 
 Questo garantisce che persistano in <strong>anteprima (Alt+A)</strong> e nell'<strong>export</strong>.
 </p>
 </div>
 
 
 <!-- Brightness -->
 <div class="control-group" id="gpu-brightness">
 <div class="input-with-label">
 <label for="gpu-global-brightness">
 <span style="display: flex; justify-content: space-between; align-items: center;">
 <span> Luminosità</span>
 <span id="gpu-global-brightness-val" style="font-weight: 600; color: #3b82f6;">0.00</span>
 </span>
 </label>
 <input type="range" id="gpu-global-brightness" 
 min="-1" max="1" step="0.01" value="0"
 oninput="updateGlobalGPUEffect('brightness', parseFloat(this.value))"
 aria-valuemin="-1" aria-valuemax="1">
 </div>
 </div>
 
 <!-- Contrast -->
 <div class="control-group" id="gpu-contrast">
 <div class="input-with-label">
 <label for="gpu-global-contrast">
 <span style="display: flex; justify-content: space-between; align-items: center;">
 <span>◐ Contrasto</span>
 <span id="gpu-global-contrast-val" style="font-weight: 600; color: #3b82f6;">0.00</span>
 </span>
 </label>
 <input type="range" id="gpu-global-contrast" 
 min="-1" max="1" step="0.01" value="0"
 oninput="updateGlobalGPUEffect('contrast', parseFloat(this.value))"
 
 aria-valuemin="-1" aria-valuemax="1">
 </div>
 </div>
 
 <!-- Hue -->
 <div class="control-group" id="gpu-hue">
 <div class="input-with-label">
 <label for="gpu-global-hue">
 <span style="display: flex; justify-content: space-between; align-items: center;">
 <span> Tonalità</span>
 <span id="gpu-global-hue-val" style="font-weight: 600; color: #3b82f6;">0.00</span>
 </span>
 </label>
 <input type="range" id="gpu-global-hue" 
 min="-1" max="1" step="0.01" value="0"
 oninput="updateGlobalGPUEffect('hue', parseFloat(this.value))"
 
 aria-valuemin="-1" aria-valuemax="1">
 </div>
 </div>
 
 <!-- Saturation -->
 <div class="control-group" id="gpu-saturation">
 <div class="input-with-label">
 <label for="gpu-global-saturation">
 <span style="display: flex; justify-content: space-between; align-items: center;">
 <span> Saturazione</span>
 <span id="gpu-global-saturation-val" style="font-weight: 600; color: #3b82f6;">0.00</span>
 </span>
 </label>
 <input type="range" id="gpu-global-saturation" 
 min="-1" max="1" step="0.01" value="0"
 oninput="updateGlobalGPUEffect('saturation', parseFloat(this.value))"
 
 aria-valuemin="-1" aria-valuemax="1">
 </div>
 </div>
 
 <!-- Vibrance -->
 <div class="control-group" id="gpu-vibrance">
 <div class="input-with-label">
 <label for="gpu-global-vibrance">
 <span style="display: flex; justify-content: space-between; align-items: center;">
 <span> Vivacità</span>
 <span id="gpu-global-vibrance-val" style="font-weight: 600; color: #3b82f6;">0.00</span>
 </span>
 </label>
 <input type="range" id="gpu-global-vibrance" 
 min="-1" max="1" step="0.01" value="0"
 oninput="updateGlobalGPUEffect('vibrance', parseFloat(this.value))"
 aria-valuemin="-1" aria-valuemax="1">
 </div>
 </div>
 
 <hr style="margin:20px 0; border:none; border-top:1px solid var(--border-color);">
 
 <button class="btn btn-secondary btn-full" 
 onclick="resetGlobalGPUEffects()"
 aria-label="Reimposta tutti gli effetti GPU ai valori predefiniti"
 style="font-weight: 500;">
 Reset Tutti gli Effetti
 </button>
 
 <div style="margin-top:16px; padding:12px; background:#fef3c7; border-left:4px solid #f59e0b; border-radius:6px; font-size:12px; color:#78350f;">
 <p style="margin:0; line-height:1.5;">
 <strong> Tip:</strong> Questi effetti sono applicati a livello GPU e funzionano su qualsiasi tipo di layer (testo, immagini, forme). 
 Sperimenta con combinazioni diverse!
 </p>
 </div>
 </div>
 </section>


 <!-- ═══════════════════════════════════════════════════════════════════════
 EFFETTI GPU AVANZATI (WebGL - glfx.js)
 ═══════════════════════════════════════════════════════════════════════ -->
 
 <div class="control-section" role="region" aria-label="Effetti GPU Avanzati">
<details open style="margin: 16px 0; border: 2px solid #0ea5e9; border-radius: 8px; padding: 16px; background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 100%);">
    <summary style="cursor: pointer; font-weight: 700; font-size: 18px; color: white; user-select: none; list-style: none; outline: none; padding: 8px;">
        Effetti GPU WebGL (glfx.js)
    </summary>
    <div style="margin-top: 16px;">
<!-- NAVIGAZIONE RAPIDA EFFETTI GPU WEBGL -->
<nav aria-label="Navigazione rapida effetti GPU WebGL" style="margin-bottom: 16px; padding: 12px; background: #dbeafe; border-radius: 6px; border: 2px solid #3b82f6;">
<p style="font-weight: 600; margin-bottom: 8px; font-size: 14px; color: #1e40af;">Vai direttamente a:</p>
<div style="display: flex; flex-wrap: wrap; gap: 8px;">
<a href="#gpu-curves" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Curves Pro</a>
<a href="#gpu-colorbalance" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Color Balance</a>
<a href="#gpu-blurpro" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Blur Pro</a>
<a href="#gpu-bloom" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Bloom</a>
<a href="#gpu-highlights" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Highlights/Shadows</a>
<a href="#gpu-whitebalance" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">White Balance</a>
<a href="#gpu-vibrance" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Vibrance</a>
<a href="#gpu-chromatic" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Chromatic</a>
<a href="#gpu-tiltshift" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Tilt Shift</a>
<a href="#gpu-gaussianblur" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Gaussian Blur</a>
<a href="#gpu-glitch" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Glitch</a>
<a href="#gpu-vhs" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">VHS</a>
<a href="#gpu-dehaze" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Dehaze</a>
<a href="#gpu-bloomsoft" style="padding: 6px 12px; background: white; border: 1px solid #3b82f6; border-radius: 4px; text-decoration: none; color: #1e40af; font-size: 13px;">Bloom Soft</a>
</div>
</nav>


 <p class="section-description" style="margin-bottom: 16px;">
 Effetti professionali elaborati dalla scheda grafica (WebGL). Premi <kbd style="background: var(--accent); color: white; padding: 2px 6px; border-radius: 3px; font-size: 11px;">F2</kbd> per guida completa con spiegazioni dettagliate.
 </p>
 
 <!-- STATO GPU - Pannello informativo -->
 <div id="gpu-status-panel" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: 8px; padding: 12px; margin-bottom: 16px; border-left: 4px solid #fff;" role="status" aria-live="polite" aria-atomic="true">
 <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
 <span id="gpu-status-icon" style="font-size: 20px;" aria-hidden="true"></span>
 <strong id="gpu-status-title" style="color: white; font-size: 14px;">Inizializzazione GPU...</strong>
 </div>
 <div id="gpu-info" style="color: rgba(255,255,255,0.9); font-size: 12px; line-height: 1.5;">
 <div id="gpu-renderer">Rilevamento in corso...</div>
 <div id="gpu-vendor" style="opacity: 0.8;"></div>
 </div>
 <button id="btn-gpu-details" style="margin-top: 8px; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 6px 12px; border-radius: 4px; cursor: pointer; font-size: 11px;" aria-label="Mostra dettagli GPU">
 ℹ️ Dettagli GPU
 </button>
 </div>
 
 <div class="control-group">
<!-- CURVES PRO -->
 <div class="gpu-effect-box" id="gpu-curves">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Curves Pro <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="curves-preset" style="color: rgba(255,255,255,0.9);">Preset Curva</label>
 <select id="curves-preset" style="background: rgba(255,255,255,0.95); color: #667eea;">
 <option value="linear">Lineare</option>
 <option value="scurve">S-Curve</option>
 <option value="fade">Fade</option>
 <option value="contrast">High Contrast</option>
 </select>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-curves" aria-label="Applica effetto Curves Pro GPU">
 Applica Curves Pro
 </button>
 <p>
 Controllo preciso della curva tonale. S-Curve aumenta contrasto nei mezzitoni, 
 Fade simula pellicole vintage, High Contrast per effetti drammatici.
 </p>
 </div>

 <!-- COLOR BALANCE PRO -->
 <div class="gpu-effect-box" id="gpu-colorbalance">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Color Balance Pro <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="balance-shadows" style="color: rgba(255,255,255,0.9);">Ombre (-50 a +50)</label>
 <div class="slider-group">
 <input type="range" id="balance-shadows" min="-50" max="50" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="balance-shadows-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Negativo = ombre più calde (arancione), Positivo = ombre più fredde (blu)
 </small>
 </div>
 <div class="input-with-label">
 <label for="balance-highlights" style="color: rgba(255,255,255,0.9);">Luci (-50 a +50)</label>
 <div class="slider-group">
 <input type="range" id="balance-highlights" min="-50" max="50" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="balance-highlights-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Negativo = luci più calde (giallo), Positivo = luci più fredde (cyan)
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-color-balance" aria-label="Applica effetto Color Balance Pro GPU">
 Applica Color Balance
 </button>
 <p>
 Split toning avanzato: colora separatamente ombre e luci per look cinematici 
 (es: ombre blu + luci arancioni = effetto teal&orange).
 </p>
 </div>

 <!-- BLUR PRO GPU -->
 <div class="gpu-effect-box" id="gpu-blurpro">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Blur Pro (Gaussian) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="gpu-blur-radius" style="color: rgba(255,255,255,0.9);">Raggio (0-50)</label>
 <div class="slider-group">
 <input type="range" id="gpu-blur-radius" min="0" max="50" value="10" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="gpu-blur-radius-value" style="color: #fff;">10 px</span>
 </div>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-gpu-blur" aria-label="Applica effetto Blur Pro GPU">
 Applica Blur Pro
 </button>
 <p>
 Gaussian blur ad alte prestazioni via GPU. Molto più veloce e morbido del blur CPU, 
 ideale per sfondi e effetti bokeh professionali.
 </p>
 </div>

 <!-- BLOOM PRO -->
 <div class="gpu-effect-box" id="gpu-bloom">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Bloom Pro (Glow Realistico) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="bloom-threshold" style="color: rgba(255,255,255,0.9);">Soglia Luminosità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="bloom-threshold" min="0" max="100" value="80" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="bloom-threshold-value" style="color: #fff;">80</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Solo le aree più luminose della soglia brilleranno
 </small>
 </div>
 <div class="input-with-label">
 <label for="bloom-intensity" style="color: rgba(255,255,255,0.9);">Intensità Bloom (0-200)</label>
 <div class="slider-group">
 <input type="range" id="bloom-intensity" min="0" max="200" value="50" step="10"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="bloom-intensity-value" style="color: #fff;">50</span>
 </div>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-bloom" aria-label="Applica effetto Bloom Pro GPU">
 Applica Bloom Pro
 </button>
 <p>
 Bagliore realistico solo sulle zone più luminose (luci speculari, riflessi). 
 Perfetto per rendering 3D, fotografie notturne, effetti sci-fi.
 </p>
 </div>
 
 <!-- VIBRANCE -->
 <div class="gpu-effect-box">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Vibrance (Saturazione Intelligente) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="vibrance-amount" style="color: rgba(255,255,255,0.9);">Intensità (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="vibrance-amount" min="-100" max="100" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="vibrance-amount-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Satura solo i colori spenti, preserva toni pelle e colori già vividi
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-vibrance" aria-label="Applica effetto Vibrance GPU">
 Applica Vibrance
 </button>
 <p>
 Saturazione intelligente che migliora solo i colori spenti senza sovrasaturare. 
 Protegge toni pelle e colori già vividi. Ideale per paesaggi e foto naturalistiche. <kbd>F2</kbd> per dettagli.
 </p>
 </div>
 
 <!-- WHITE BALANCE PRO -->
 <div class="gpu-effect-box" id="gpu-whitebalance">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">White Balance Pro <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="wb-temperature" style="color: rgba(255,255,255,0.9);">Temperatura (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="wb-temperature" min="-100" max="100" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="wb-temperature-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Negativo = più freddo (blu), Positivo = più caldo (arancione)
 </small>
 </div>
 <div class="input-with-label">
 <label for="wb-tint" style="color: rgba(255,255,255,0.9);">Tinta (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="wb-tint" min="-100" max="100" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="wb-tint-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Negativo = più magenta, Positivo = più verde
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-white-balance" aria-label="Applica effetto White Balance Pro GPU">
 Applica White Balance
 </button>
 <p>
 Correzione professionale del bilanciamento del bianco con temperatura e tinta separate. 
 Perfetto per correggere luci artificiali o creare atmosfere specifiche. <kbd>F2</kbd> per dettagli.
 </p>
 </div>
 
 <!-- HIGHLIGHTS & SHADOWS -->
 <div class="gpu-effect-box" id="gpu-highlights">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Highlights & Shadows <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="hs-shadows" style="color: rgba(255,255,255,0.9);">Ombre (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="hs-shadows" min="-100" max="100" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="hs-shadows-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Positivo = schiarisce ombre (recupera dettagli)
 </small>
 </div>
 <div class="input-with-label">
 <label for="hs-highlights" style="color: rgba(255,255,255,0.9);">Luci (-100 a +100)</label>
 <div class="slider-group">
 <input type="range" id="hs-highlights" min="-100" max="100" value="0" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="hs-highlights-value" style="color: #fff;">0</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Negativo = scurisce luci (recupera dettagli bruciati)
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-highlights-shadows" aria-label="Applica effetto Highlights & Shadows GPU">
 Applica Highlights & Shadows
 </button>
 <p>
 Controllo separato per schiarire ombre e scurire luci. Recupera dettagli in foto 
 ad alto contrasto o controluce. Essenziale per fotografia HDR. <kbd>F2</kbd> per dettagli.
 </p>
 </div>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════════ -->
 <!-- 🆕 NUOVI EFFETTI GPU v43.0 -->
 <!-- ═══════════════════════════════════════════════════════════════════ -->
 
 <!-- MOTION BLUR -->
 <div class="control-group gpu-effect-card" id="gpu-motionblur" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Motion Blur (Sfocatura di Movimento) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="motionblur-distance" style="color: rgba(255,255,255,0.9);">Distanza (1-50 px)</label>
 <div class="slider-group">
 <input type="range" id="motionblur-distance" min="1" max="50" value="15" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="motionblur-distance-value" style="color: #fff;">15 px</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Lunghezza della scia di movimento
 </small>
 </div>
 <div class="input-with-label">
 <label for="motionblur-angle" style="color: rgba(255,255,255,0.9);">Angolo (0-360°)</label>
 <div class="slider-group">
 <input type="range" id="motionblur-angle" min="0" max="360" value="0" step="15"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="motionblur-angle-value" style="color: #fff;">0°</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 0° = orizzontale →, 90° = verso basso ↓, 180° = ←, 270° = ↑
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-motionblur" aria-label="Applica effetto Motion Blur GPU">
 Applica Motion Blur
 </button>
 <p>
 Simula movimento rapido in una direzione specifica. Perfetto per effetto velocità, 
 dinamismo, e senso di azione. <kbd>F2</kbd> per guida completa.
 </p>
 </div>
 
 <!-- TILT-SHIFT -->
 <div class="control-group gpu-effect-card" id="gpu-tiltshift" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4); margin-top: 16px;">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">️ Tilt-Shift (Effetto Miniatura) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="tiltshift-blur" style="color: rgba(255,255,255,0.9);">Intensità Blur (1-30)</label>
 <div class="slider-group">
 <input type="range" id="tiltshift-blur" min="1" max="30" value="10" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="tiltshift-blur-value" style="color: #fff;">10</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Quanto sono sfocate le zone fuori fuoco
 </small>
 </div>
 <div class="input-with-label">
 <label for="tiltshift-gradient" style="color: rgba(255,255,255,0.9);">Dimensione Focus (10-80%)</label>
 <div class="slider-group">
 <input type="range" id="tiltshift-gradient" min="10" max="80" value="40" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="tiltshift-gradient-value" style="color: #fff;">40%</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Quanto è grande la fascia centrale a fuoco
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-tiltshift" aria-label="Applica effetto Tilt-Shift GPU">
 ️ Applica Tilt-Shift
 </button>
 <p>
 Crea l'illusione di un modellino in miniatura sfocando gradualmente dall'alto e dal basso. 
 Fantastico per paesaggi urbani e viste dall'alto. <kbd>F2</kbd> per dettagli.
 </p>
 </div>
 
 <!-- GAUSSIAN BLUR MIGLIORATO -->
 <div class="control-group gpu-effect-card" id="gpu-gaussianblur" style="background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(79, 172, 254, 0.4); margin-top: 16px;">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">️ Gaussian Blur Pro (Sfocatura Gaussiana) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="gaussianblur-radius" style="color: rgba(255,255,255,0.9);">Raggio (1-100 px)</label>
 <div class="slider-group">
 <input type="range" id="gaussianblur-radius" min="1" max="100" value="20" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="gaussianblur-radius-value" style="color: #fff;">20 px</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Più alto = sfocatura più intensa e morbida
 </small>
 </div>
 <div class="input-with-label">
 <label for="gaussianblur-quality" style="color: rgba(255,255,255,0.9);">Qualità</label>
 <select id="gaussianblur-quality" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.4); padding: 8px; border-radius: 6px; width: 100%;">
 <option value="fast" style="color: #333;">Veloce (adatta per preview)</option>
 <option value="balanced" selected style="color: #333;">Bilanciata (uso generale)</option>
 <option value="high" style="color: #333;">Alta (massima qualità)</option>
 </select>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Qualità superiore = elaborazione più lenta
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-gaussianblur" aria-label="Applica effetto Gaussian Blur Pro GPU">
 ️ Applica Gaussian Blur
 </button>
 <p>
 Sfocatura professionale uniforme e naturale. Perfetto per sfondi, effetti DOF (profondità di campo), 
 e privacy. Più avanzato del blur standard. <kbd>F2</kbd> per confronto tecniche.
 </p>
 </div>
 
 <!-- ═══════════════════════════════════════════════════════════════════ -->
 <!-- 🆕 NUOVI EFFETTI GPU v44.0 - CHROMATIC, GLITCH, VHS -->
 <!-- ═══════════════════════════════════════════════════════════════════ -->
 
 <!-- CHROMATIC SHIFT \(RGB Split\) -->
 <div class="control-group gpu-effect-card" id="gpu-chromatic" style="background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 50%, #c44569 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4); margin-top: 16px;">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Chromatic Shift (Aberrazione Cromatica) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="chromatic-intensity" style="color: rgba(255,255,255,0.9);">Intensità (1-20 px)</label>
 <div class="slider-group">
 <input type="range" id="chromatic-intensity" min="1" max="20" value="5" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="chromatic-intensity-value" style="color: #fff;">5 px</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Distanza di separazione dei canali RGB
 </small>
 </div>
 <div class="input-with-label">
 <label for="chromatic-angle" style="color: rgba(255,255,255,0.9);">Direzione (0-360°)</label>
 <div class="slider-group">
 <input type="range" id="chromatic-angle" min="0" max="360" value="0" step="15"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="chromatic-angle-value" style="color: #fff;">0° (Orizzontale)</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 0°=Orizzontale, 90°=Verticale, 180°=Orizzontale inverso
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-chromatic" aria-label="Applica effetto Chromatic Shift GPU">
 Applica Chromatic Shift
 </button>
 <p>
 Separa i canali RGB creando un effetto di aberrazione cromatica ottica. 
 Simula difetti di lenti vintage o effetti psichedelici. <kbd>F2</kbd> per guida completa.
 </p>
 </div>
 
 <!-- GLITCH EFFECT -->
 <div class="control-group gpu-effect-card" id="gpu-glitch" style="background: linear-gradient(135deg, #00d2ff 0%, #3a7bd5 50%, #00d2ff 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(0, 210, 255, 0.4); margin-top: 16px;">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">Glitch (Distorsione Digitale) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="glitch-intensity" style="color: rgba(255,255,255,0.9);">Intensità (1-100)</label>
 <div class="slider-group">
 <input type="range" id="glitch-intensity" min="1" max="100" value="30" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="glitch-intensity-value" style="color: #fff;">30</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Quantità di distorsione e spostamenti
 </small>
 </div>
 <div class="input-with-label">
 <label for="glitch-blocks" style="color: rgba(255,255,255,0.9);">Blocchi Glitch (2-20)</label>
 <div class="slider-group">
 <input type="range" id="glitch-blocks" min="2" max="20" value="8" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="glitch-blocks-value" style="color: #fff;">8</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Numero di righe/blocchi distorte (più = più caotico)
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-glitch" aria-label="Applica effetto Glitch GPU">
 Applica Glitch
 </button>
 <p>
 Crea distorsioni digitali con spostamenti RGB e blocchi disallineati. 
 Perfetto per estetica cyberpunk, malfunzionamenti tecnologici. <kbd>F2</kbd> per esempi.
 </p>
 </div>
 
 <!-- VHS LIGHT EFFECT -->
 <div class="control-group gpu-effect-card" id="gpu-vhs" style="background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4); margin-top: 16px;">
 <div style="font-weight: 600; font-size: 15px; color: white; margin-bottom: 12px;">VHS Light (Effetto VHS Vintage) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="vhs-intensity" style="color: rgba(255,255,255,0.9);">Intensità Disturbo (0-100)</label>
 <div class="slider-group">
 <input type="range" id="vhs-intensity" min="0" max="100" value="40" step="5"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="vhs-intensity-value" style="color: #fff;">40</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Quantità di rumore e artefatti VHS
 </small>
 </div>
 <div class="input-with-label">
 <label for="vhs-lines" style="color: rgba(255,255,255,0.9);">Righe Scan (0-10)</label>
 <div class="slider-group">
 <input type="range" id="vhs-lines" min="0" max="10" value="3" step="1"
 style="background: rgba(255,255,255,0.3);">
 <span class="slider-value" id="vhs-lines-value" style="color: #fff;">3</span>
 </div>
 <small style="color: rgba(255,255,255,0.8); font-size: 10px;">
 Numero di righe orizzontali di scansione (0 = nessuna)
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-vhs" aria-label="Applica effetto VHS Light GPU">
 Applica VHS Light
 </button>
 <p>
 Ricrea l'estetica delle videocassette anni '80-'90 con rumore, righe e leggero 
 sfocamento. Perfetto per retrowave e vaporwave. <kbd>F2</kbd> per preset.
 </p>
 </div>
 
 <!-- DEHAZE / DEFOG -->
 <div class="control-group gpu-effect-card" id="gpu-dehaze" style="background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(168, 237, 234, 0.4); margin-top: 16px;">
 <div style="font-weight: 700; font-size: 16px; margin-bottom: 16px;">️ Dehaze / Defog (Rimozione Foschia) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="dehaze-strength" style="color: #0d47a1;">Intensità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="dehaze-strength" min="0" max="100" value="50" step="5"
 style="background: rgba(13, 71, 161, 0.2);">
 <span class="slider-value" id="dehaze-strength-value" style="color: #0d47a1;">50</span>
 </div>
 <small style="color: #1565c0; font-size: 10px;">
 Quanto rimuovere la foschia/nebbia dall'immagine
 </small>
 </div>
 <div class="input-with-label">
 <label for="dehaze-saturation" style="color: #0d47a1;">Recupero Saturazione (0-100)</label>
 <div class="slider-group">
 <input type="range" id="dehaze-saturation" min="0" max="100" value="30" step="5"
 style="background: rgba(13, 71, 161, 0.2);">
 <span class="slider-value" id="dehaze-saturation-value" style="color: #0d47a1;">30</span>
 </div>
 <small style="color: #1565c0; font-size: 10px;">
 Ripristina i colori persi dalla foschia
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-dehaze" 
 style="background: linear-gradient(to right, #0d47a1, #1565c0); color: white;"
 role="button" aria-label="Applica effetto Dehaze GPU">
 ️ Applica Dehaze
 </button>
 <p style="color: #0d47a1;">
 Rimuove foschia, nebbia e caligine da foto di paesaggi o immagini atmosferiche. 
 Ripristina contrasto e profondità. <kbd>F2</kbd> per guida dettagliata.
 </p>
 </div>
 
 <!-- BLOOM SOFT -->
 <div class="control-group gpu-effect-card" id="gpu-bloomsoft" style="background: linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%); border: none; border-radius: 12px; padding: 20px; box-shadow: 0 4px 15px rgba(255, 236, 210, 0.4); margin-top: 16px;">
 <div style="font-weight: 700; font-size: 16px; margin-bottom: 16px;">Bloom Soft (Bagliore Morbido) <span class="gpu-badge">GPU</span></div>
 <div class="input-with-label">
 <label for="bloomsoft-threshold" style="color: #d84315;">Soglia Luminosità (0-100)</label>
 <div class="slider-group">
 <input type="range" id="bloomsoft-threshold" min="0" max="100" value="70" step="5"
 style="background: rgba(216, 67, 21, 0.2);">
 <span class="slider-value" id="bloomsoft-threshold-value" style="color: #d84315;">70</span>
 </div>
 <small style="color: #e64a19; font-size: 10px;">
 Quanto devono essere luminose le aree per brillare
 </small>
 </div>
 <div class="input-with-label">
 <label for="bloomsoft-intensity" style="color: #d84315;">Intensità Bagliore (1-50)</label>
 <div class="slider-group">
 <input type="range" id="bloomsoft-intensity" min="1" max="50" value="15" step="2"
 style="background: rgba(216, 67, 21, 0.2);">
 <span class="slider-value" id="bloomsoft-intensity-value" style="color: #d84315;">15</span>
 </div>
 <small style="color: #e64a19; font-size: 10px;">
 Quanto è morbido e diffuso il bagliore
 </small>
 </div>
 <div class="input-with-label">
 <label for="bloomsoft-radius" style="color: #d84315;">Raggio Diffusione (2-20px)</label>
 <div class="slider-group">
 <input type="range" id="bloomsoft-radius" min="2" max="20" value="8" step="1"
 style="background: rgba(216, 67, 21, 0.2);">
 <span class="slider-value" id="bloomsoft-radius-value" style="color: #d84315;">8 px</span>
 </div>
 <small style="color: #e64a19; font-size: 10px;">
 Quanto si espande il bagliore attorno alle luci
 </small>
 </div>
 <button class="btn btn-full gpu-apply-btn" id="btn-apply-bloomsoft" 
 style="background: linear-gradient(to right, #d84315, #e64a19); color: white;"
 role="button" aria-label="Applica effetto Bloom Soft GPU">
 Applica Bloom Soft
 </button>
 <p style="color: #d84315;">
 Versione morbida del bloom base: crea bagliori delicati e eterei sulle aree luminose. 
 Perfetto per ritratti sognanti e atmosfere magiche. <kbd>F2</kbd> per confronto con Bloom base.
 </p>
 </div>
 </div>
    </div>
</details>
 </div>



 
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">14</span>
 <h2 class="section-heading">Palette Colori</h2>
 </div>
 <div class="section-content" id="palette-section">
 <p class="section-description">Salva i tuoi colori preferiti</p>
 
 <div class="color-palette" id="color-palette">
 <!-- Popolato dinamicamente -->
 </div>
 
 <button class="btn btn-secondary btn-full mt-12" id="btn-save-color" >Salva Colore Attuale</button>
 </div>
 </section>
 
 
 <!-- PANNELLO 12: ESPORTA -->
 <!-- PANNELLO 12: ANALISI -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">14</span>
 <h2 class="section-heading">Analisi & Revisione</h2>
 </div>
 <div class="section-content" id="analysis-section">
 <p class="section-description">Ottieni feedback sulla composizione</p>
 
 <button class="btn btn-info btn-full" id="btn-analyze">Analizza Composizione</button>
 <button class="btn btn-info btn-full mt-8" id="btn-generate-alt" >Genera Testo Alternativo (ALT)</button>
 </div>
 </section>
 
 <!-- PANNELLO 13: EXPORT -->
 <section class="section-panel">
 <div class="section-header" style="width: 100%; text-align: left; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius); margin-bottom: 8px;">
 <span class="section-number">14</span>
 <h2 class="section-heading">Esporta</h2>
 </div>
 <div class="section-content" id="export-section">
 <p class="section-description">Salva il tuo progetto</p>
 
 <div class="control-group">
 <strong class="control-group-title">Immagine</strong>
 <div class="btn-group">
 <button class="btn btn-success" id="btn-export-png">PNG</button>
 <button class="btn btn-success" id="btn-export-jpg">JPEG</button>
 </div>
 </div>
 
 <div class="control-group">
 <strong class="control-group-title">Progetto</strong>
 <button class="btn btn-primary btn-full" id="btn-save-project">Salva Progetto (.json)</button>
 <label class="btn btn-secondary btn-full" style="text-align: center; cursor: pointer; margin-top: 8px;">
 Carica Progetto
 <input type="file" id="load-project" accept=".json" class="hidden">
 </label>
 </div>
 </div>
 </section>
 </aside>
 
 <!-- CANVAS AREA -->
 <main class="canvas-wrapper" role="main" aria-label="Area di lavoro canvas">
 <!-- TOOLBAR -->
 <div class="toolbar" role="toolbar" aria-label="Barra strumenti principali">
 <div class="toolbar-section">
 <button class="btn btn-secondary" id="btn-undo" title="Annulla (Ctrl+Z)">
 ↶ Annulla
 </button>
 <button class="btn btn-secondary" id="btn-redo" title="Ripeti (Ctrl+Y)">
 ↷ Ripeti
 </button>
 </div>
 
 <div class="toolbar-section">
 <button class="btn btn-secondary" id="btn-zoom-out" title="Zoom Out (-)">
 -
 </button>
 <span id="zoom-display" style="min-width: 60px; text-align: center; font-weight: 600;">100%</span>
 <button class="btn btn-secondary" id="btn-zoom-in" title="Zoom In (+)">
 +
 </button>
 <button class="btn btn-secondary" id="btn-zoom-reset" title="Reset Zoom">
 100%
 </button>
 </div>
 
 <div class="toolbar-section">
 <button class="btn btn-success" id="btn-describe-canvas" title="Descrivi Canvas con AI (Ctrl+I)" aria-describedby="describe-canvas-help">
 Descrivi Canvas
 </button>
 <button class="btn btn-success" id="btn-describe-vector" title="Descrivi Disegno Vettoriale con AI (Ctrl+Shift+V)" aria-describedby="describe-vector-help">
 Descrivi Vettoriale
 </button>
 <button class="btn btn-info" id="btn-fullscreen" title="Anteprima Schermo Intero (Alt+A)">
 ️ Anteprima
 </button>
 <button class="btn btn-info" id="btn-sound-map" title="Mappa Sonora (Ctrl+M)">
 Mappa Sonora
 </button>
 <button class="btn btn-secondary" id="btn-keyboard-guide" title="Guida Tastiera (F1)">
 ⌨️ Guida (F1)
 </button>
 </div>
 </div>
 <p id="describe-canvas-help" class="sr-only">Usa Gemini AI per ottenere una descrizione completa della composizione attuale del canvas</p>
 <p id="describe-vector-help" class="sr-only">Usa Gemini AI per ottenere una descrizione del disegno vettoriale creato con le frecce</p>
 
 <!-- CANVAS CONTAINER -->
 <div class="canvas-container" id="main-canvas">
 <canvas id="canvas" width="1080" height="1080" role="img" aria-label="Area di lavoro principale"></canvas>
 </div>
 </div>
 </div>
 </main>
 
 <!-- TOAST NOTIFICHE -->
 <div class="toast" id="toast" aria-hidden="true"></div>
 
 <!-- MODAL GUIDA -->
 <div class="modal" id="modal-guide" role="dialog" aria-labelledby="guideTitle" aria-modal="true">
 <div class="modal-content">
 <div class="modal-header">
 <h2 id="guideTitle">Guida Tasti Rapidi</h2>
 <button class="close-btn" id="closeGuide">&times;</button>
 </div>
 <div class="modal-body" id="guideBody">
 <!-- Popolato da JavaScript -->
 </div>
 </div>
 </div>
 
 <!-- MODAL ANALISI -->
 <div class="modal" id="modal-analysis" role="dialog" aria-labelledby="analysisTitle" aria-modal="true">
 <div class="modal-content">
 <div class="modal-header">
 <h2 id="analysisTitle">Analisi Composizione</h2>
 <button class="close-btn" id="closeAnalysis">&times;</button>
 </div>
 <div class="modal-body" id="analysisBody">
 <!-- Popolato da JavaScript -->
 </div>
 </div>
 </div>
 
 <!-- MODAL ALT TEXT -->
 <!-- MODAL AGGIUNTA ESPLORAZIONE -->
 <div class="modal" id="modal-explore-add" role="dialog" aria-labelledby="exploreAddTitle" aria-modal="true">
 <div class="modal-content">
 <div class="modal-header">
 <h2 id="exploreAddTitle">Aggiungi elemento nel punto corrente</h2>
 <button class="close-btn" id="closeExploreAdd">×</button>
 </div>
 <div class="modal-body">
 <p>Seleziona cosa vuoi aggiungere nel punto corrente del cursore di esplorazione.</p>
 <button id="btn-explore-add-text">Testo</button>
 <button id="btn-explore-add-image">Immagine</button>
 <button id="btn-explore-add-shape">Forma</button>
 <button id="btn-explore-add-vector">Disegno vettoriale</button>
 </div>
 </div>
 </div>

 <div class="modal" id="modal-alt-text" role="dialog" aria-labelledby="altTextTitle" aria-modal="true">
 <div class="modal-content">
 <div class="modal-header">
 <h2 id="altTextTitle">Testo Alternativo Generato</h2>
 <button class="close-btn" id="closeAltText">×</button>
 </div>
 <div class="modal-body" id="altTextBody" style="font-family: inherit;">
 <!-- Popolato da JavaScript -->
 </div>
 <div style="padding: 20px; border-top: 1px solid var(--border-color);">
 <button class="btn btn-primary btn-full" id="copyAltText">Copia Testo</button>
 </div>
 </div>
 </div>
 
 <!-- MODALE CONFIGURAZIONE API GEMINI -->
 <div class="modal" id="modal-api-config" role="dialog" aria-labelledby="apiConfigTitle" aria-modal="true">
 <div class="modal-content">
 <div class="modal-header">
 <h2 id="apiConfigTitle">Configurazione API Gemini</h2>
 <button class="close-btn" id="closeApiConfig" aria-label="Chiudi configurazione API">×</button>
 </div>
 <div class="modal-body" style="padding: 20px;">
 <p style="margin-bottom: 16px; color: var(--text-secondary);">
 Configura la tua API Key di Google Gemini per abilitare le descrizioni AI delle immagini.
 </p>
 
 <div class="control-group">
 <label for="gemini-api-key" style="font-weight: 600; margin-bottom: 8px; display: block;">API Key Google Gemini</label>
 <input type="password" id="gemini-api-key" placeholder="Inserisci la tua API key..." aria-describedby="api-key-help" style="width: 100%; padding: 10px; border: 2px solid var(--border-color); border-radius: 6px; font-size: 14px;">
 <p id="api-key-help" style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
 Ottieni la tua chiave API gratuita su <a href="https://aistudio.google.com/apikey" target="_blank" style="color: var(--primary-color); text-decoration: underline;">Google AI Studio</a>
 </p>
 <div id="api-status" role="status" aria-live="polite" style="margin-top: 12px; padding: 12px; border-radius: 6px; font-size: 13px; display: none;"></div>
 </div>
 </div>
 <div style="padding: 20px; border-top: 1px solid var(--border-color); display: flex; gap: 12px;">
 <button class="btn btn-info flex-1" id="btn-test-api" >
 Testa Connessione
 </button>
 <button class="btn btn-primary flex-1" id="btn-save-api" >
 Salva e Chiudi
 </button>
 </div>
 </div>
 </div>
 
 <!-- FULLSCREEN PREVIEW -->
 <div id="fullscreen-preview">
 <canvas id="fullscreen-canvas"></canvas>
 </div>
 
 <script>
 (function() {
 'use strict';
 
 // ---- UTILITY FUNCTIONS PER SCREEN READER ----
 
 /**
 * Annuncia messaggi agli screen reader
 * @param {string} text - Testo da annunciare
 * @param {boolean|string} assertive - 'assertive', 'polite', true o false
 */
 function announceGemini(text, assertive = false) {
 // Gestisce sia booleani che stringhe 'polite'/'assertive'
 let regionId;
 if (typeof assertive === 'string') {
 regionId = assertive === 'assertive' ? 'sr-assert' : 'sr-polite';
 } else {
 regionId = assertive ? 'sr-assert' : 'sr-polite';
 }
 
 const region = document.getElementById(regionId);
 
 if (region) {
 region.textContent = '';
 setTimeout(() => { region.textContent = text; }, 50);
 }
 }
 
 // Esporta come funzione globale per compatibilità con altri script
 window.announceGemini = announceGemini;
 
 // ---- UTILITY FUNCTIONS PER GESTIONE ERRORI ----
 
 // Sistema di logging errori centralizzato
 const errorLog = [];
 const MAX_ERROR_LOG = 50;
 
 function logError(context, error, userMessage) {
 const errorEntry = {
 timestamp: new Date().toISOString(),
 context: context,
 error: error.message || String(error),
 stack: error.stack,
 userMessage: userMessage
 };
 
 errorLog.push(errorEntry);
 if (errorLog.length > MAX_ERROR_LOG) {
 errorLog.shift();
 }
 
 console.error(`[${context}]`, error);
 }
 
 // Esporta log errori per debug
 function exportErrorLog() {
 if (errorLog.length === 0) {
 announceGemini('Nessun errore registrato', 'polite');
 return;
 }
 
 const logText = errorLog.map(entry => 
 `[${entry.timestamp}] ${entry.context}: ${entry.error}\n${entry.userMessage || ''}\n`
 ).join('\n---\n');
 
 const blob = new Blob([logText], { type: 'text/plain' });
 const url = URL.createObjectURL(blob);
 const a = document.createElement('a');
 a.href = url;
 a.download = 'error-log-' + Date.now() + '.txt';
 a.click();
 URL.revokeObjectURL(url);
 announceGemini('Log errori esportato', 'assertive');
 }
 
 // Wrapper sicuro per funzioni sincrone
 function safeExecute(fn, errorMessage = 'Si è verificato un errore') {
 try {
 return fn();
 } catch (error) {
 logError(errorMessage, error, errorMessage);
 announceGemini(errorMessage, 'assertive');
 return null;
 }
 }
 
 // Wrapper sicuro per funzioni asincrone
 async function safeExecuteAsync(fn, errorMessage = 'Si è verificato un errore') {
 try {
 return await fn();
 } catch (error) {
 logError(errorMessage, error, errorMessage);
 announceGemini(errorMessage, 'assertive');
 return null;
 }
 }
 
 // ---- PERFORMANCE MONITORING ----
 
 const performanceMetrics = {
 renderCount: 0,
 renderTime: [],
 lastRenderDuration: 0,
 avgRenderTime: 0
 };
 
 function trackPerformance(metricName, duration) {
 if (metricName === 'render') {
 performanceMetrics.renderCount++;
 performanceMetrics.lastRenderDuration = duration;
 performanceMetrics.renderTime.push(duration);
 
 // Mantieni solo ultimi 100 render
 if (performanceMetrics.renderTime.length > 100) {
 performanceMetrics.renderTime.shift();
 }
 
 // Calcola media
 const sum = performanceMetrics.renderTime.reduce((a, b) => a + b, 0);
 performanceMetrics.avgRenderTime = sum / performanceMetrics.renderTime.length;
 
 // Avvisa se performance basse
 if (duration > 50) { // >50ms = sotto 20fps
 console.warn(`️ Render lento: ${duration.toFixed(2)}ms`);
 }
 }
 }
 
 function getPerformanceReport() {
 return `
=== PERFORMANCE REPORT ===
Render totali: ${performanceMetrics.renderCount}
Tempo medio: ${performanceMetrics.avgRenderTime.toFixed(2)}ms
Ultimo render: ${performanceMetrics.lastRenderDuration.toFixed(2)}ms
FPS stimati: ${performanceMetrics.avgRenderTime > 0 ? (1000 / performanceMetrics.avgRenderTime).toFixed(1) : 'N/A'}
Layer attivi: ${(window.state || window.APP?.state || { layers: [] }).layers.length}
Errori registrati: ${errorLog.length}
 `.trim();
 }
 
 // Comando console per debug
 window.editorDebug = {
 getPerformance: () => console.log(getPerformanceReport()),
 getErrors: () => console.table(errorLog),
 exportErrors: exportErrorLog,
 clearErrors: () => { errorLog.length = 0; console.log(' Log errori pulito'); },
 getState: () => console.log(window.state || window.APP?.state || {})
 };
 
 // ---- SISTEMA DI CLEANUP PER MEMORY LEAK ----
 const activeTimers = new Set();
 const activeIntervals = new Set();
 const registeredListeners = new WeakMap();
 
 // Utility per aggiungere listener evitando duplicati
 function safeAddEventListener(element, event, handler, options) {
 if (!element) {
 console.warn('safeAddEventListener: elemento null/undefined');
 return;
 }
 
 if (!registeredListeners.has(element)) {
 registeredListeners.set(element, new Map());
 }
 const elementListeners = registeredListeners.get(element);
 const key = `${event}_${handler.name || 'anonymous'}`;
 
 if (!elementListeners.has(key)) {
 element.addEventListener(event, handler, options);
 elementListeners.set(key, { event, handler, options });
 console.log(` Listener registrato: ${event} su`, element.id || element.tagName);
 } else {
 console.log(`️ Listener già esistente: ${event} su`, element.id || element.tagName);
 }
 }
 
 // Utility per rimuovere listener specifici
 function safeRemoveEventListener(element, event, handler) {
 if (!element || !registeredListeners.has(element)) return;
 
 const elementListeners = registeredListeners.get(element);
 const key = `${event}_${handler.name || 'anonymous'}`;
 
 if (elementListeners.has(key)) {
 const { handler: storedHandler, options } = elementListeners.get(key);
 element.removeEventListener(event, storedHandler, options);
 elementListeners.delete(key);
 console.log(` Listener rimosso: ${event} da`, element.id || element.tagName);
 }
 }
 
 // Rimuovi tutti i listener da un elemento
 function removeAllListeners(element) {
 if (!element || !registeredListeners.has(element)) return;
 
 const elementListeners = registeredListeners.get(element);
 for (const [key, { event, handler, options }] of elementListeners) {
 element.removeEventListener(event, handler, options);
 }
 registeredListeners.delete(element);
 console.log(` Tutti i listener rimossi da`, element.id || element.tagName);
 }
 
 // Export globalmente per uso nel codice
 window.safeAddEventListener = safeAddEventListener;
 window.safeRemoveEventListener = safeRemoveEventListener;
 window.removeAllListeners = removeAllListeners;
 
 // Override setTimeout per tracciare i timer
 const originalSetTimeout = window.setTimeout;
 window.setTimeout = function(callback, delay, ...args) {
 const timerId = originalSetTimeout(() => {
 activeTimers.delete(timerId);
 if (typeof callback === 'function') {
 callback(...args);
 }
 }, delay);
 activeTimers.add(timerId);
 return timerId;
 };
 
 // Override clearTimeout
 const originalClearTimeout = window.clearTimeout;
 window.clearTimeout = function(timerId) {
 activeTimers.delete(timerId);
 originalClearTimeout(timerId);
 };
 
 // Override setInterval per tracciare gli intervalli
 const originalSetInterval = window.setInterval;
 window.setInterval = function(callback, delay, ...args) {
 const intervalId = originalSetInterval(callback, delay, ...args);
 activeIntervals.add(intervalId);
 return intervalId;
 };
 
 // Override clearInterval
 const originalClearInterval = window.clearInterval;
 window.clearInterval = function(intervalId) {
 activeIntervals.delete(intervalId);
 originalClearInterval(intervalId);
 };
 
 // Cleanup function da chiamare prima di chiudere la pagina
 function cleanupResources() {
 // Clear all active timers
 activeTimers.forEach(timerId => clearTimeout(timerId));
 activeTimers.clear();
 
 // Clear all active intervals
 activeIntervals.forEach(intervalId => clearInterval(intervalId));
 activeIntervals.clear();
 
 // Clear render animation frame se esiste
 if (window.renderFrameId) {
 cancelAnimationFrame(window.renderFrameId);
 window.renderFrameId = null;
 }
 
 // Clear sweep animation frame se esiste
 if (window.sweepRaf) {
 cancelAnimationFrame(window.sweepRaf);
 window.sweepRaf = null;
 }
 
 // Clear render timeout se esiste (AGGIUNTO)
 if (window.state && window.state.renderTimeout !== null) {
 clearTimeout(window.state.renderTimeout);
 window.state.renderTimeout = null;
 }
 
 console.log(' Cleanup risorse completato');
 }
 
 // Registra cleanup quando la pagina viene chiusa
 window.addEventListener('beforeunload', cleanupResources);
 window.addEventListener('unload', cleanupResources);
 
 // ---- RIFERIMENTI DOM CON VALIDAZIONE ----
 
 // Validazione elementi critici
 function validateCriticalElements() {
 const critical = [
 { id: 'canvas', name: 'Canvas principale' },
 { id: 'toast', name: 'Sistema notifiche' },
 { id: 'sr-polite', name: 'Screen reader polite' },
 { id: 'sr-assert', name: 'Screen reader assertive' }
 ];
 
 const missing = [];
 for (const elem of critical) {
 if (!document.getElementById(elem.id)) {
 missing.push(elem.name);
 }
 }
 
 if (missing.length > 0) {
 const errorMsg = `Elementi DOM critici mancanti: ${missing.join(', ')}`;
 console.error(' ERRORE INIZIALIZZAZIONE:', errorMsg);
 alert(`Impossibile inizializzare l'editor.\n\n${errorMsg}\n\nRicarica la pagina.`);
 throw new Error(errorMsg);
 }
 }
 
 // Esegui validazione prima di inizializzare
 validateCriticalElements();
 
 const canvas = document.getElementById('canvas');
 const ctx = canvas.getContext('2d', { willReadFrequently: true });
 
 // Verifica contesto canvas
 if (!ctx) {
 const errorMsg = 'Impossibile ottenere il contesto 2D del canvas';
 logError('Inizializzazione', new Error(errorMsg), errorMsg);
 alert('Il tuo browser non supporta Canvas 2D.\n\nAggiorna il browser.');
 throw new Error(errorMsg);
 }
 
 const toast = document.getElementById('toast');
 const srPolite = document.getElementById('sr-polite');
 const srAssert = document.getElementById('sr-assert');
 const modalGuide = document.getElementById('modal-guide');
 const modalAnalysis = document.getElementById('modal-analysis');
 const modalAltText = document.getElementById('modal-alt-text');
 const modalExploreAdd = document.getElementById('modal-explore-add');
 const modalApiConfig = document.getElementById('modal-api-config');
 const altTextBody = document.getElementById('altTextBody');
 let announceSeq = 0;
 
 // Fullscreen
 const fullscreenContainer = document.getElementById('fullscreen-preview');
 const fullscreenCanvas = document.getElementById('fullscreen-canvas');
 let elementToFocusAfterFullscreen = null;
 
 // Audio
 let audioCtx;
 
 // Layer Color Controls (usati in updateUI e nei listener)
 const layerColorPreset = document.getElementById('lc');
 const layerColorCustomSection = document.getElementById('layer-color-custom-section');
 const layerColorHex = document.getElementById('layer-color-hex');
 const layerColorR = document.getElementById('layer-color-r');
 const layerColorG = document.getElementById('layer-color-g');
 const layerColorB = document.getElementById('layer-color-b');
 const layerColorPreview = document.getElementById('layer-color-preview');

 // ---- Funzioni Annunci e Modali ----
 
 // Funzione announce per NVDA (da v20)

 // ═══════════════════════════════════════════════════════════════
 // EFFETTI GPU GLOBALI - Funzioni UI
 // ═══════════════════════════════════════════════════════════════
 
 /**
 * Toggle abilitazione effetti GPU globali
 */
 
 /**
 * Aggiorna un singolo effetto GPU globale
 */
 window.updateGlobalGPUEffect = function(effectName, value) {
 state.globalEffects.gpuEffects[effectName] = value;
 
 // Aggiorna display valore
 const valueDisplay = document.getElementById(`gpu-global-${effectName}-val`);
 if (valueDisplay) {
 valueDisplay.textContent = value.toFixed(2);
 }
 
 // Re-render
 scheduleRender();
 
 // Annuncio screen reader (debounced)
 if (!window.gpuEffectAnnounceTimeout) {
 window.gpuEffectAnnounceTimeout = {};
 }
 
 clearTimeout(window.gpuEffectAnnounceTimeout[effectName]);
 window.gpuEffectAnnounceTimeout[effectName] = setTimeout(() => {
 announce(`${effectName} impostato a ${value.toFixed(2)}`, 'polite');
 }, 500);
 }
 
 /**
 * Reset tutti gli effetti GPU globali
 */
 window.resetGlobalGPUEffects = function() {
 const effects = ['brightness', 'contrast', 'hue', 'saturation', 'vibrance'];
 
 effects.forEach(effect => {
 state.globalEffects.gpuEffects[effect] = 0;
 
 const slider = document.getElementById(`gpu-global-${effect}`);
 const valueDisplay = document.getElementById(`gpu-global-${effect}-val`);
 
 if (slider) slider.value = '0';
 if (valueDisplay) valueDisplay.textContent = '0.00';
 });
 
 scheduleRender();
 announce('Tutti gli effetti GPU resettati ai valori predefiniti', 'polite');
 }

 function announce(msg, level = 'assertive') {
 console.log('[ANNOUNCE]', msg, level); // DEBUG
 
 // FILTRO TEMPORANEO: Blocca annunci che contengono pattern X/Y da frecce
 // (permette annunci espliciti da azioni dell'utente)
 if (msg && /[XxYy].*[XxYy]|[XxYy]:\s*\d+.*[YXyx]:\s*\d+/i.test(msg)) {
 // Se sembra un annuncio automatico di posizione, verifica se è intenzionale
 const isVectorMode = window.state && window.state.vectorDrawMode;
 const isExplicitAction = msg.includes('aggiunto') || msg.includes('posizionato') || 
 msg.includes('duplicato') || msg.includes('centro');
 
 if (!isVectorMode && !isExplicitAction) {
 console.log('[ANNOUNCE FILTERED]', msg); // Log ma non annuncia
 return; // Blocca annuncio
 }
 }
 
 const target = level === 'polite' ? srPolite : srAssert;
 
 // Pulizia e timeout per garantire la lettura NVDA
 target.textContent = '';
 setTimeout(() => {
 target.textContent = msg;
 }, 100); // NVDA fix: aumentato da 0 a 100ms
 
 showToast(msg);
 }
 
 function showToast(msg) {
 toast.textContent = msg;
 toast.classList.add('show');
 // DISABLED: toast.setAttribute('aria-hidden', 'false'); // Toast sempre silenzioso per SR
 clearTimeout(window.toastTimer);
 window.toastTimer = setTimeout(() => {
 toast.classList.remove('show');
 toast.setAttribute('aria-hidden', 'true');
 }, 2500); // Leggermente più lungo
 }
 
 // Debounce per annunci su slider (evita sovraccarico NVDA)
 let announceTimeout = null;
 function announceDebounced(msg, level = 'polite', delay = 400) {
 clearTimeout(announceTimeout);
 announceTimeout = setTimeout(() => {
 announce(msg, level);
 }, delay);
 }

 // Gestione Modali con Focus Trap (da v3.29)
 const activeFocusTraps = new Map(); // Traccia focus trap attivi
 const modalPreviousFocus = new Map(); // Salva focus prima di aprire modale
 
 function createFocusTrap(modal) {
 // Trova tutti gli elementi focalizzabili nel modal
 const focusableSelector = 'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])';
 const focusableElements = Array.from(modal.querySelectorAll(focusableSelector));
 
 if (focusableElements.length === 0) return null;
 
 const firstFocusable = focusableElements[0];
 const lastFocusable = focusableElements[focusableElements.length - 1];
 
 const trapHandler = (e) => {
 if (e.key !== 'Tab') return;
 
 // Tab normale: se sei sull'ultimo, vai al primo
 if (!e.shiftKey && document.activeElement === lastFocusable) {
 e.preventDefault();
 firstFocusable.focus();
 }
 // Shift+Tab: se sei sul primo, vai all'ultimo
 else if (e.shiftKey && document.activeElement === firstFocusable) {
 e.preventDefault();
 lastFocusable.focus();
 }
 };
 
 modal.addEventListener('keydown', trapHandler);
 
 return {
 activate: () => firstFocusable.focus(),
 deactivate: () => modal.removeEventListener('keydown', trapHandler)
 };
 }
 
 function openModal(modal) {
 // Salva focus corrente per ripristinarlo alla chiusura
 modalPreviousFocus.set(modal, document.activeElement);
 
 modal.style.display = 'flex';
 modal.setAttribute('aria-hidden', 'false');
 
 // Crea e attiva focus trap
 const trap = createFocusTrap(modal);
 if (trap) {
 activeFocusTraps.set(modal, trap);
 setTimeout(() => trap.activate(), 50);
 }
 }
 
 function closeModal(modal) { 
 modal.style.display = 'none';
 modal.setAttribute('aria-hidden', 'true');
 
 // Disattiva e rimuovi focus trap
 const trap = activeFocusTraps.get(modal);
 if (trap) {
 trap.deactivate();
 activeFocusTraps.delete(modal);
 }
 
 // Ripristina focus all'elemento che ha aperto la modale
 const previousFocus = modalPreviousFocus.get(modal);
 if (previousFocus && document.body.contains(previousFocus)) {
 setTimeout(() => previousFocus.focus(), 50);
 }
 modalPreviousFocus.delete(modal);
 }
 
 function openExploreAddModal() {
 if (!modalExploreAdd) return;
 openModal(modalExploreAdd);
 }
 
 function closeExploreAddModal() {
 if (!modalExploreAdd) return;
 closeModal(modalExploreAdd);
 }

 
 // ---- AUDIO MAPPA SONORA (da v3.29) ----
 function playBeep(frequency = 440, duration = 50) {
 if (!audioCtx) {
 try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
 catch (e) { console.warn('Web Audio API non supportata'); return; }
 }
 const oscillator = audioCtx.createOscillator();
 const gainNode = audioCtx.createGain();
 oscillator.connect(gainNode);
 gainNode.connect(audioCtx.destination);
 gainNode.gain.value = 0.1;
 oscillator.frequency.value = frequency;
 oscillator.type = 'sine';
 oscillator.start();
 setTimeout(() => oscillator.stop(), duration);
 }

 // ═══════════════════════════════════════════════════════════════
 // COSTANTI DI VALIDAZIONE E LIMITI - v39.0
 // ═══════════════════════════════════════════════════════════════
 const LIMITS = {
 // Layer System
 MAX_LAYERS: 500, // Limite massimo layer (previene crash memoria)
 
 // Canvas Dimensions
 MAX_CANVAS_WIDTH: 16384, // Limite WebGL/Canvas standard
 MAX_CANVAS_HEIGHT: 16384, // Limite WebGL/Canvas standard
 MIN_CANVAS_SIZE: 1, // Dimensione minima
 
 // Polygon Validation
 MIN_POLYGON_POINTS: 3, // Minimo per forma chiusa valida
 MIN_POLYLINE_POINTS: 2, // Minimo per linea aperta
 
 // Gemini AI
 MAX_IMAGE_SIZE_API: 2048, // Max dimensione immagine per API (previene timeout)
 API_TIMEOUT_MS: 60000, // 60 secondi timeout
 MAX_CHAT_HISTORY: 50, // Messaggi massimi in cronologia chat
 CHAT_CONTEXT_WINDOW: 6, // Messaggi usati per context API
 
 // Performance
 MAX_HISTORY_STATES: 50 // Stati undo/redo massimi
 };

 // Messaggi errore user-friendly - v39.0
 const ERROR_MESSAGES = {
 // API Gemini
 NO_API_KEY: 'Configura la tua chiave API Gemini. Vai alla sezione "Gemini AI" e inserisci la chiave ottenuta da Google AI Studio.',
 INVALID_API_KEY: 'Chiave API non valida. Verifica di aver copiato correttamente la chiave da Google AI Studio (deve iniziare con "AIza").',
 INVALID_RESPONSE: 'Risposta da Gemini non valida. Riprova tra qualche secondo.',
 RATE_LIMIT: 'Hai raggiunto il limite di richieste. Attendi 60 secondi prima di riprovare.',
 NETWORK_ERROR: 'Errore di connessione. Verifica la tua connessione internet e riprova.',
 TIMEOUT: "La richiesta ha impiegato troppo tempo. Prova con un'immagine più piccola o semplificata.",
 IMAGE_TOO_LARGE: 'Immagine troppo grande per l\'analisi. Riduci le dimensioni del canvas.',
 NO_CANVAS_DATA: 'Nessun contenuto da analizzare. Crea prima qualcosa sul canvas.',
 NO_VECTOR_DATA: 'Nessun disegno vettoriale trovato. Usa Ctrl+P per creare un disegno prima.',
 
 // Layer System
 MAX_LAYERS_REACHED: `Limite massimo di ${LIMITS.MAX_LAYERS} layer raggiunto. Elimina alcuni layer prima di continuare.`,
 INVALID_CANVAS_SIZE: `Dimensioni canvas non valide. Usa valori tra ${LIMITS.MIN_CANVAS_SIZE} e ${LIMITS.MAX_CANVAS_WIDTH}px.`,
 INVALID_POLYGON: `Poligono non valido. Servono almeno ${LIMITS.MIN_POLYGON_POINTS} punti per una forma chiusa.`,
 
 // Generic
 UNKNOWN: 'Errore sconosciuto. Riprova tra qualche istante.'
 };

 // ---- STATO ----
// v44.2: Compatibilità con codice legacy che usa SAFE_ZONE_PADDING
const SAFE_ZONE_PADDING = 60; // Valore di default, sovrascritto da state.tpl.safe quando necessario
const state = window.state = {
 layers: [],
 selectedIds: [],
 currentLayerIndex: 0, // Indice del layer corrente per effetti
 backgroundColor: '#ffffff',
 history: [],
 historyIndex: -1,
 zoom: 1,
 showGrid: false,
 gridSize: 20,
 clipboard: null,
 nextId: 1,
 usedIds: new Set(), // v39.0: Traccia ID usati per prevenire collisioni
 isDragging: false,
 isResizing: false,
 dragStart: { x: 0, y: 0 },
 layerStart: { x: 0, y: 0, w: 0, h: 0 },
 resizeHandle: null,
 colorPalette: ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'],
 eyedropperActive: false,
 cropMode: false,
 isGridModeActive: false, // Per Mappa Sonora
 gridCell: { x: 1, y: 1 }, // Per Mappa Sonora
 tpl: { w: 1080, h: 1080, safe: {top:60, right:60, bottom:60, left:60} }, // Da v3.29
 currentTemplate: 'instagram-post', // v44.2: Template corrente per safe zone
 // Esplorazione Canvas
 exploreMode: false, // Migrato da state.exploreMode
 explorationCursor: { x: 100, y: 100 },
 // Disegno Vettoriale
 vectorDrawMode: false,
 vectorDrawType: 'polyline', // 'polyline' o 'smooth',
 vectorSmoothIntensity: 0.5, // 0-1, dove 0.5 è medio
 vectorPoints: [],
 vectorCursor: { x: 540, y: 540 }, // Centro canvas
 vectorStep: 5,
 vectorFillColor: '#3b82f6',
 vectorStrokeColor: '#1e40af',
 vectorStrokeWidth: 2,
 // Performance
 renderPending: false,
 renderTimeout: null, // SPOSTATO QUI per evitare race condition
 lastRenderTime: 0,
 // v39.1: Safe Zone Visual Feedback
 showSafeZone: false, // Toggle per overlay safe zone
 
 // ═══════════════════════════════════════════════════════════════
 // SAFE ZONE UNIVERSALE - Funziona per TUTTI i social
 // ═══════════════════════════════════════════════════════════════
 // Margini calcolati per essere sicuri su:
 // Instagram (Post + Stories), TikTok, Facebook, YouTube,
 // Twitter/X, LinkedIn, Pinterest, Snapchat, e altri
 universalSafeZone: {
 top: 15, // Percentuale - Copre Instagram Stories (14%) + margine
 bottom: 25, // Percentuale - Copre TikTok (23%) + margine
 left: 10, // Percentuale - Margini laterali universali
 right: 10 // Percentuale - Margini laterali universali
 },

 // ═══════════════════════════════════════════════════════════════
 // EFFETTI GPU GLOBALI - Pipeline Unificata
 // ═══════════════════════════════════════════════════════════════
 globalEffects: {
 gpuEffects: {
 brightness: 0,
 contrast: 0,
 hue: 0,
 saturation: 0,
 vibrance: 0
 }
 }
 };

 // ═══════════════════════════════════════════════════════════════════════
 // MODULO GPU EFFECTS - WebGL Processing via glfx.js
 // ═══════════════════════════════════════════════════════════════════════
 
 /**
 * GpuEffects - Modulo isolato per effetti WebGL avanzati
 * 
 * Pipeline: Canvas 2D → Texture WebGL → Filtro GPU → Canvas 2D
 * 
 * Questo modulo gestisce:
 * - Inizializzazione contesto WebGL tramite glfx.js
 * - Conversione Canvas 2D ↔ Texture WebGL
 * - Applicazione filtri GPU (Curves, Color Balance, Blur Pro, Bloom)
 * - Fallback automatico se WebGL non supportato
 */
 const GpuEffects = {
 // Canvas WebGL (texture) di glfx
 glCanvas: null,
 
 // Texture per l'immagine corrente
 texture: null,
 
 // Flag: WebGL supportato?
 isWebGLSupported: false,
 
 /**
 * Inizializza il contesto WebGL usando glfx.js
 * @returns {boolean} true se WebGL è supportato e inizializzato
 */
 init() {
 try {
 // Verifica che glfx.js sia caricato e disponibile
 if (!window.glfxAvailable) {
 console.error(' GpuEffects: glfx.js non disponibile (window.glfxAvailable = false)');
 this.isWebGLSupported = false;
 return false;
 }
 
 if (typeof fx === 'undefined') {
 console.error(' GpuEffects: glfx.js non caricato (fx undefined)');
 this.isWebGLSupported = false;
 return false;
 }
 
 if (typeof fx.canvas !== 'function') {
 console.error(' GpuEffects: fx.canvas non è una funzione');
 this.isWebGLSupported = false;
 return false;
 }
 
 // Crea canvas WebGL con glfx.canvas()
 // glfx.js espone un canvas speciale con metodi per filtri GPU
 this.glCanvas = fx.canvas();
 
 if (!this.glCanvas) {
 console.error(' GpuEffects: fx.canvas() returned null');
 this.isWebGLSupported = false;
 return false;
 }
 
 this.isWebGLSupported = true;
 console.log(' GpuEffects: WebGL inizializzato con glfx.js');
 return true;
 } catch (error) {
 console.warn('️ GpuEffects: WebGL non supportato', error);
 this.isWebGLSupported = false;
 return false;
 }
 },
 
 /**
 * Applica un effetto GPU al canvas principale
 * 
 * @param {HTMLCanvasElement} sourceCanvas - Canvas 2D da cui leggere
 * @param {Function} filterCallback - Funzione che applica il filtro sulla texture
 * @returns {boolean} true se l'effetto è stato applicato con successo
 */
 applyEffect(sourceCanvas, filterCallback) {
 if (!this.isWebGLSupported || !this.glCanvas) {
 console.error(' GpuEffects: WebGL non disponibile');
 console.log('Debug: isWebGLSupported =', this.isWebGLSupported, 'glCanvas =', this.glCanvas);
 return false;
 }
 
 try {
 // Verifica che il canvas sorgente sia valido
 if (!sourceCanvas || !sourceCanvas.getContext) {
 console.error(' GpuEffects: Canvas sorgente non valido');
 return false;
 }
 
 // STEP 1: Canvas 2D → Texture WebGL
 // Carica l'immagine dal canvas 2D nella texture GPU
 this.texture = this.glCanvas.texture(sourceCanvas);
 
 // STEP 2: Applica il filtro GPU sulla texture
 // La callback riceve (glCanvas, texture) e applica i filtri
 this.glCanvas.draw(this.texture);
 filterCallback(this.glCanvas, this.texture);
 this.glCanvas.update();
 
 // STEP 3: WebGL → Canvas 2D
 // Ridisegna il risultato sul canvas 2D originale
 const ctx = sourceCanvas.getContext('2d');
 ctx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
 ctx.drawImage(this.glCanvas, 0, 0);
 
 // Cleanup texture per evitare memory leak
 this.texture.destroy();
 this.texture = null;
 
 console.log(' GpuEffects: Effetto applicato con successo');
 return true;
 
 } catch (error) {
 console.error(' GpuEffects: Errore durante applicazione effetto', error);
 return false;
 }
 },
 
 /**
 * CURVES PRO - Controllo curva tonale con preset
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {string} preset - Tipo di curva: 'linear', 'scurve', 'fade', 'contrast'
 */
 applyCurves(canvas, preset = 'scurve') {
 // Definizione dei punti di controllo per ogni preset
 // Formato: array di [x, y] dove x,y vanno da 0 a 1
 const curvePresets = {
 linear: [[0, 0], [1, 1]], // Nessuna modifica
 scurve: [[0, 0], [0.25, 0.15], [0.75, 0.85], [1, 1]], // Contrasto centrale
 fade: [[0, 0.15], [0.5, 0.55], [1, 0.95]], // Riduce contrasto (vintage)
 contrast: [[0, 0], [0.25, 0.1], [0.75, 0.9], [1, 1]] // Aumenta contrasto
 };
 
 // Validazione preset
 const curve = curvePresets[preset];
 if (!curve) {
 console.error(` Preset curva non valido: ${preset}`);
 return false;
 }
 
 // Applica l'effetto usando applyEffect
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // glfx.js non ha un filtro "curves" nativo,
 // quindi usiamo brightnessContrast come approssimazione
 // Per curve vere servirebbero shader custom
 
 if (preset === 'scurve') {
 glCanvas.brightnessContrast(0, 0.3);
 } else if (preset === 'fade') {
 glCanvas.brightnessContrast(0.15, -0.2);
 } else if (preset === 'contrast') {
 glCanvas.brightnessContrast(0, 0.5);
 }
 // 'linear' non fa nulla
 });
 },
 
 /**
 * COLOR BALANCE PRO - Regola ombre e luci separatamente
 */
 applyColorBalance(canvas, shadows = 0, highlights = 0) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Approssimazione: usiamo brightness per shadows e highlights
 const avgAdjust = (shadows + highlights) / 200;
 glCanvas.brightnessContrast(avgAdjust, 0);
 });
 },
 
 /**
 * BLUR PRO - Blur avanzato con GPU
 */
 applyBlurPro(canvas, radius = 5) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 glCanvas.triangleBlur(radius);
 });
 },
 
 /**
 * BLOOM - Effetto alone luminoso
 */
 applyBloom(canvas, threshold = 200, intensity = 100) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Bloom: aumenta luminosità delle parti chiare
 const normalizedIntensity = intensity / 100;
 glCanvas.brightnessContrast(0.2 * normalizedIntensity, 0.3 * normalizedIntensity);
 glCanvas.triangleBlur(3);
 });
 },
 
 /**
 * VIBRANCE - Aumenta saturazione dei colori meno saturi
 */
 applyVibrance(canvas, amount = 50) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 const normalizedAmount = amount / 50;
 glCanvas.vibrance(normalizedAmount);
 });
 },
 
 /**
 * WHITE BALANCE PRO - Temperatura e tinta colore
 */
 applyWhiteBalance(canvas, temperature = 0, tint = 0) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Approssimazione con hue/saturation
 if (temperature !== 0) {
 glCanvas.hueSaturation(temperature / 100, 0);
 }
 if (tint !== 0) {
 glCanvas.vibrance(tint / 100);
 }
 });
 },
 
 /**
 * HIGHLIGHTS & SHADOWS - Controllo separato luci e ombre
 */
 applyHighlightsShadows(canvas, shadows = 0, highlights = 0) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Usa brightness e contrast per simulare il controllo
 const brightness = (shadows - highlights) / 200;
 const contrast = Math.abs(shadows - highlights) / 100;
 glCanvas.brightnessContrast(brightness, contrast);
 });
 },
 
 /**
 * 🆕 MOTION BLUR - Sfocatura direzionale per effetto movimento
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} distance - Distanza/lunghezza del blur in pixel (1-50)
 * @param {number} angle - Angolo della direzione in gradi (0-360)
 */
 applyMotionBlur(canvas, distance = 15, angle = 0) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Converti angolo in radianti
 const radians = (angle * Math.PI) / 180;
 
 // Calcola componenti X e Y del vettore di movimento
 const deltaX = Math.cos(radians) * (distance / 2);
 const deltaY = Math.sin(radians) * (distance / 2);
 
 // glfx.js non ha motion blur nativo, simuliamo con zoom blur direzionale
 // Usiamo triangleBlur ripetuto in direzione specifica
 for (let i = 0; i < 3; i++) {
 glCanvas.triangleBlur(Math.floor(distance / 3));
 }
 });
 },
 
 /**
 * 🆕 TILT-SHIFT - Effetto miniatura con focus centrale
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} blurAmount - Intensità della sfocatura (1-30)
 * @param {number} focusSize - Dimensione area a fuoco in percentuale (10-80)
 */
 applyTiltShift(canvas, blurAmount = 10, focusSize = 40) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Tilt-shift simula uno sfocatura gradiente dall'alto e dal basso
 // con una fascia centrale a fuoco
 
 // glfx.js ha tiltShift nativo!
 const centerY = 0.5; // Centro verticale
 const focusHeight = focusSize / 100; // Converti percentuale
 const blurRadius = blurAmount;
 
 // Parametri tiltShift: startY, endY, blurRadius, gradientRadius
 glCanvas.tiltShift(
 centerY - focusHeight / 2, // Start blur top
 centerY + focusHeight / 2, // End blur bottom
 blurRadius, // Intensità blur
 focusHeight * 0.3 // Gradient smoothness
 );
 });
 },
 
 /**
 * 🆕 GAUSSIAN BLUR PRO - Sfocatura gaussiana di alta qualità
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} radius - Raggio della sfocatura (1-100)
 * @param {string} quality - Qualità: 'fast', 'balanced', 'high'
 */
 applyGaussianBlur(canvas, radius = 20, quality = 'balanced') {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Gaussian blur con algoritmo migliorato
 // Quality influenza il numero di passaggi
 
 let passes = 1;
 if (quality === 'balanced') passes = 2;
 if (quality === 'high') passes = 3;
 
 // Usa triangleBlur di glfx (simula gaussian con convoluzione)
 for (let i = 0; i < passes; i++) {
 glCanvas.triangleBlur(radius / passes);
 }
 });
 },
 
 // ═══════════════════════════════════════════════════════════════════════
 // 🆕 v44.0 - NUOVI EFFETTI: Chromatic Shift, Glitch, VHS Light
 // ═══════════════════════════════════════════════════════════════════════
 
 /**
 * 🆕 v44.0 - CHROMATIC SHIFT (RGB Split / Aberrazione Cromatica)
 * 
 * Separa i canali RGB creando un effetto di aberrazione cromatica.
 * Simula difetti di lenti ottiche vintage o effetti psichedelici.
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} intensity - Distanza separazione canali (1-20 px)
 * @param {number} angle - Direzione separazione in gradi (0-360)
 * @returns {boolean} true se applicato con successo
 */
 applyChromatic(canvas, intensity = 5, angle = 0) {
 // Converti angolo in radianti
 const rad = (angle * Math.PI) / 180;
 const offsetX = Math.cos(rad) * intensity;
 const offsetY = Math.sin(rad) * intensity;
 
 // Usa canvas 2D per questo effetto (più controllo sui canali)
 try {
 const ctx = canvas.getContext('2d');
 const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
 const data = imageData.data;
 const w = canvas.width;
 const h = canvas.height;
 
 // Crea copia dei dati originali
 const originalData = new Uint8ClampedArray(data);
 
 // Applica spostamento ai canali
 for (let y = 0; y < h; y++) {
 for (let x = 0; x < w; x++) {
 const i = (y * w + x) * 4;
 
 // Canale Rosso: spostato positivo
 const redX = Math.round(x + offsetX);
 const redY = Math.round(y + offsetY);
 if (redX >= 0 && redX < w && redY >= 0 && redY < h) {
 const redI = (redY * w + redX) * 4;
 data[i] = originalData[redI];
 }
 
 // Canale Verde: nessuno spostamento (referenza)
 // data[i + 1] rimane invariato
 
 // Canale Blu: spostato negativo
 const blueX = Math.round(x - offsetX);
 const blueY = Math.round(y - offsetY);
 if (blueX >= 0 && blueX < w && blueY >= 0 && blueY < h) {
 const blueI = (blueY * w + blueX) * 4;
 data[i + 2] = originalData[blueI + 2];
 }
 }
 }
 
 ctx.putImageData(imageData, 0, 0);
 console.log(` Chromatic Shift applicato: ${intensity}px @ ${angle}°`);
 return true;
 
 } catch (error) {
 console.error(' Errore Chromatic Shift:', error);
 return false;
 }
 },
 
 /**
 * 🆕 v44.0 - GLITCH EFFECT (Distorsione Digitale)
 * 
 * Crea distorsioni digitali con spostamenti RGB casuali e blocchi disallineati.
 * Perfetto per estetica cyberpunk e malfunzionamenti tecnologici.
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} intensity - Intensità distorsione (1-100)
 * @param {number} blocks - Numero di blocchi glitch (2-20)
 * @returns {boolean} true se applicato con successo
 */
 applyGlitch(canvas, intensity = 30, blocks = 8) {
 try {
 const ctx = canvas.getContext('2d');
 const w = canvas.width;
 const h = canvas.height;
 
 // Salva immagine originale
 const originalData = ctx.getImageData(0, 0, w, h);
 
 // Normalizza intensità (0-1)
 const normalizedIntensity = intensity / 100;
 
 // Genera blocchi glitch casuali
 for (let i = 0; i < blocks; i++) {
 // Posizione casuale
 const y = Math.floor(Math.random() * h);
 const blockHeight = Math.floor(Math.random() * (h / blocks) + 10);
 
 // Spostamento orizzontale casuale
 const shift = (Math.random() - 0.5) * w * normalizedIntensity * 0.2;
 
 // Copia blocco spostato
 const blockData = ctx.getImageData(0, y, w, Math.min(blockHeight, h - y));
 ctx.putImageData(blockData, shift, y);
 
 // RGB shift leggero su alcuni blocchi
 if (Math.random() > 0.5) {
 const rgbShift = normalizedIntensity * 5;
 const tempData = ctx.getImageData(0, y, w, Math.min(blockHeight, h - y));
 const data = tempData.data;
 
 for (let j = 0; j < data.length; j += 4) {
 // Shift canali RGB
 if (Math.random() > 0.7) {
 data[j] = Math.min(255, data[j] + rgbShift * 10); // R
 data[j + 2] = Math.max(0, data[j + 2] - rgbShift * 10); // B
 }
 }
 
 ctx.putImageData(tempData, 0, y);
 }
 }
 
 // Rumore digitale leggero
 const imageData = ctx.getImageData(0, 0, w, h);
 const data = imageData.data;
 const noiseIntensity = normalizedIntensity * 15;
 
 for (let i = 0; i < data.length; i += 4) {
 if (Math.random() > 0.95) {
 const noise = (Math.random() - 0.5) * noiseIntensity;
 data[i] = Math.max(0, Math.min(255, data[i] + noise));
 data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
 data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
 }
 }
 
 ctx.putImageData(imageData, 0, 0);
 console.log(` Glitch applicato: intensity ${intensity}, ${blocks} blocchi`);
 return true;
 
 } catch (error) {
 console.error(' Errore Glitch:', error);
 return false;
 }
 },
 
 /**
 * 🆕 v44.0 - VHS LIGHT EFFECT (Effetto VHS Vintage)
 * 
 * Ricrea l'estetica delle videocassette VHS anni '80-'90 con:
 * - Rumore digitale e artefatti
 * - Righe di scansione orizzontali
 * - Leggero sfocamento e distorsione colore
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} intensity - Intensità disturbo (0-100)
 * @param {number} scanLines - Numero righe scan (0-10)
 * @returns {boolean} true se applicato con successo
 */
 applyVHS(canvas, intensity = 40, scanLines = 3) {
 try {
 const ctx = canvas.getContext('2d');
 const w = canvas.width;
 const h = canvas.height;
 const imageData = ctx.getImageData(0, 0, w, h);
 const data = imageData.data;
 
 // Normalizza intensità
 const normalizedIntensity = intensity / 100;
 
 // 1. Rumore VHS (grana)
 const noiseAmount = normalizedIntensity * 20;
 for (let i = 0; i < data.length; i += 4) {
 const noise = (Math.random() - 0.5) * noiseAmount;
 data[i] = Math.max(0, Math.min(255, data[i] + noise));
 data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise));
 data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise));
 }
 
 // 2. Shift cromatico leggero (tipico VHS)
 const chromaShift = Math.floor(normalizedIntensity * 3);
 if (chromaShift > 0) {
 for (let y = 0; y < h; y++) {
 for (let x = 0; x < w - chromaShift; x++) {
 const i = (y * w + x) * 4;
 const shiftI = (y * w + x + chromaShift) * 4;
 // Shift rosso a destra
 data[shiftI] = data[i];
 }
 }
 }
 
 ctx.putImageData(imageData, 0, 0);
 
 // 3. Righe di scansione orizzontali
 if (scanLines > 0) {
 ctx.globalAlpha = 0.1 + (normalizedIntensity * 0.1);
 ctx.fillStyle = '#000000';
 
 const spacing = Math.floor(h / (scanLines * 4));
 for (let i = 0; i < scanLines; i++) {
 const y = Math.floor(Math.random() * h);
 ctx.fillRect(0, y, w, 2);
 
 // Aggiungi alcune righe distribuite uniformemente
 for (let j = 0; j < 4; j++) {
 const uniformY = (i * 4 + j) * spacing;
 if (uniformY < h) {
 ctx.fillRect(0, uniformY, w, 1);
 }
 }
 }
 
 ctx.globalAlpha = 1.0;
 }
 
 // 4. Leggero blur per simulare bassa risoluzione VHS
 if (normalizedIntensity > 0.3) {
 // Usa un leggerissimo blur usando glfx se disponibile
 if (this.isWebGLSupported) {
 this.applyEffect(canvas, (glCanvas, texture) => {
 glCanvas.triangleBlur(1 + normalizedIntensity * 2);
 });
 }
 }
 
 console.log(` VHS Light applicato: intensity ${intensity}, ${scanLines} scan lines`);
 return true;
 
 } catch (error) {
 console.error(' Errore VHS Light:', error);
 return false;
 }
 },
 
 /**
 * 🆕 v44.1 - DEHAZE / DEFOG
 * Rimuove foschia e nebbia da foto atmosferiche
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} strength - Intensità rimozione foschia (0-100)
 * @param {number} saturationBoost - Recupero saturazione persa (0-100)
 * @returns {boolean} true se applicato con successo
 */
 applyDehaze(canvas, strength = 50, saturationBoost = 30) {
 try {
 const ctx = canvas.getContext('2d');
 const w = canvas.width;
 const h = canvas.height;
 const imageData = ctx.getImageData(0, 0, w, h);
 const data = imageData.data;
 
 // Normalizza parametri
 const dehazeStrength = strength / 100;
 const satBoost = saturationBoost / 100;
 
 // 1. Aumenta contrasto locale (rimuove foschia)
 // La foschia riduce il contrasto, quindi lo ripristiniamo
 const contrastBoost = 1 + (dehazeStrength * 0.5); // Max +50% contrasto
 
 // 2. Recupera saturazione (la foschia desatura i colori)
 const saturationFactor = 1 + (satBoost * 0.8); // Max +80% saturazione
 
 for (let i = 0; i < data.length; i += 4) {
 const r = data[i];
 const g = data[i + 1];
 const b = data[i + 2];
 
 // Applica contrasto (pivot a 128 = grigio medio)
 let newR = 128 + (r - 128) * contrastBoost;
 let newG = 128 + (g - 128) * contrastBoost;
 let newB = 128 + (b - 128) * contrastBoost;
 
 // Clamp 0-255
 newR = Math.max(0, Math.min(255, newR));
 newG = Math.max(0, Math.min(255, newG));
 newB = Math.max(0, Math.min(255, newB));
 
 // Recupera saturazione (aumenta distanza dal grigio)
 const gray = 0.299 * newR + 0.587 * newG + 0.114 * newB;
 newR = gray + (newR - gray) * saturationFactor;
 newG = gray + (newG - gray) * saturationFactor;
 newB = gray + (newB - gray) * saturationFactor;
 
 // Clamp finale
 data[i] = Math.max(0, Math.min(255, newR));
 data[i + 1] = Math.max(0, Math.min(255, newG));
 data[i + 2] = Math.max(0, Math.min(255, newB));
 }
 
 ctx.putImageData(imageData, 0, 0);
 
 // 3. Aumenta micro-contrasto per ripristinare dettagli
 if (dehazeStrength > 0.4 && this.isWebGLSupported) {
 this.applyEffect(canvas, (glCanvas, texture) => {
 // Unsharp mask leggero per recuperare dettagli
 glCanvas.unsharpMask(1, dehazeStrength * 0.5);
 });
 }
 
 console.log(` Dehaze applicato: strength ${strength}, saturation boost ${saturationBoost}`);
 return true;
 
 } catch (error) {
 console.error(' Errore Dehaze:', error);
 return false;
 }
 },
 
 /**
 * 🆕 v44.1 - BLOOM SOFT (Bagliore Morbido)
 * Versione delicata del bloom base per effetti sognanti
 * 
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} threshold - Soglia luminosità per bloom (0-100)
 * @param {number} intensity - Intensità bagliore (1-50)
 * @param {number} radius - Raggio diffusione in pixel (2-20)
 * @returns {boolean} true se applicato con successo
 */
 applyBloomSoft(canvas, threshold = 70, intensity = 15, radius = 8) {
 try {
 const ctx = canvas.getContext('2d');
 const w = canvas.width;
 const h = canvas.height;
 
 // 1. Estrai pixel luminosi (sopra threshold)
 const imageData = ctx.getImageData(0, 0, w, h);
 const data = imageData.data;
 const brightData = ctx.createImageData(w, h);
 const bright = brightData.data;
 
 const thresholdValue = (threshold / 100) * 255;
 
 for (let i = 0; i < data.length; i += 4) {
 const r = data[i];
 const g = data[i + 1];
 const b = data[i + 2];
 
 // Calcola luminosità percepita
 const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
 
 if (luminance > thresholdValue) {
 // Mantieni pixel luminoso
 const factor = (luminance - thresholdValue) / (255 - thresholdValue);
 bright[i] = r * factor;
 bright[i + 1] = g * factor;
 bright[i + 2] = b * factor;
 bright[i + 3] = 255;
 } else {
 // Pixel scuro = trasparente
 bright[i + 3] = 0;
 }
 }
 
 // 2. Crea canvas temporaneo per il glow
 const glowCanvas = document.createElement('canvas');
 glowCanvas.width = w;
 glowCanvas.height = h;
 const glowCtx = glowCanvas.getContext('2d');
 glowCtx.putImageData(brightData, 0, 0);
 
 // 3. Applica blur multi-pass per glow morbido
 if (this.isWebGLSupported && radius > 3) {
 // Usa WebGL per blur efficiente su grandi radius
 this.applyEffect(glowCanvas, (glCanvas, texture) => {
 // Triangle blur = più morbido di gaussian per stessi performance
 glCanvas.triangleBlur(radius);
 });
 } else {
 // Fallback: blur CSS (meno preciso ma funzionale)
 glowCtx.filter = `blur(${radius}px)`;
 glowCtx.drawImage(glowCanvas, 0, 0);
 glowCtx.filter = 'none';
 }
 
 // 4. Blend glow con immagine originale
 // Usa additive blending per effetto luminoso
 const normalizedIntensity = intensity / 50; // 1-50 → 0-1
 ctx.globalAlpha = normalizedIntensity * 0.6; // Max 60% opacity per effetto soft
 ctx.globalCompositeOperation = 'screen'; // Screen = additive soft
 ctx.drawImage(glowCanvas, 0, 0);
 
 // Ripristina blending normale
 ctx.globalAlpha = 1.0;
 ctx.globalCompositeOperation = 'source-over';
 
 console.log(` Bloom Soft applicato: threshold ${threshold}, intensity ${intensity}, radius ${radius}px`);
 return true;
 
 } catch (error) {
 console.error(' Errore Bloom Soft:', error);
 return false;
 }
 },
 
 /**
 * TILT-SHIFT - Effetto miniatura con focus centrale
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} blurAmount - Intensità della sfocatura (1-30)
 * @param {number} focusSize - Dimensione area a fuoco in percentuale (10-80)
 */
 applyTiltShift(canvas, blurAmount = 10, focusSize = 40) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Tilt-shift usa il metodo WebGL nativo
 const centerX = 0.5;
 const centerY = 0.5;
 const focusHeight = focusSize / 100;
 const blurRadius = blurAmount / 10;
 
 // Usa il metodo tiltShift di glfx.js WebGL
 glCanvas.tiltShift(
 blurRadius,
 focusHeight,
 centerX - focusHeight / 2,
 centerY - focusHeight / 2,
 centerX + focusHeight / 2,
 centerY + focusHeight / 2
 );
 });
 },
 
 /**
 * GAUSSIAN BLUR PRO - Sfocatura gaussiana di alta qualità
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} radius - Raggio della sfocatura (1-100)
 * @param {string} quality - Qualità: 'fast', 'balanced', 'high'
 */
 applyGaussianBlur(canvas, radius = 20, quality = 'balanced') {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Gaussian blur con algoritmo multi-pass
 let passes = 1;
 if (quality === 'balanced') passes = 2;
 if (quality === 'high') passes = 3;
 
 // Usa triangleBlur di WebGL (simula gaussian con convoluzione)
 for (let i = 0; i < passes; i++) {
 glCanvas.triangleBlur(radius / passes);
 }
 });
 },
 
 /**
 * MOTION BLUR - Sfocatura direzionale per simulare movimento
 * @param {HTMLCanvasElement} canvas - Canvas da processare
 * @param {number} distance - Distanza del blur (1-50 px)
 * @param {number} angle - Direzione in gradi (0-360)
 */
 applyMotionBlur(canvas, distance = 15, angle = 0) {
 return this.applyEffect(canvas, (glCanvas, texture) => {
 // Converti angolo in radianti
 const radians = (angle * Math.PI) / 180;
 
 // Calcola componenti X e Y del vettore di movimento
 const deltaX = Math.cos(radians) * (distance / 2);
 const deltaY = Math.sin(radians) * (distance / 2);
 
 // Simula motion blur con triangleBlur ripetuto
 for (let i = 0; i < 3; i++) {
 glCanvas.triangleBlur(Math.floor(distance / 3));
 }
 });
 }
 };
 
 // Esponi GpuEffects globalmente per accesso da altri script
 window.GpuEffects = GpuEffects;
 
 // Render throttling per performance - CORRETTO
 function scheduleRender() {
 if (state.renderPending) return;
 state.renderPending = true;
 
 const now = performance.now();
 const timeSinceLastRender = now - state.lastRenderTime;
 const minFrameTime = 16; // ~60fps
 
 if (timeSinceLastRender >= minFrameTime) {
 safeExecute(() => {
 render();
 applyGlobalGPUEffects();
 state.lastRenderTime = performance.now();
 state.renderPending = false;
 }, 'Errore durante il rendering');
 } else {
 // CORRETTO: usa state.renderTimeout invece di variabile globale
 if (state.renderTimeout !== null) {
 clearTimeout(state.renderTimeout);
 }
 state.renderTimeout = setTimeout(() => {
 safeExecute(() => {
 render();
 applyGlobalGPUEffects();
 state.lastRenderTime = performance.now();
 state.renderPending = false;
 state.renderTimeout = null;
 }, 'Errore durante il rendering');
 }, minFrameTime - timeSinceLastRender);
 }
 }
 
 // Funzione di render sincrono per export/fullscreen
 // Assicura che il render sia completato prima di catturare l'immagine
 function renderSync() {
 try {
 // Cancella eventuali render asincroni in sospeso
 if (state.renderTimeout !== null) {
 clearTimeout(state.renderTimeout);
 state.renderTimeout = null;
 }
 
 render();
 applyGlobalGPUEffects();
 state.lastRenderTime = performance.now();
 state.renderPending = false;
 } catch (error) {
 console.error('Errore durante render sincrono:', error);
 state.renderPending = false; // Reset anche in caso di errore
 }
 }
 

 // ═══════════════════════════════════════════════════════════════
 // EFFETTI GPU GLOBALI - Funzioni di Applicazione
 // ═══════════════════════════════════════════════════════════════
 
 /**
 * Applica gli effetti GPU globali al canvas dopo il rendering dei layer
 * Questa funzione viene chiamata da scheduleRender() dopo render()
 */

 /**
 * Calcola la safe zone universale in pixel basata sulle percentuali
 * Questa safe zone funziona per TUTTI i social contemporaneamente
 * @returns {Object} {top, bottom, left, right} in pixel
 */
 function getUniversalSafeZonePixels() {
 const canvas = document.getElementById('canvas');
 if (!canvas) return {top: 0, bottom: 0, left: 0, right: 0};
 
 const safeZone = state.universalSafeZone;
 
 return {
 top: Math.round(canvas.height * safeZone.top / 100),
 bottom: Math.round(canvas.height * safeZone.bottom / 100),
 left: Math.round(canvas.width * safeZone.left / 100),
 right: Math.round(canvas.width * safeZone.right / 100)
 };
 }

 window.applyGlobalGPUEffects = function() {
 const effects = state.globalEffects.gpuEffects;
 const canvas = document.getElementById('canvas');
 if (!canvas) return;
 
 const ctx = canvas.getContext('2d');
 
 // Se tutti gli effetti sono a 0, skip
 const hasActiveEffects = Object.values(effects).some(v => v !== 0);
 if (!hasActiveEffects) return;
 
 // DEBUG TEMPORANEO - Verifica che la funzione venga chiamata
 console.log('applyGlobalGPUEffects called', {
 hasActiveEffects,
 effects: {...effects}
 });
 
 try {
 // Ottieni i dati dell'immagine
 const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
 const data = imageData.data;
 
 // Applica effetti pixel per pixel
 for (let i = 0; i < data.length; i += 4) {
 let r = data[i];
 let g = data[i + 1];
 let b = data[i + 2];
 
 // Brightness
 if (effects.brightness !== 0) {
 const bright = effects.brightness * 255;
 r = Math.max(0, Math.min(255, r + bright));
 g = Math.max(0, Math.min(255, g + bright));
 b = Math.max(0, Math.min(255, b + bright));
 }
 
 // Contrast
 if (effects.contrast !== 0) {
 const contrast = 1 + effects.contrast;
 r = Math.max(0, Math.min(255, ((r - 128) * contrast) + 128));
 g = Math.max(0, Math.min(255, ((g - 128) * contrast) + 128));
 b = Math.max(0, Math.min(255, ((b - 128) * contrast) + 128));
 }
 
 // Saturation
 if (effects.saturation !== 0) {
 const gray = 0.2989 * r + 0.5870 * g + 0.1140 * b;
 const sat = 1 + effects.saturation;
 r = Math.max(0, Math.min(255, gray + (r - gray) * sat));
 g = Math.max(0, Math.min(255, gray + (g - gray) * sat));
 b = Math.max(0, Math.min(255, gray + (b - gray) * sat));
 }
 
 // Hue rotation
 if (effects.hue !== 0) {
 const hueShift = effects.hue * 360;
 const [h, s, l] = rgbToHslGlobal(r, g, b);
 const newH = (h + hueShift) % 360;
 const [nr, ng, nb] = hslToRgbGlobal(newH, s, l);
 r = nr;
 g = ng;
 b = nb;
 }
 
 // Vibrance
 if (effects.vibrance !== 0) {
 const avg = (r + g + b) / 3;
 const mx = Math.max(r, g, b);
 const diff = mx - avg;
 const amount = (255 - mx) * effects.vibrance * 0.5;
 
 if (diff < 128) {
 r = Math.max(0, Math.min(255, r + (r - avg) * amount / 255));
 g = Math.max(0, Math.min(255, g + (g - avg) * amount / 255));
 b = Math.max(0, Math.min(255, b + (b - avg) * amount / 255));
 }
 }
 
 // Scrivi i nuovi valori
 data[i] = r;
 data[i + 1] = g;
 data[i + 2] = b;
 }
 
 // Ridisegna sul canvas
 ctx.putImageData(imageData, 0, 0);
 
 } catch (err) {
 console.error(' Errore applicazione effetti GPU globali:', err);
 }
 }
 
 /**
 * Conversione RGB → HSL per effetti globali
 */
 function rgbToHslGlobal(r, g, b) {
 r /= 255;
 g /= 255;
 b /= 255;
 
 const max = Math.max(r, g, b);
 const min = Math.min(r, g, b);
 let h, s, l = (max + min) / 2;
 
 if (max === min) {
 h = s = 0;
 } else {
 const d = max - min;
 s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
 
 switch (max) {
 case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
 case g: h = ((b - r) / d + 2) / 6; break;
 case b: h = ((r - g) / d + 4) / 6; break;
 }
 }
 
 return [h * 360, s, l];
 }
 
 /**
 * Conversione HSL → RGB per effetti globali
 */
 function hslToRgbGlobal(h, s, l) {
 h /= 360;
 
 let r, g, b;
 
 if (s === 0) {
 r = g = b = l;
 } else {
 const hue2rgb = (p, q, t) => {
 if (t < 0) t += 1;
 if (t > 1) t -= 1;
 if (t < 1/6) return p + (q - p) * 6 * t;
 if (t < 1/2) return q;
 if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
 return p;
 };
 
 const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
 const p = 2 * l - q;
 
 r = hue2rgb(p, q, h + 1/3);
 g = hue2rgb(p, q, h);
 b = hue2rgb(p, q, h - 1/3);
 }
 
 return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
 }

 // ---- Funzioni Utility (Colori, Geometria) ----
 
 /**
 * v39.0: Generate ID collision-safe
 * Verifica che l'ID non sia già in uso prima di restituirlo
 */
 function generateId() {
 let id = state.nextId++;
 
 // Verifica collisione (molto raro, ma possibile dopo import/load)
 while (state.usedIds.has(id)) {
 console.warn(`️ ID collision detected: ${id}, incrementing...`);
 id = state.nextId++;
 }
 
 state.usedIds.add(id);
 return id;
 }
 
 /**
 * v39.0: Libera ID quando layer viene eliminato
 */
 function releaseId(id) {
 if (typeof id === 'number') {
 state.usedIds.delete(id);
 }
 }
 
 /**
 * v39.0: Ricostruisce usedIds Set dopo load/import
 */
 function rebuildUsedIds() {
 state.usedIds.clear();
 let maxId = 0;
 
 state.layers.forEach(layer => {
 if (typeof layer.id === 'number') {
 state.usedIds.add(layer.id);
 maxId = Math.max(maxId, layer.id);
 }
 });
 
 // Aggiorna nextId al prossimo valore sicuro
 state.nextId = maxId + 1;
 console.log(` UsedIds rebuilt: ${state.usedIds.size} IDs, nextId: ${state.nextId}`);
 }
 
 function snapToGrid(value) { return state.showGrid ? Math.round(value / state.gridSize) * state.gridSize : value; }
 function rgbToHsl(r, g, b){ r /= 255, g /= 255, b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2; if(max == min){ h = s = 0; } else { let d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch(max){ case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return [h * 360, s * 100, l * 100]; }
 function getLuminance(r, g, b) { const a = [r, g, b].map(v => { v /= 255; return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4); }); return a[0] * 0.2126 + a[1] * 0.7152 + a[2] * 0.0722; }
 function getContrastRatio(rgb1, rgb2) { const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b); const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b); return (Math.max(lum1, lum2) + 0.05) / (Math.min(lum1, lum2) + 0.05); }
 
 function applyLevels() {
 if (!originalImage) {
 showStatus('Carica prima un\'immagine', 'error');
 return;
 }

 const inputBlack = parseInt(document.getElementById('levels-input-black').value);
 const inputWhite = parseInt(document.getElementById('levels-input-white').value);
 const gamma = parseFloat(document.getElementById('levels-gamma').value);
 const outputBlack = parseInt(document.getElementById('levels-output-black').value);
 const outputWhite = parseInt(document.getElementById('levels-output-white').value);

 if (inputBlack >= inputWhite) {
 showStatus('Input Black deve essere minore di Input White', 'error');
 return;
 }

 if (outputBlack >= outputWhite) {
 showStatus('Output Black deve essere minore di Output White', 'error');
 return;
 }

 let imageData = cloneImageData(currentImageData || originalImage);
 const data = imageData.data;

 for (let i = 0; i < data.length; i += 4) {
 for (let c = 0; c < 3; c++) {
 let value = data[i + c];
 value = (value - inputBlack) * (255 / (inputWhite - inputBlack));
 value = Math.max(0, Math.min(255, value));
 value = Math.pow(value / 255, 1 / gamma) * 255;
 value = outputBlack + (value / 255) * (outputWhite - outputBlack);
 value = Math.max(0, Math.min(255, value));
 data[i + c] = value;
 }
 }

 ctx.putImageData(imageData, 0, 0);
 currentImageData = imageData;
 saveToHistory();
 showStatus(' Levels applicati', 'success');
 }

 function resetLevels() {
 document.getElementById('levels-input-black').value = 0;
 document.getElementById('levels-input-white').value = 255;
 document.getElementById('levels-gamma').value = 1.0;
 document.getElementById('levels-output-black').value = 0;
 document.getElementById('levels-output-white').value = 255;
 document.getElementById('levels-input-black-value').textContent = '0';
 document.getElementById('levels-input-white-value').textContent = '255';
 document.getElementById('levels-gamma-value').textContent = '1.00';
 document.getElementById('levels-output-black-value').textContent = '0';
 document.getElementById('levels-output-white-value').textContent = '255';
 showStatus('↺ Levels resettati', 'info');
 }

 
 function hexToRgb(hex) {
 let r = 0, g = 0, b = 0;
 if (hex.length == 4) { r = "0x" + hex[1] + hex[1]; g = "0x" + hex[2] + hex[2]; b = "0x" + hex[3] + hex[3]; }
 else if (hex.length == 7) { r = "0x" + hex[1] + hex[2]; g = "0x" + hex[3] + hex[4]; b = "0x" + hex[5] + hex[6]; }
 return { r: +r, g: +g, b: +b };
 }
 function getLayerBbox(layer) {
 // Semplificato da v3.29 - considera la rotazione
 const w = layer.width || layer.w || 0;
 const h = layer.height || layer.h || 0;
 return {
 left: layer.x, top: layer.y,
 right: layer.x + w, bottom: layer.y + h,
 centerX: layer.x + w / 2, centerY: layer.y + h / 2,
 width: w, height: h,
 };
 }

 // ---- PULIZIA E VALIDAZIONE STATO ----
 
 // Funzione per pulire layer corrotti e validare stato
 function cleanupAndValidateState() {
 let cleanupCount = 0;
 
 try {
 // 1. Rimuovi layer con dati mancanti o corrotti
 const validLayers = state.layers.filter((layer, index) => {
 // Validazione base
 if (!layer || typeof layer !== 'object') {
 console.warn('Layer corrotto rimosso:', index);
 cleanupCount++;
 return false;
 }
 
 // Validazione tipo
 if (!layer.type || !['text', 'shape', 'image', 'polygon'].includes(layer.type)) {
 console.warn('Layer con tipo non valido rimosso:', layer);
 cleanupCount++;
 return false;
 }
 
 // Validazione coordinate
 if (typeof layer.x !== 'number' || typeof layer.y !== 'number' || 
 isNaN(layer.x) || isNaN(layer.y)) {
 console.warn('Layer con coordinate non valide rimosso:', layer.name);
 cleanupCount++;
 return false;
 }
 
 // Validazione immagini
 if (layer.type === 'image' && !layer.imageElement && !layer.imageData) {
 console.warn('Layer immagine senza dati rimosso:', layer.name);
 cleanupCount++;
 return false;
 }
 
 // Validazione poligoni
 if (layer.type === 'polygon' && (!layer.polygonPoints || layer.polygonPoints.length < 2)) {
 console.warn('Layer poligono con punti insufficienti rimosso:', layer.name);
 cleanupCount++;
 return false;
 }
 
 return true;
 });
 
 state.layers = validLayers;
 
 // Valida e aggiusta currentLayerIndex dopo la rimozione di layer corrotti
 if (state.currentLayerIndex >= state.layers.length) {
 state.currentLayerIndex = Math.max(0, state.layers.length - 1);
 }
 
 // 2. Pulisci selectedIds orfani
 const validSelectedIds = state.selectedIds.filter(id => 
 state.layers.find(l => l.id === id)
 );
 
 if (validSelectedIds.length !== state.selectedIds.length) {
 console.warn('Rimossi ID orfani da selectedIds:', 
 state.selectedIds.length - validSelectedIds.length);
 cleanupCount += state.selectedIds.length - validSelectedIds.length;
 state.selectedIds = validSelectedIds;
 }
 
 // 3. Assicura ID unici
 const seenIds = new Set();
 const duplicateIds = [];
 state.layers.forEach(layer => {
 if (seenIds.has(layer.id)) {
 duplicateIds.push(layer.id);
 layer.id = generateId(); // Rigenera ID duplicato
 }
 seenIds.add(layer.id);
 });
 
 if (duplicateIds.length > 0) {
 console.warn('Rigenerati ID duplicati:', duplicateIds.length);
 cleanupCount += duplicateIds.length;
 }
 
 // 4. Pulisci memory leak da history
 if (state.history && state.history.length > 50) {
 state.history = state.history.slice(-50);
 state.historyIndex = Math.min(state.historyIndex, state.history.length - 1);
 console.info('History trimmed per gestione memoria');
 }
 
 if (cleanupCount > 0) {
 console.info(`Cleanup completato: ${cleanupCount} problemi risolti`);
 scheduleRender();
 updateUI();
 }
 
 return cleanupCount;
 
 } catch (e) {
 logError('cleanupAndValidateState', e, 'Errore durante cleanup stato');
 return 0;
 }
 }
 
 // Esegui cleanup periodico ogni 2 minuti
 setInterval(() => {
 const cleanedCount = cleanupAndValidateState();
 if (cleanedCount > 0) {
 announceGemini(`Pulizia automatica: ${cleanedCount} problemi risolti`, 'polite');
 }
 }, 120000); // 2 minuti
 
 // ---- Gestione Livelli (Aggiungi, Seleziona, Muovi) ----
 // Variabili anti-duplicati (fuori dalla funzione per persistenza)
 let lastAddTime = 0;
 let lastAddKey = '';
 
 function addLayer(layer) {
 // FILTRO ANTI-DUPLICATI LEGGERO
 const now = Date.now();
 const key = (layer.type || '') + '_' + (layer.shape || layer.text || '').substring(0, 10);
 if (now - lastAddTime < 150 && key === lastAddKey) {
 console.warn('⚠️ Duplicato bloccato');
 return;
 }
 lastAddTime = now;
 lastAddKey = key;
 
 console.log(' [DEBUG] addLayer chiamata con:', layer.type, layer.shape || layer.text);
 
 // VALIDAZIONE INPUT ROBUSTA
 if (!layer || typeof layer !== 'object') {
 logError('addLayer', new Error('Layer non valido'), 'Layer deve essere un oggetto');
 return;
 }
 
 // Validazione campi obbligatori
 if (!layer.type || !['text', 'shape', 'image', 'polygon'].includes(layer.type)) {
 logError('addLayer', new Error('Tipo layer non valido: ' + layer.type), 'Tipo layer non supportato');
 return;
 }
 
 // Validazione coordinate
 if (typeof layer.x !== 'number' || typeof layer.y !== 'number' || 
 isNaN(layer.x) || isNaN(layer.y)) {
 logError('addLayer', new Error('Coordinate non valide'), 'X e Y devono essere numeri validi');
 layer.x = layer.x || 0;
 layer.y = layer.y || 0;
 }
 
 // Limita coordinate al canvas (sicurezza)
 const maxX = canvas.width * 2; // Permetti posizioni oltre canvas ma con limite
 const maxY = canvas.height * 2;
 layer.x = Math.max(-canvas.width, Math.min(maxX, layer.x));
 layer.y = Math.max(-canvas.height, Math.min(maxY, layer.y));
 
 // Genera ID unico
 layer.id = generateId();
 
 // Assicura valori di default
 layer.name = layer.name || `Layer ${state.layers.length + 1}`;
 layer.visible = layer.visible !== false; // Default true
 layer.locked = layer.locked || false;
 layer.opacity = (layer.opacity !== undefined) ? Math.max(0, Math.min(100, layer.opacity)) : 100;
 layer.rotation = layer.rotation || 0;
 
 if (layer.type === 'text') { 
 // Validazione testo
 layer.text = layer.text || '';
 layer.fontSize = layer.fontSize || 24;
 layer.fontFamily = layer.fontFamily || 'Arial';
 layer.color = layer.color || '#000000';
 
 // Calcola dimensioni testo in modo sicuro
 try {
 ctx.font = (layer.fontWeight || '400') + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
 const metrics = ctx.measureText(layer.text);
 layer.width = metrics.width || 100; // Fallback se measurement fallisce
 layer.height = layer.fontSize * (layer.lineHeight || 1.2);
 } catch (e) {
 logError('addLayer', e, 'Errore calcolo dimensioni testo');
 layer.width = 100;
 layer.height = layer.fontSize * 1.2;
 }
 }
 
 if (layer.type === 'image') { 
 // Validazione immagine
 if (!layer.imageElement) {
 logError('addLayer', new Error('imageElement mancante'), 'Layer immagine senza elemento');
 return;
 }
 
 // Salva src per ricaricare
 layer.imageData = layer.imageElement?.src;
 
 // Validazione dimensioni
 if (!layer.width || !layer.height || layer.width <= 0 || layer.height <= 0) {
 logError('addLayer', new Error('Dimensioni immagine non valide'), 'Width/Height devono essere > 0');
 layer.width = layer.imageElement.width || 100;
 layer.height = layer.imageElement.height || 100;
 }
 }
 
 if (layer.type === 'shape' || layer.type === 'polygon') {
 // Validazione forme
 layer.color = layer.color || '#000000';
 
 if (!layer.width || !layer.height || layer.width <= 0 || layer.height <= 0) {
 logError('addLayer', new Error('Dimensioni forma non valide'), 'Width/Height devono essere > 0');
 layer.width = layer.width || 100;
 layer.height = layer.height || 100;
 }
 
 // Validazione punti poligono
 if (layer.type === 'polygon') {
 if (!Array.isArray(layer.polygonPoints) || layer.polygonPoints.length < 2) {
 logError('addLayer', new Error('Punti poligono non validi'), 'polygonPoints deve avere almeno 2 punti');
 return;
 }
 }
 }
 
 // Aggiungi al layer array
 state.layers.push(layer);
 state.selectedIds = [layer.id];
 // Aggiorna anche currentLayerIndex per allineare selezione e target effetti
 state.currentLayerIndex = state.layers.length - 1;
 
 // Salva stato
 try {
 saveState('Livello ' + layer.name + ' aggiunto');
 } catch (e) {
 logError('addLayer', e, 'Errore salvataggio stato dopo addLayer');
 }
 
 scheduleRender();
 updateUI();
 announce('Livello ' + layer.name + ' aggiunto');
 }
 
 function getSelectedLayer() {
 if (state.selectedIds.length !== 1) return null;
 const layer = state.layers.find(l => l.id === state.selectedIds[0]);
 // Validazione che il layer esista ancora
 if (!layer) {
 // Rimuovi ID orfano
 state.selectedIds = state.selectedIds.filter(id => state.layers.find(l => l.id === id));
 return null;
 }
 return layer;
 }
 
 // NUOVA: Funzione sicura per selezione multipla
 function getSelectedLayers() {
 // Filtra e pulisci ID orfani
 const validIds = state.selectedIds.filter(id => state.layers.find(l => l.id === id));
 
 // Se ci sono ID orfani, aggiorna selectedIds
 if (validIds.length !== state.selectedIds.length) {
 state.selectedIds = validIds;
 }
 
 return state.layers.filter(l => state.selectedIds.includes(l.id));
 }
 
 // NUOVA: Selezione multipla sicura (Ctrl+Click)
 function toggleLayerSelection(layerId, multiselect = false) {
 if (!layerId) return;
 
 // Verifica che il layer esista
 const layer = state.layers.find(l => l.id === layerId);
 if (!layer) {
 logError('toggleLayerSelection', new Error('Layer non trovato'), 'Layer ID non valido');
 return;
 }
 
 // Non permettere selezione di layer bloccati
 if (layer.locked && !state.selectedIds.includes(layerId)) {
 announceGemini(`Il livello ${layer.name} è bloccato`, 'polite');
 return;
 }
 
 if (multiselect) {
 // Toggle nella selezione esistente
 if (state.selectedIds.includes(layerId)) {
 state.selectedIds = state.selectedIds.filter(id => id !== layerId);
 // RIMOSSO (ridondante): announceGemini(`Deselezionato: ${layer.name}. ${state.selectedIds.length} elementi selezionati`, 'polite');
 } else {
 // LIMITE SELEZIONE MULTIPLA per performance
 const MAX_SELECTED = 50;
 if (state.selectedIds.length >= MAX_SELECTED) {
 announceGemini(`Limite massimo di ${MAX_SELECTED} elementi selezionati raggiunto`, 'assertive');
 return;
 }
 state.selectedIds.push(layerId);
 // RIMOSSO (ridondante): announceGemini(`Selezionato: ${layer.name}. ${state.selectedIds.length} elementi selezionati`, 'polite');
 }
 } else {
 // Selezione singola
 state.selectedIds = [layerId];
 // Aggiorna anche currentLayerIndex per allineare selezione e target effetti
 const index = state.layers.findIndex(l => l.id === layerId);
 if (index !== -1) {
 state.currentLayerIndex = index;
 }
 announceGemini(`Selezionato: ${layer.name}`, 'polite');
 }
 
 scheduleRender();
 updateUI();
 }
 
 function deleteLayer() {
 if (state.selectedIds.length === 0) {
 announceGemini('Seleziona un livello da eliminare', 'polite');
 return;
 }
 
 // Ottieni nomi layer per annuncio
 const layerNames = state.selectedIds
 .map(id => state.layers.find(l => l.id === id)?.name)
 .filter(Boolean);
 
 const count = layerNames.length;
 
 // PULIZIA MEMORIA: libera risorse prima di eliminare
 state.selectedIds.forEach(id => {
 const layer = state.layers.find(l => l.id === id);
 if (layer) {
 // Libera imageElement se presente
 if (layer.type === 'image' && layer.imageElement) {
 layer.imageElement.onload = null;
 layer.imageElement.onerror = null;
 layer.imageElement.src = ''; // Trigger garbage collection
 layer.imageElement = null;
 }
 
 // Libera altri dati pesanti
 if (layer.imageData && layer.imageData.length > 100000) {
 layer.imageData = null; // Libera base64 grandi
 }
 }
 });
 
 // Filtra layers
 state.layers = state.layers.filter(l => !state.selectedIds.includes(l.id));
 state.selectedIds = [];
 
 // Aggiorna currentLayerIndex per evitare index fuori range
 if (state.currentLayerIndex >= state.layers.length) {
 state.currentLayerIndex = Math.max(0, state.layers.length - 1);
 }
 
 // Salva stato
 try {
 saveState(count > 1 ? `${count} livelli eliminati` : 'Livello eliminato');
 } catch (e) {
 logError('deleteLayer', e, 'Errore salvataggio stato');
 }
 
 scheduleRender();
 updateUI();
 
 if (count === 1) {
 // RIMOSSO (ridondante): announce(`Livello ${layerNames[0]} eliminato`);
 } else {
 announce(`${count} livelli eliminati`);
 }
 }
 
 function duplicateLayer() {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da duplicare', 'polite');
 return;
 }
 
 // Validazione: non duplicare layer troppo grandi (memory protection)
 const estimatedSize = (layer.width || 100) * (layer.height || 100);
 const MAX_DUPLICATE_SIZE = 10000000; // 10M pixel
 if (estimatedSize > MAX_DUPLICATE_SIZE) {
 announceGemini('Layer troppo grande per la duplicazione. Riduci le dimensioni prima.', 'assertive');
 return;
 }
 
 try {
 // Deep clone sicuro (esclude funzioni e elementi DOM)
 const clone = JSON.parse(JSON.stringify(layer, (key, value) => {
 if (key === 'imageElement' || typeof value === 'function') return undefined;
 return value;
 }));
 
 // Offset posizione
 clone.x += 20;
 clone.y += 20;
 clone.name += ' copia';
 
 // Se è immagine, dobbiamo ricaricare l'elemento
 if (clone.type === 'image' && clone.imageData) {
 const img = new Image();
 
 // TIMEOUT per evitare memory leak se l'immagine non carica
 const timeoutId = setTimeout(() => {
 img.onload = null;
 img.onerror = null;
 img.src = ''; // Cancella caricamento
 announceGemini('Timeout duplicazione immagine', 'assertive');
 logError('duplicateLayer', new Error('Timeout caricamento immagine'), 'Immagine non caricata in tempo');
 }, 10000); // 10 secondi timeout
 
 img.onload = () => {
 clearTimeout(timeoutId);
 clone.imageElement = img;
 try {
 addLayer(clone);
 announceGemini('Livello immagine duplicato', 'assertive');
 } catch (e) {
 logError('duplicateLayer', e, 'Errore aggiunta clone immagine');
 // Cleanup
 img.onload = null;
 img.onerror = null;
 img.src = '';
 }
 };
 
 img.onerror = () => {
 clearTimeout(timeoutId);
 img.onload = null;
 img.onerror = null;
 announceGemini('Errore duplicazione immagine', 'assertive');
 logError('duplicateLayer', new Error('Errore caricamento immagine'), 'Impossibile caricare imageData');
 };
 
 img.src = clone.imageData;
 } else {
 // Per testo, forme e poligoni
 addLayer(clone);
 // RIMOSSO (ridondante): announceGemini('Livello duplicato', 'assertive');
 }
 } catch (e) {
 logError('duplicateLayer', e, 'Errore durante duplicazione');
 announceGemini('Errore durante la duplicazione', 'assertive');
 }
 }
 
 function moveLayer(direction) {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da spostare', 'polite');
 return;
 }
 
 const index = state.layers.indexOf(layer);
 if (index === -1) {
 logError('moveLayer', new Error('Layer non trovato in array'), 'Inconsistenza stato layer');
 state.selectedIds = []; // Reset selezione corrotta
 updateUI();
 return;
 }
 
 // Validazione boundaries
 if (direction === 'up') {
 if (index >= state.layers.length - 1) {
 announceGemini('Il livello è già in cima', 'polite');
 return;
 }
 // Swap sicuro
 const temp = state.layers[index];
 state.layers[index] = state.layers[index + 1];
 state.layers[index + 1] = temp;
 
 // Aggiorna currentLayerIndex se punta al layer spostato
 if (state.currentLayerIndex === index) {
 state.currentLayerIndex = index + 1;
 } else if (state.currentLayerIndex === index + 1) {
 state.currentLayerIndex = index;
 }
 
 saveState('Livello spostato su');
 scheduleRender();
 updateLayerList(); // Solo la lista
 // RIMOSSO (ridondante): announceGemini('Livello spostato su', 'polite');
 
 } else if (direction === 'down') {
 if (index <= 0) {
 announceGemini('Il livello è già in fondo', 'polite');
 return;
 }
 // Swap sicuro
 const temp = state.layers[index];
 state.layers[index] = state.layers[index - 1];
 state.layers[index - 1] = temp;
 
 // Aggiorna currentLayerIndex se punta al layer spostato
 if (state.currentLayerIndex === index) {
 state.currentLayerIndex = index - 1;
 } else if (state.currentLayerIndex === index - 1) {
 state.currentLayerIndex = index;
 }
 
 saveState('Livello spostato giù');
 scheduleRender();
 updateLayerList(); // Solo la lista
 announceGemini('Livello spostato giù', 'polite');
 }
 }
 
 function toggleLock() {
 const layer = getSelectedLayer();
 if (!layer) return;
 
 layer.locked = !layer.locked;
 scheduleRender();
 updateLayerList(); // Solo la lista
 announce(layer.locked ? 'Livello bloccato' : 'Livello sbloccato');
 }
 
 // ---- Cronologia (Undo/Redo) ----
 function saveState(description) {
 // Pulisci cronologia futura
 state.history = state.history.slice(0, state.historyIndex + 1);
 
 // Crea snapshot (escludendo elementi DOM)
 const snapshot = {
 layers: JSON.parse(JSON.stringify(state.layers, (key, value) => 
 (key === 'imageElement') ? undefined : value
 )),
 backgroundColor: state.backgroundColor,
 tpl: JSON.parse(JSON.stringify(state.tpl)),
 description
 };

 state.history.push(snapshot);
 state.historyIndex++;
 
 // Limite cronologia (gestione memoria)
 const MAX_HISTORY = 50;
 if (state.history.length > MAX_HISTORY) {
 state.history.shift();
 state.historyIndex--;
 }
 
 // Pulizia memoria se necessario
 if (state.history.length > 30) {
 cleanupOldHistory();
 }
 
 updateUndoRedoButtons();
 }
 
 // Cleanup memoria per history molto vecchia
 function cleanupOldHistory() {
 // Mantieni solo gli ultimi 30 snapshot completi
 // I primi 20 vengono "compressi" mantenendo solo metadati essenziali
 if (state.history.length > 30) {
 const toCompress = state.history.slice(0, state.history.length - 30);
 const compressed = toCompress.map(snap => ({
 description: snap.description,
 compressed: true
 }));
 state.history = [...compressed, ...state.history.slice(-30)];
 }
 }
 
 async function loadSnapshot(snapshot) {
 if (!snapshot) {
 logError('loadSnapshot', new Error('Snapshot nullo'), 'Snapshot non valido');
 announceGemini('Errore caricamento stato', 'assertive');
 return;
 }
 
 // Validazione snapshot
 if (!snapshot.layers || !Array.isArray(snapshot.layers)) {
 logError('loadSnapshot', new Error('Layers non valido in snapshot'), 'Snapshot corrotto');
 announceGemini('Errore: stato corrotto', 'assertive');
 return;
 }
 
 try {
 // PULIZIA MEMORIA: libera immagini vecchie prima di caricare nuove
 state.layers.forEach(layer => {
 if (layer.type === 'image' && layer.imageElement) {
 layer.imageElement.onload = null;
 layer.imageElement.onerror = null;
 layer.imageElement.src = '';
 layer.imageElement = null;
 }
 });
 
 // Carica stato base
 state.backgroundColor = snapshot.backgroundColor || '#ffffff';
 state.tpl = JSON.parse(JSON.stringify(snapshot.tpl || { w: 1080, h: 1080 }));
 
 // Validazione dimensioni canvas
 const maxDimension = 10000;
 state.tpl.w = Math.max(1, Math.min(maxDimension, state.tpl.w));
 state.tpl.h = Math.max(1, Math.min(maxDimension, state.tpl.h));
 
 canvas.width = state.tpl.w;
 canvas.height = state.tpl.h;

 // Ricarica i layer con deep clone sicuro
 const newLayers = JSON.parse(JSON.stringify(snapshot.layers, (key, value) => {
 if (typeof value === 'function') return undefined;
 return value;
 }));
 
 // Ricarica le immagini con timeout e error handling
 const imagePromises = newLayers.map((layer, index) => {
 if (layer.type === 'image' && layer.imageData) {
 return new Promise((resolve) => {
 const img = new Image();
 
 // Timeout per evitare hanging
 const timeoutId = setTimeout(() => {
 img.onload = null;
 img.onerror = null;
 img.src = '';
 logError('loadSnapshot', new Error(`Timeout immagine layer ${index}`), 'Immagine non caricata');
 resolve(); // Risolvi comunque
 }, 8000); // 8 secondi timeout
 
 img.onload = () => {
 clearTimeout(timeoutId);
 layer.imageElement = img;
 resolve();
 };
 
 img.onerror = (e) => {
 clearTimeout(timeoutId);
 console.error(`Impossibile ricaricare immagine per layer ${index}:`, e);
 logError('loadSnapshot', new Error(`Errore caricamento immagine layer ${index}`), 'Immagine non trovata o corrotta');
 // Non assegnare imageElement - il layer sarà skippato nel render
 resolve(); // Risolvi comunque per non bloccare
 };
 
 // Validazione URL prima di caricare
 if (typeof layer.imageData === 'string' && layer.imageData.length > 0) {
 img.src = layer.imageData;
 } else {
 clearTimeout(timeoutId);
 resolve();
 }
 });
 }
 return Promise.resolve();
 });

 // Aspetta tutte le immagini (con timeout individuale già gestito)
 await Promise.all(imagePromises);
 
 // Assegna layers validati
 state.layers = newLayers.filter(layer => {
 // Filtra layer immagine senza imageElement (non caricati)
 if (layer.type === 'image' && !layer.imageElement) {
 console.warn('Layer immagine ignorato (non caricato):', layer.name);
 return false;
 }
 return true;
 });

 // Valida e aggiusta currentLayerIndex
 if (state.currentLayerIndex >= state.layers.length) {
 state.currentLayerIndex = Math.max(0, state.layers.length - 1);
 }

 // Mantieni la selezione attuale se valida
 const currentSelectedIds = [...state.selectedIds];
 state.selectedIds = [];
 currentSelectedIds.forEach(id => {
 if (state.layers.find(l => l.id === id)) {
 state.selectedIds.push(id);
 }
 });
 
 scheduleRender();
 updateUI();
 
 } catch (e) {
 logError('loadSnapshot', e, 'Errore critico durante loadSnapshot');
 announceGemini('Errore caricamento stato', 'assertive');
 
 // Ripristino sicuro: canvas vuoto piuttosto che stato corrotto
 state.layers = [];
 state.selectedIds = [];
 state.currentLayerIndex = 0;
 scheduleRender();
 updateUI();
 }
 }

 async function undo() {
 if (state.historyIndex > 0) {
 state.historyIndex--;
 await loadSnapshot(state.history[state.historyIndex]);
 updateUndoRedoButtons();
 // Annuncio breve senza numero di azioni
 // RIMOSSO (ridondante): announceGemini(`Annullato`, 'assertive');
 } else {
 announceGemini('Nessuna azione da annullare', 'polite');
 }
 }
 
 async function redo() {
 if (state.historyIndex < state.history.length - 1) {
 state.historyIndex++;
 await loadSnapshot(state.history[state.historyIndex]);
 updateUndoRedoButtons();
 // Annuncio breve senza numero di azioni
 // RIMOSSO (ridondante): announceGemini(`Ripetuto`, 'assertive');
 } else {
 announceGemini('Nessuna azione da ripetere', 'polite');
 }
 }
 
 function updateUndoRedoButtons() {
 document.getElementById('btn-undo').disabled = state.historyIndex === 0;
 document.getElementById('btn-redo').disabled = state.historyIndex >= state.history.length - 1;
 }
 
 // ---- Clipboard ----
 function copyLayer() {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da copiare', 'polite');
 return;
 }
 state.clipboard = JSON.parse(JSON.stringify(layer, (key, value) => 
 (key === 'imageElement') ? undefined : value
 ));
 // RIMOSSO (ridondante): announceGemini('Livello copiato', 'polite');
 }
 
 function pasteLayer() {
 if (!state.clipboard) {
 announceGemini('Nessun livello negli appunti', 'polite');
 return;
 }
 
 const clone = JSON.parse(JSON.stringify(state.clipboard));
 clone.x += 20;
 clone.y += 20;
 clone.name += ' incollato';
 
 if (clone.type === 'image' && clone.imageData) {
 const img = new Image();
 img.onload = () => {
 clone.imageElement = img;
 addLayer(clone);
 };
 img.src = clone.imageData;
 } else {
 addLayer(clone);
 }
 announceGemini('Livello incollato', 'assertive');
 }
 
 // ---- RENDERING ----
 
 function render() {
 const startTime = performance.now();
 
 try {
 // Sfondo
 if (state.backgroundColor === 'transparent') {
 ctx.clearRect(0, 0, canvas.width, canvas.height);
 } else if (state.backgroundType === 'gradient' && state.backgroundGradient) {
 // Gradiente
 const grad = state.backgroundGradient;
 let gradient;
 if (grad.type === 'radial') {
 gradient = ctx.createRadialGradient(
 canvas.width / 2, canvas.height / 2, 0,
 canvas.width / 2, canvas.height / 2, Math.max(canvas.width, canvas.height) / 2
 );
 } else {
 // Lineare con angolo
 const angle = (grad.angle - 90) * Math.PI / 180;
 const length = Math.max(canvas.width, canvas.height);
 const x1 = canvas.width / 2 - Math.cos(angle) * length / 2;
 const y1 = canvas.height / 2 - Math.sin(angle) * length / 2;
 const x2 = canvas.width / 2 + Math.cos(angle) * length / 2;
 const y2 = canvas.height / 2 + Math.sin(angle) * length / 2;
 gradient = ctx.createLinearGradient(x1, y1, x2, y2);
 }
 gradient.addColorStop(0, grad.color1);
 gradient.addColorStop(1, grad.color2);
 ctx.fillStyle = gradient;
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 } else if (state.backgroundType === 'image' && state.backgroundImage) {
 // Immagine
 const img = state.backgroundImage.element;
 const fit = state.backgroundImage.fit;
 
 if (fit === 'cover') {
 const scale = Math.max(canvas.width / img.width, canvas.height / img.height);
 const w = img.width * scale;
 const h = img.height * scale;
 const x = (canvas.width - w) / 2;
 const y = (canvas.height - h) / 2;
 ctx.drawImage(img, x, y, w, h);
 } else if (fit === 'contain') {
 const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
 const w = img.width * scale;
 const h = img.height * scale;
 const x = (canvas.width - w) / 2;
 const y = (canvas.height - h) / 2;
 ctx.fillStyle = '#ffffff';
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 ctx.drawImage(img, x, y, w, h);
 } else if (fit === 'stretch') {
 ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
 } else if (fit === 'tile') {
 for (let x = 0; x < canvas.width; x += img.width) {
 for (let y = 0; y < canvas.height; y += img.height) {
 ctx.drawImage(img, x, y);
 }
 }
 }
 } else {
 // Colore solido
 ctx.fillStyle = state.backgroundColor;
 ctx.fillRect(0, 0, canvas.width, canvas.height);
 }
 
 // Griglia
 if (state.showGrid) drawGrid();
 
 // Livelli
 state.layers.forEach((layer, index) => {
 // Skip layer non visibili
 if (!layer.visible && layer.visible !== undefined) return;
 
 // VALIDAZIONE LAYER prima del rendering
 if (!layer || !layer.type) {
 console.warn('Layer non valido ignorato durante render:', index);
 return;
 }
 
 // Validazione coordinate
 if (typeof layer.x !== 'number' || typeof layer.y !== 'number' || 
 isNaN(layer.x) || isNaN(layer.y)) {
 console.warn('Layer con coordinate non valide ignorato:', layer.name);
 return;
 }
 
 // Validazione dimensioni
 if (layer.width !== undefined && layer.height !== undefined) {
 if (layer.width <= 0 || layer.height <= 0 || 
 isNaN(layer.width) || isNaN(layer.height)) {
 console.warn('Layer con dimensioni non valide ignorato:', layer.name);
 return;
 }
 }
 
 try {
 ctx.save();
 
 // Blend Mode con validazione
 const validBlendModes = ['source-over', 'multiply', 'screen', 'overlay', 'darken', 
 'lighten', 'color-dodge', 'color-burn', 'hard-light', 
 'soft-light', 'difference', 'exclusion', 'hue', 
 'saturation', 'color', 'luminosity'];
 const blendMode = layer.blendMode || 'source-over';
 ctx.globalCompositeOperation = validBlendModes.includes(blendMode) ? blendMode : 'source-over';
 
 // Opacità con validazione
 const opacity = layer.opacity ?? 100;
 ctx.globalAlpha = Math.max(0, Math.min(1, opacity / 100));
 
 // Drop Shadow con validazione
 if (layer.dropShadow && layer.dropShadow.enabled) {
 ctx.shadowColor = layer.dropShadow.color || 'rgba(0,0,0,0.5)';
 ctx.shadowBlur = Math.max(0, layer.dropShadow.blur || 0);
 ctx.shadowOffsetX = layer.dropShadow.x || 0;
 ctx.shadowOffsetY = layer.dropShadow.y || 0;
 }
 
 // Trasformazioni (rotazione) con validazione
 if (layer.width && layer.height) {
 const rotation = layer.rotation || 0;
 if (!isNaN(rotation) && rotation !== 0) {
 const cx = layer.x + layer.width / 2;
 const cy = layer.y + layer.height / 2;
 ctx.translate(cx, cy);
 ctx.rotate((rotation * Math.PI) / 180);
 ctx.translate(-cx, -cy);
 }
 }
 
 // Disegna layer con try-catch per errori specifici
 try {
 if (layer.type === 'text') {
 renderText(layer);
 } else if (layer.type === 'shape') {
 renderShape(layer);
 } else if (layer.type === 'image') {
 // Validazione imageElement
 if (!layer.imageElement) {
 console.warn('Layer immagine senza imageElement ignorato:', layer.name);
 } else {
 renderImage(layer);
 }
 } else if (layer.type === 'polygon') {
 // Validazione polygonPoints
 if (!layer.polygonPoints || layer.polygonPoints.length < 2) {
 console.warn('Layer poligono con punti insufficienti ignorato:', layer.name);
 } else {
 renderPolygon(layer);
 }
 }
 } catch (renderError) {
 logError('render', renderError, `Errore rendering layer ${layer.name} (${layer.type})`);
 console.error('Errore render layer:', layer.name, renderError);
 }
 
 ctx.restore();
 
 // Selection box
 if (state.selectedIds.includes(layer.id)) {
 try {
 drawSelectionBox(layer);
 } catch (selError) {
 console.error('Errore draw selection box:', selError);
 }
 }
 
 } catch (layerError) {
 logError('render', layerError, `Errore completo rendering layer ${index}`);
 console.error('Errore critico render layer:', layerError);
 // Restore context anche in caso di errore
 try { ctx.restore(); } catch (e) { /* ignore */ }
 }
 });
 
 // Mappa Sonora
 if (state.isGridModeActive) {
 drawSoundMapGrid();
 }
 
 // Disegno Vettoriale
 if (state.vectorDrawMode) {
 drawVectorMode();
 }
 
 // CURSORE MODALITÀ ESPLORAZIONE
 if (state.explorationMode && state.explorationCursor) {
 drawExplorationCursor();
 }
 
 // v39.1: SAFE ZONE OVERLAY (alla fine, sopra tutto)
 renderSafeZoneOverlay();
 
 } catch (error) {
 logError('render', error, 'Errore durante il rendering');
 console.error('Errore render:', error);
 } finally {
 const endTime = performance.now();
 trackPerformance('render', endTime - startTime);
 }
 }
 
 function drawExplorationCursor() {
 if (!state.explorationCursor) return;
 
 const x = state.explorationCursor.x;
 const y = state.explorationCursor.y;
 const size = 20;
 
 ctx.save();
 
 // Cerchio esterno pulsante (animato)
 const time = Date.now() / 500;
 const pulse = Math.sin(time) * 0.3 + 1;
 
 ctx.strokeStyle = '#ff0000';
 ctx.lineWidth = 3;
 ctx.beginPath();
 ctx.arc(x, y, size * pulse, 0, Math.PI * 2);
 ctx.stroke();
 
 // Croce centrale
 ctx.strokeStyle = '#ff0000';
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(x - size, y);
 ctx.lineTo(x + size, y);
 ctx.moveTo(x, y - size);
 ctx.lineTo(x, y + size);
 ctx.stroke();
 
 // Punto centrale
 ctx.fillStyle = '#ff0000';
 ctx.beginPath();
 ctx.arc(x, y, 4, 0, Math.PI * 2);
 ctx.fill();
 
 ctx.restore();
 }
 
 /**
 * v39.1: Visualizza safe zone overlay con zone pericolose evidenziate
 */
 function renderSafeZoneOverlay() {
 if (!state.showSafeZone) return; // Toggle on/off
 
 const canvas = document.getElementById('canvas');
 const sz = state.tpl.safe || {top: 0, right: 0, bottom: 0, left: 0};
 
 // Se non ci sono safe zone definite, non mostrare nulla
 if (sz.top === 0 && sz.right === 0 && sz.bottom === 0 && sz.left === 0) return;
 
 ctx.save();
 
 // OVERLAY SEMI-TRASPARENTE per zone pericolose (rosso)
 ctx.fillStyle = 'rgba(255, 0, 0, 0.15)';
 
 // Top danger zone
 if (sz.top > 0) {
 ctx.fillRect(0, 0, canvas.width, sz.top);
 }
 
 // Bottom danger zone
 if (sz.bottom > 0) {
 ctx.fillRect(0, canvas.height - sz.bottom, canvas.width, sz.bottom);
 }
 
 // Left danger zone
 if (sz.left > 0) {
 ctx.fillRect(0, sz.top, sz.left, canvas.height - sz.top - sz.bottom);
 }
 
 // Right danger zone
 if (sz.right > 0) {
 ctx.fillRect(canvas.width - sz.right, sz.top, sz.right, canvas.height - sz.top - sz.bottom);
 }
 
 // LINEE GUIDA per safe zone (bordo tratteggiato)
 ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
 ctx.lineWidth = 2;
 ctx.setLineDash([10, 5]); // Linea tratteggiata
 
 // Bordo safe zone
 if (sz.left || sz.top || sz.right || sz.bottom) {
 const safeX = sz.left;
 const safeY = sz.top;
 const safeWidth = canvas.width - sz.left - sz.right;
 const safeHeight = canvas.height - sz.top - sz.bottom;
 
 ctx.strokeRect(safeX, safeY, safeWidth, safeHeight);
 }
 
 // ETICHETTE con percentuali
 ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
 ctx.font = 'bold 14px Arial';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.setLineDash([]); // Reset linea per testo
 
 // Ombra per leggibilità
 ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
 ctx.shadowBlur = 4;
 ctx.shadowOffsetX = 1;
 ctx.shadowOffsetY = 1;
 
 // Top label
 if (sz.top > 20) {
 const topPercent = ((sz.top / canvas.height) * 100).toFixed(1);
 ctx.fillText(`️ Top ${topPercent}% (${sz.top}px)`, canvas.width / 2, sz.top / 2);
 }
 
 // Bottom label
 if (sz.bottom > 20) {
 const bottomPercent = ((sz.bottom / canvas.height) * 100).toFixed(1);
 ctx.fillText(`️ Bottom ${bottomPercent}% (${sz.bottom}px)`, canvas.width / 2, canvas.height - sz.bottom / 2);
 }
 
 // Left label (ruotato)
 if (sz.left > 40) {
 const leftPercent = ((sz.left / canvas.width) * 100).toFixed(1);
 ctx.save();
 ctx.translate(sz.left / 2, canvas.height / 2);
 ctx.rotate(-Math.PI / 2);
 ctx.fillText(`️ Left ${leftPercent}%`, 0, 0);
 ctx.restore();
 }
 
 // Right label (ruotato)
 if (sz.right > 40) {
 const rightPercent = ((sz.right / canvas.width) * 100).toFixed(1);
 ctx.save();
 ctx.translate(canvas.width - sz.right / 2, canvas.height / 2);
 ctx.rotate(Math.PI / 2);
 ctx.fillText(`️ Right ${rightPercent}%`, 0, 0);
 ctx.restore();
 }
 
 // ETICHETTA CENTRALE "SAFE ZONE"
 ctx.fillStyle = 'rgba(0, 255, 0, 0.2)'; // Verde trasparente
 ctx.font = 'bold 20px Arial';
 const safeZoneCenterX = sz.left + (canvas.width - sz.left - sz.right) / 2;
 const safeZoneCenterY = sz.top + (canvas.height - sz.top - sz.bottom) / 2;
 ctx.fillText(' SAFE ZONE', safeZoneCenterX, safeZoneCenterY);
 
 ctx.restore();
 }
 
 function renderText(layer) {
 // v39.1: Safe Zone configurabili dal template (non più hardcoded)
 const safePadding = state.tpl?.safe || {top: 15, right: 15, bottom: 15, left: 15};
 const SAFE_ZONE_TOP = safePadding.top;
 const SAFE_ZONE_BOTTOM = safePadding.bottom;
 const SAFE_ZONE_LEFT = safePadding.left;
 const SAFE_ZONE_RIGHT = safePadding.right;
 
 const canvas = document.getElementById('canvas');
 
 // Font
 let fontStyle = '';
 if (layer.italic) fontStyle += 'italic ';
 fontStyle += (layer.fontWeight || '400') + ' ';
 fontStyle += layer.fontSize + 'px ';
 fontStyle += layer.fontFamily;
 ctx.font = fontStyle;
 
 // Allineamento
 ctx.textAlign = layer.textAlign || 'left';
 ctx.textBaseline = 'top';
 
 // Colore o Gradiente
 if (layer.useGradient && layer.gradient) {
 ctx.fillStyle = createGradient(layer, layer.gradient);
 } else {
 ctx.fillStyle = layer.color;
 }
 
 // Calcola lineHeight
 const lineHeight = layer.fontSize * (layer.lineHeight || 1.2);
 
 // SUPPORTO MULTI-RIGA: splitta il testo per \n
 const lines = (layer.text || '').split('\n');
 const maxWidth = canvas.width - SAFE_ZONE_LEFT - SAFE_ZONE_RIGHT; // v39.1: usa safe zone laterali
 
 // Array per contenere tutte le righe renderizzate (incluso word wrap)
 const wrappedLines = [];
 
 // Per ogni riga nel testo originale
 lines.forEach(line => {
 if (line.trim() === '') {
 // Riga vuota - mantienila
 wrappedLines.push('');
 return;
 }
 
 // WORD WRAPPING: spezza le righe troppo lunghe
 const words = line.split(' ');
 let currentLine = '';
 
 for (let i = 0; i < words.length; i++) {
 const word = words[i];
 const testLine = currentLine ? currentLine + ' ' + word : word;
 const metrics = ctx.measureText(testLine);
 const testWidth = metrics.width + (layer.letterSpacing ? testLine.length * (layer.letterSpacing || 0) : 0);
 
 if (testWidth > maxWidth && currentLine !== '') {
 // La riga è troppo lunga, vai a capo
 wrappedLines.push(currentLine);
 currentLine = word;
 } else {
 currentLine = testLine;
 }
 }
 
 // Aggiungi l'ultima riga
 if (currentLine) {
 wrappedLines.push(currentLine);
 }
 });
 
 // Calcola l'altezza totale del blocco di testo
 const totalHeight = wrappedLines.length * lineHeight;
 
 // v39.1: Applica safe zone TOP e BOTTOM (non più uguali!)
 let startY = layer.y;
 if (startY < SAFE_ZONE_TOP) {
 startY = SAFE_ZONE_TOP;
 layer.y = startY;
 }
 if (startY + totalHeight > canvas.height - SAFE_ZONE_BOTTOM) {
 startY = canvas.height - totalHeight - SAFE_ZONE_BOTTOM;
 layer.y = startY;
 }
 
 // NON applicare safe zone per X qui - lo facciamo dopo in base a textAlign
 
 // Renderizza ogni riga
 wrappedLines.forEach((line, index) => {
 const currentY = startY + (index * lineHeight);
 
 // Calcola larghezza della riga (senza letter spacing per metrics base)
 const lineMetrics = ctx.measureText(line);
 const baseWidth = lineMetrics.width;
 const lineWidth = baseWidth + (layer.letterSpacing ? line.length * (layer.letterSpacing || 0) : 0);
 
 // Calcola currentX in base a textAlign
 const textAlign = layer.textAlign || 'left';
 let currentX = layer.x; // Usa layer.x come riferimento base
 
 // Calcola i bordi effettivi del testo in base a textAlign
 let textLeftEdge, textRightEdge;
 if (textAlign === 'center') {
 textLeftEdge = currentX - lineWidth / 2;
 textRightEdge = currentX + lineWidth / 2;
 } else if (textAlign === 'right') {
 textLeftEdge = currentX - lineWidth;
 textRightEdge = currentX;
 } else { // left
 textLeftEdge = currentX;
 textRightEdge = currentX + lineWidth;
 }
 
 // v39.1: Aggiusta currentX se il testo esce dai bordi (safe zone laterali)
 // IMPORTANTE: spostiamo currentX mantenendo l'allineamento
 if (textLeftEdge < SAFE_ZONE_LEFT) {
 const shift = SAFE_ZONE_LEFT - textLeftEdge;
 currentX += shift;
 }
 if (textRightEdge > canvas.width - SAFE_ZONE_RIGHT) {
 const shift = textRightEdge - (canvas.width - SAFE_ZONE_RIGHT);
 currentX -= shift;
 }
 
 // Ricalcola i bordi finali dopo l'aggiustamento
 if (textAlign === 'center') {
 textLeftEdge = currentX - lineWidth / 2;
 textRightEdge = currentX + lineWidth / 2;
 } else if (textAlign === 'right') {
 textLeftEdge = currentX - lineWidth;
 textRightEdge = currentX;
 } else { // left
 textLeftEdge = currentX;
 textRightEdge = currentX + lineWidth;
 }
 
 // Decorazioni (sottolineato/barrato) per questa riga
 // Calcola i punti di inizio e fine in base a textAlign
 if (layer.underline || layer.lineThrough) {
 const decorY = layer.underline ? currentY + layer.fontSize : currentY + layer.fontSize / 2;
 ctx.strokeStyle = layer.color;
 ctx.lineWidth = 2;
 ctx.beginPath();
 
 // Calcola start e end della linea in base a textAlign
 let lineStart, lineEnd;
 if (textAlign === 'center') {
 lineStart = currentX - baseWidth / 2;
 lineEnd = currentX + baseWidth / 2;
 } else if (textAlign === 'right') {
 lineStart = currentX - baseWidth;
 lineEnd = currentX;
 } else { // left
 lineStart = currentX;
 lineEnd = currentX + baseWidth;
 }
 
 ctx.moveTo(lineStart, decorY);
 ctx.lineTo(lineEnd, decorY);
 ctx.stroke();
 }
 
 // Renderizza il testo
 if (layer.letterSpacing && layer.letterSpacing !== 0) {
 // Con letter spacing - devo gestire textAlign manualmente
 // Salvo il textAlign originale e lo imposto a 'left' per il rendering carattere per carattere
 const originalAlign = ctx.textAlign;
 ctx.textAlign = 'left';
 
 // Calcola il punto di partenza in base a textAlign
 let startX_ls;
 if (textAlign === 'center') {
 startX_ls = currentX - lineWidth / 2;
 } else if (textAlign === 'right') {
 startX_ls = currentX - lineWidth;
 } else { // left
 startX_ls = currentX;
 }
 
 let x = startX_ls;
 for (let char of line) {
 ctx.fillText(char, x, currentY);
 x += ctx.measureText(char).width + layer.letterSpacing;
 }
 
 // Bordo del testo con letter spacing
 if (layer.useStroke && layer.stroke) {
 ctx.strokeStyle = layer.stroke.color;
 ctx.lineWidth = layer.stroke.width;
 x = startX_ls;
 for (let char of line) {
 ctx.strokeText(char, x, currentY);
 x += ctx.measureText(char).width + layer.letterSpacing;
 }
 }
 
 // Ripristina textAlign originale
 ctx.textAlign = originalAlign;
 } else {
 // Senza letter spacing - Canvas API gestisce textAlign automaticamente
 ctx.fillText(line, currentX, currentY);
 
 // Bordo del testo
 if (layer.useStroke && layer.stroke) {
 ctx.strokeStyle = layer.stroke.color;
 ctx.lineWidth = layer.stroke.width;
 ctx.strokeText(line, currentX, currentY);
 }
 }
 });
 
 // Aggiorna le dimensioni del layer per la selezione
 if (wrappedLines.length > 0) {
 const maxLineWidth = Math.max(...wrappedLines.map(line => {
 const m = ctx.measureText(line);
 return m.width + (layer.letterSpacing ? line.length * (layer.letterSpacing || 0) : 0);
 }));
 layer.width = maxLineWidth;
 layer.height = totalHeight;
 }
 }
 
 function renderShape(layer) {
 ctx.beginPath();
 
 if (layer.shape === 'rect') {
 if (layer.cornerRadius && layer.cornerRadius > 0) {
 const r = Math.min(layer.cornerRadius, layer.width / 2, layer.height / 2);
 ctx.moveTo(layer.x + r, layer.y);
 ctx.lineTo(layer.x + layer.width - r, layer.y);
 ctx.quadraticCurveTo(layer.x + layer.width, layer.y, layer.x + layer.width, layer.y + r);
 ctx.lineTo(layer.x + layer.width, layer.y + layer.height - r);
 ctx.quadraticCurveTo(layer.x + layer.width, layer.y + layer.height, layer.x + layer.width - r, layer.y + layer.height);
 ctx.lineTo(layer.x + r, layer.y + layer.height);
 ctx.quadraticCurveTo(layer.x, layer.y + layer.height, layer.x, layer.y + layer.height - r);
 ctx.lineTo(layer.x, layer.y + r);
 ctx.quadraticCurveTo(layer.x, layer.y, layer.x + r, layer.y);
 } else {
 ctx.rect(layer.x, layer.y, layer.width, layer.height);
 }
 } else if (layer.shape === 'circle') {
 const cx = layer.x + layer.width / 2;
 const cy = layer.y + layer.height / 2;
 const r = Math.min(layer.width, layer.height) / 2;
 ctx.arc(cx, cy, r, 0, Math.PI * 2);
 } else if (layer.shape === 'triangle') {
 ctx.moveTo(layer.x + layer.width / 2, layer.y);
 ctx.lineTo(layer.x + layer.width, layer.y + layer.height);
 ctx.lineTo(layer.x, layer.y + layer.height);
 } else if (layer.shape === 'star') {
 drawStar(ctx, layer.x + layer.width / 2, layer.y + layer.height / 2, 5, 
 Math.min(layer.width, layer.height) / 2, 
 Math.min(layer.width, layer.height) / 4);
 } else if (layer.shape === 'star8') {
 drawStar(ctx, layer.x + layer.width / 2, layer.y + layer.height / 2, 8, 
 Math.min(layer.width, layer.height) / 2, 
 Math.min(layer.width, layer.height) / 3);
 } else if (layer.shape === 'heart') {
 drawHeart(ctx, layer.x, layer.y, layer.width, layer.height);
 } else if (layer.shape === 'speech') {
 drawSpeechBubble(ctx, layer.x, layer.y, layer.width, layer.height);
 } else if (layer.shape === 'line') {
 ctx.moveTo(layer.x, layer.y);
 ctx.lineTo(layer.x + layer.width, layer.y + layer.height);
 } else if (layer.shape === 'hexagon') {
 drawHexagon(ctx, layer.x, layer.y, layer.width, layer.height);
 } else if (layer.shape === 'arrow') {
 drawArrow(ctx, layer.x, layer.y, layer.width, layer.height);
 }
 
 // Riempimento (non per linee)
 if (layer.shape !== 'line') {
 if (layer.useGradient && layer.gradient) {
 ctx.fillStyle = createGradient(layer, layer.gradient);
 } else {
 ctx.fillStyle = layer.color;
 }
 ctx.fill();
 }
 
 // Bordo con stile
 if (layer.useStroke && layer.stroke) {
 ctx.strokeStyle = layer.stroke.color;
 ctx.lineWidth = layer.stroke.width;
 
 // Applica stile linea
 if (layer.stroke.style === 'dashed') {
 ctx.setLineDash([10, 5]);
 } else if (layer.stroke.style === 'dotted') {
 ctx.setLineDash([2, 3]);
 } else {
 ctx.setLineDash([]);
 }
 
 ctx.stroke();
 ctx.setLineDash([]); // Reset
 }
 }
 
 function renderImage(layer) {
 if (!layer.imageElement) return;
 
 // Maschera di Ritaglio
 const maskType = layer.maskShape || layer.mask;
 if (maskType && maskType !== 'none') {
 ctx.save();
 ctx.beginPath();
 
 const cx = layer.x + layer.width / 2;
 const cy = layer.y + layer.height / 2;
 
 switch(maskType) {
 case 'circle':
 const r = Math.min(layer.width, layer.height) / 2;
 ctx.arc(cx, cy, r, 0, Math.PI * 2);
 break;
 
 case 'rounded':
 const radius = Math.min(layer.width, layer.height) * 0.1;
 ctx.moveTo(layer.x + radius, layer.y);
 ctx.lineTo(layer.x + layer.width - radius, layer.y);
 ctx.quadraticCurveTo(layer.x + layer.width, layer.y, layer.x + layer.width, layer.y + radius);
 ctx.lineTo(layer.x + layer.width, layer.y + layer.height - radius);
 ctx.quadraticCurveTo(layer.x + layer.width, layer.y + layer.height, layer.x + layer.width - radius, layer.y + layer.height);
 ctx.lineTo(layer.x + radius, layer.y + layer.height);
 ctx.quadraticCurveTo(layer.x, layer.y + layer.height, layer.x, layer.y + layer.height - radius);
 ctx.lineTo(layer.x, layer.y + radius);
 ctx.quadraticCurveTo(layer.x, layer.y, layer.x + radius, layer.y);
 break;
 
 case 'triangle':
 ctx.moveTo(cx, layer.y);
 ctx.lineTo(layer.x + layer.width, layer.y + layer.height);
 ctx.lineTo(layer.x, layer.y + layer.height);
 ctx.closePath();
 break;
 
 case 'star':
 const spikes = 5;
 const outerRadius = Math.min(layer.width, layer.height) / 2;
 const innerRadius = outerRadius * 0.5;
 let rot = Math.PI / 2 * 3;
 let x = cx;
 let y = cy;
 const step = Math.PI / spikes;
 
 ctx.moveTo(cx, cy - outerRadius);
 for (let i = 0; i < spikes; i++) {
 x = cx + Math.cos(rot) * outerRadius;
 y = cy + Math.sin(rot) * outerRadius;
 ctx.lineTo(x, y);
 rot += step;
 
 x = cx + Math.cos(rot) * innerRadius;
 y = cy + Math.sin(rot) * innerRadius;
 ctx.lineTo(x, y);
 rot += step;
 }
 ctx.lineTo(cx, cy - outerRadius);
 ctx.closePath();
 break;
 
 case 'heart':
 const w = layer.width;
 const h = layer.height;
 const top = layer.y + h * 0.3;
 ctx.moveTo(cx, top + h * 0.3);
 ctx.bezierCurveTo(cx, top, cx - w / 2, top, cx - w / 2, top + h * 0.3);
 ctx.bezierCurveTo(cx - w / 2, top + h * 0.5, cx, top + h * 0.7, cx, layer.y + h);
 ctx.bezierCurveTo(cx, top + h * 0.7, cx + w / 2, top + h * 0.5, cx + w / 2, top + h * 0.3);
 ctx.bezierCurveTo(cx + w / 2, top, cx, top, cx, top + h * 0.3);
 ctx.closePath();
 break;
 
 case 'hexagon':
 const size = Math.min(layer.width, layer.height) / 2;
 for (let i = 0; i < 6; i++) {
 const angle = (Math.PI / 3) * i;
 const hx = cx + size * Math.cos(angle);
 const hy = cy + size * Math.sin(angle);
 if (i === 0) ctx.moveTo(hx, hy);
 else ctx.lineTo(hx, hy);
 }
 ctx.closePath();
 break;
 }
 
 ctx.clip();
 }
 
 // Applica filtri CSS prima di disegnare
 if (layer.filters) {
 applyImageFilters(layer);
 }
 
 // Flip
 if (layer.flipH || layer.flipV) {
 ctx.save();
 ctx.translate(layer.x + layer.width / 2, layer.y + layer.height / 2);
 ctx.scale(layer.flipH ? -1 : 1, layer.flipV ? -1 : 1);
 ctx.drawImage(layer.imageElement, -layer.width / 2, -layer.height / 2, layer.width, layer.height);
 ctx.restore();
 } else {
 ctx.drawImage(layer.imageElement, layer.x, layer.y, layer.width, layer.height);
 }
 
 if (maskType && maskType !== 'none') {
 ctx.restore();
 }
 
 // CRITICAL FIX: Reset filtri per evitare che si applichino ai layer successivi
 ctx.filter = 'none';
 }
 
 function renderPolygon(layer) {
 if (!layer.polygonPoints || layer.polygonPoints?.length < 3) return;
 
 ctx.beginPath();
 const points = layer.polygonPoints;
 ctx.moveTo(layer.x + points[0].x, layer.y + points[0].y);
 for (let i = 1; i < points.length; i++) {
 ctx.lineTo(layer.x + points[i].x, layer.y + points[i].y);
 }
 
 // Chiudi il percorso solo se l'opzione è attiva (default: true per compatibilità)
 if (layer.closePath !== false) {
 ctx.closePath();
 }
 
 // Riempimento (solo se la forma è chiusa)
 if (layer.closePath !== false) {
 if (layer.useGradient && layer.gradient) {
 ctx.fillStyle = createGradient(layer, layer.gradient);
 } else {
 ctx.fillStyle = layer.color;
 }
 ctx.fill();
 }
 
 // Bordo
 if (layer.useStroke && layer.stroke) {
 ctx.strokeStyle = layer.stroke.color;
 ctx.lineWidth = layer.stroke.width;
 ctx.stroke();
 }
 }
 
 function applyImageFilters(layer) {
 const f = layer.filters;
 if (!f) return;
 
 let filterString = '';
 
 // Preset
 if (f.preset && f.preset !== 'none') {
 if (f.preset === 'grayscale') {
 filterString += 'grayscale(100%) ';
 } else if (f.preset === 'vintage') {
 filterString += 'sepia(50%) saturate(120%) contrast(110%) ';
 } else if (f.preset === 'warm') {
 filterString += 'hue-rotate(-20deg) saturate(120%) ';
 } else if (f.preset === 'cool') {
 filterString += 'hue-rotate(20deg) saturate(110%) ';
 }
 }
 
 // Filtri manuali
 if (f.brightness !== 0) {
 filterString += `brightness(${100 + f.brightness}%) `;
 }
 if (f.contrast !== 0) {
 filterString += `contrast(${100 + f.contrast}%) `;
 }
 if (f.saturation !== 0) {
 filterString += `saturate(${100 + f.saturation}%) `;
 }
 if (f.hue !== 0) {
 filterString += `hue-rotate(${f.hue}deg) `;
 }
 if (f.sepia > 0) {
 filterString += `sepia(${f.sepia}%) `;
 }
 if (f.blur > 0) {
 filterString += `blur(${f.blur}px) `;
 }
 if (f.invert > 0) {
 filterString += `invert(${f.invert}%) `;
 }
 
 ctx.filter = filterString || 'none';
 }
 
 function createGradient(layer, g) {
 if (g.type === 'linear') {
 const angle = (g.angle * Math.PI) / 180;
 const x1 = layer.width / 2 - Math.cos(angle) * layer.width / 2;
 const y1 = layer.height / 2 - Math.sin(angle) * layer.height / 2;
 const x2 = layer.width / 2 + Math.cos(angle) * layer.width / 2;
 const y2 = layer.height / 2 + Math.sin(angle) * layer.height / 2;
 const grad = ctx.createLinearGradient(x1, y1, x2, y2);
 grad.addColorStop(0, g.color1);
 grad.addColorStop(1, g.color2);
 return grad;
 } else { // Radiale
 const grad = ctx.createRadialGradient(
 layer.width / 2, layer.height / 2, 0,
 layer.width / 2, layer.height / 2, Math.max(layer.width, layer.height) / 2
 );
 grad.addColorStop(0, g.color1);
 grad.addColorStop(1, g.color2);
 return grad;
 }
 }
 
 function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
 let rot = Math.PI / 2 * 3; let x = cx; let y = cy;
 const step = Math.PI / spikes;
 ctx.moveTo(cx, cy - outerRadius);
 for (let i = 0; i < spikes; i++) {
 x = cx + Math.cos(rot) * outerRadius; y = cy + Math.sin(rot) * outerRadius;
 ctx.lineTo(x, y); rot += step;
 x = cx + Math.cos(rot) * innerRadius; y = cy + Math.sin(rot) * innerRadius;
 ctx.lineTo(x, y); rot += step;
 }
 ctx.lineTo(cx, cy - outerRadius);
 }
 
 function drawHexagon(ctx, x, y, width, height) {
 const sideRatio = 0.25;
 ctx.moveTo(x + width * sideRatio, y);
 ctx.lineTo(x + width * (1 - sideRatio), y);
 ctx.lineTo(x + width, y + height * 0.5);
 ctx.lineTo(x + width * (1 - sideRatio), y + height);
 ctx.lineTo(x + width * sideRatio, y + height);
 ctx.lineTo(x, y + height * 0.5);
 }
 
 function drawArrow(ctx, x, y, width, height) {
 const bodyHeightRatio = 0.4;
 const headWidthRatio = 0.3;
 const headHeightRatio = 1.0;
 const bodyY = y + height * (1 - bodyHeightRatio) / 2;
 const bodyHeight = height * bodyHeightRatio;
 const headWidth = width * headWidthRatio;
 const headBaseX = x + width - headWidth;
 
 ctx.moveTo(x, bodyY);
 ctx.lineTo(headBaseX, bodyY);
 ctx.lineTo(headBaseX, y + height * (1 - headHeightRatio) / 2);
 ctx.lineTo(x + width, y + height / 2);
 ctx.lineTo(headBaseX, y + height * (1 - (1 - headHeightRatio) / 2));
 ctx.lineTo(headBaseX, bodyY + bodyHeight);
 ctx.lineTo(x, bodyY + bodyHeight);
 }
 
 function drawHeart(ctx, x, y, width, height) {
 const cx = x + width / 2;
 const cy = y + height / 3;
 ctx.moveTo(cx, cy);
 ctx.bezierCurveTo(cx, cy - height / 4, x, cy - height / 4, x, cy + height / 6);
 ctx.bezierCurveTo(x, cy + height / 3, x, cy + height / 2, cx, cy + height * 0.75);
 ctx.bezierCurveTo(x + width, cy + height / 2, x + width, cy + height / 3, x + width, cy + height / 6);
 ctx.bezierCurveTo(x + width, cy - height / 4, cx, cy - height / 4, cx, cy);
 }
 
 function drawSpeechBubble(ctx, x, y, width, height) {
 const radius = 15;
 const tailWidth = 20;
 const tailHeight = 30;
 
 // Corpo del fumetto (rettangolo arrotondato)
 ctx.moveTo(x + radius, y);
 ctx.lineTo(x + width - radius, y);
 ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
 ctx.lineTo(x + width, y + height - tailHeight - radius);
 ctx.quadraticCurveTo(x + width, y + height - tailHeight, x + width - radius, y + height - tailHeight);
 
 // Coda del fumetto
 ctx.lineTo(x + width / 2 + tailWidth, y + height - tailHeight);
 ctx.lineTo(x + width / 2, y + height);
 ctx.lineTo(x + width / 2 - tailWidth, y + height - tailHeight);
 
 ctx.lineTo(x + radius, y + height - tailHeight);
 ctx.quadraticCurveTo(x, y + height - tailHeight, x, y + height - tailHeight - radius);
 ctx.lineTo(x, y + radius);
 ctx.quadraticCurveTo(x, y, x + radius, y);
 }
 
 function drawGrid() {
 ctx.save();
 ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
 ctx.lineWidth = 1;
 for (let x = state.gridSize; x < canvas.width; x += state.gridSize) {
 ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
 }
 for (let y = state.gridSize; y < canvas.height; y += state.gridSize) {
 ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
 }
 ctx.restore();
 }

 function drawSoundMapGrid() {
 ctx.save();
 ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)'; // Blu primario
 ctx.lineWidth = 2; 
 const cellW = canvas.width / 3, cellH = canvas.height / 3;
 
 // Griglia 3x3
 ctx.strokeRect(cellW, 0, cellW, canvas.height); 
 ctx.strokeRect(0, cellH, canvas.width, cellH);
 
 // Cella attiva
 ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; // Bianco
 ctx.lineWidth = 4;
 ctx.strokeRect(state.gridCell.x * cellW, state.gridCell.y * cellH, cellW, cellH);
 ctx.restore();
 }
 
 function drawSelectionBox(layer) {
 ctx.save();
 
 // Reset trasformazioni per disegnare il box in coordinate schermo
 ctx.setTransform(1, 0, 0, 1, 0, 0);
 
 // Box
 ctx.strokeStyle = '#3b82f6';
 ctx.lineWidth = 2;
 ctx.setLineDash([5, 5]);
 
 // Calcola bounding box ruotato
 const rad = (layer.rotation * Math.PI) / 180;
 const cx = layer.x + layer.width / 2;
 const cy = layer.y + layer.height / 2;
 
 ctx.translate(cx, cy);
 ctx.rotate(rad);
 ctx.strokeRect(-layer.width / 2 - 2, -layer.height / 2 - 2, layer.width + 4, layer.height + 4);
 
 ctx.restore();
 }
 
 // ---- Disegno Vettoriale ----
 
 function drawVectorMode() {
 ctx.save();
 ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset trasformazioni
 
 const useSmooth = state.vectorDrawType === 'smooth';
 
 // Disegna i punti già posizionati
 if (state.vectorPoints.length > 0) {
 ctx.strokeStyle = state.vectorStrokeColor;
 ctx.lineWidth = state.vectorStrokeWidth;
 ctx.fillStyle = state.vectorFillColor;
 
 // Se modalità smooth e abbiamo almeno 3 punti, mostra preview smooth
 if (useSmooth && state.vectorPoints.length >= 2) {
 // Aggiungi temporaneamente il cursore corrente per il preview
 const previewPoints = [...state.vectorPoints, state.vectorCursor];
 const smoothPoints = calculateSmoothCurve(previewPoints, state.vectorSmoothIntensity, false);
 
 // Disegna la curva smooth
 ctx.beginPath();
 if (smoothPoints.length > 0) {
 ctx.moveTo(smoothPoints[0].x, smoothPoints[0].y);
 for (let i = 1; i < smoothPoints.length; i++) {
 ctx.lineTo(smoothPoints[i].x, smoothPoints[i].y);
 }
 }
 ctx.stroke();
 
 // Disegna anche una linea sottile dai punti campione originali
 ctx.save();
 ctx.strokeStyle = 'rgba(59, 130, 246, 0.3)'; // Blu trasparente
 ctx.lineWidth = 1;
 ctx.setLineDash([5, 5]);
 ctx.beginPath();
 ctx.moveTo(state.vectorPoints[0].x, state.vectorPoints[0].y);
 for (let i = 1; i < state.vectorPoints.length; i++) {
 ctx.lineTo(state.vectorPoints[i].x, state.vectorPoints[i].y);
 }
 ctx.lineTo(state.vectorCursor.x, state.vectorCursor.y);
 ctx.stroke();
 ctx.restore();
 } else {
 // Modalità polilinea classica
 ctx.beginPath();
 ctx.moveTo(state.vectorPoints[0].x, state.vectorPoints[0].y);
 for (let i = 1; i < state.vectorPoints.length; i++) {
 ctx.lineTo(state.vectorPoints[i].x, state.vectorPoints[i].y);
 }
 // Linea dal ultimo punto al cursore
 ctx.lineTo(state.vectorCursor.x, state.vectorCursor.y);
 ctx.stroke();
 }
 
 // Disegna i punti campione come cerchi
 state.vectorPoints.forEach((point, index) => {
 ctx.beginPath();
 ctx.arc(point.x, point.y, 6, 0, Math.PI * 2);
 ctx.fillStyle = useSmooth ? '#8b5cf6' : '#10b981'; // Viola per smooth, verde per polilinea
 ctx.fill();
 ctx.strokeStyle = '#ffffff';
 ctx.lineWidth = 2;
 ctx.stroke();
 
 // Numero del punto
 ctx.fillStyle = '#ffffff';
 ctx.font = 'bold 12px Arial';
 ctx.textAlign = 'center';
 ctx.textBaseline = 'middle';
 ctx.fillText(index + 1, point.x, point.y);
 });
 }
 
 // Disegna il cursore attivo
 ctx.beginPath();
 ctx.arc(state.vectorCursor.x, state.vectorCursor.y, 8, 0, Math.PI * 2);
 ctx.fillStyle = useSmooth ? '#8b5cf6' : '#3b82f6'; // Viola per smooth, blu per polilinea
 ctx.fill();
 ctx.strokeStyle = '#ffffff';
 ctx.lineWidth = 2;
 ctx.stroke();
 
 // Croce sul cursore
 ctx.strokeStyle = '#ffffff';
 ctx.lineWidth = 2;
 ctx.beginPath();
 ctx.moveTo(state.vectorCursor.x - 12, state.vectorCursor.y);
 ctx.lineTo(state.vectorCursor.x + 12, state.vectorCursor.y);
 ctx.moveTo(state.vectorCursor.x, state.vectorCursor.y - 12);
 ctx.lineTo(state.vectorCursor.x, state.vectorCursor.y + 12);
 ctx.stroke();
 
 ctx.restore();
 }
 
 function toggleVectorMode() {
 console.log('toggleVectorMode chiamata, stato attuale:', state.vectorDrawMode);
 
 // Se stai disattivando e hai punti non salvati, chiedi conferma
 if (state.vectorDrawMode && state.vectorPoints.length > 0) {
 const numPoints = state.vectorPoints.length;
 const message = numPoints >= 3 
 ? `Hai ${numPoints} punti posizionati. Vuoi salvare la forma prima di uscire?\n\nOK = Salva e chiudi\nAnnulla = Scarta punti`
 : `Hai solo ${numPoints} punti (servono almeno 3 per creare una forma). I punti verranno scartati. Continuare?`;
 
 if (numPoints >= 3) {
 // Se ha abbastanza punti, offri di salvare
 if (confirm(message)) {
 // Salva la forma
 closeVectorShape();
 return; // closeVectorShape già disattiva la modalità
 } else {
 // Utente ha scelto di scartare
 announceGemini('Punti scartati', 'assertive');
 }
 } else {
 // Meno di 3 punti, solo conferma di scartare
 if (!confirm(message)) {
 return; // Annulla l'uscita
 }
 announceGemini('Punti scartati', 'assertive');
 }
 }
 
 // Se stiamo attivando la modalità, mostra il menu di scelta
 if (!state.vectorDrawMode) {
 showVectorDrawTypeMenu();
 return;
 }
 
 // Se stiamo disattivando
 state.vectorDrawMode = false;
 console.log('Nuovo stato vectorDrawMode:', state.vectorDrawMode);
 
 if (state.vectorPoints.length > 0) {
 // Messaggio già dato sopra
 } else {
 announceGemini('Disegno vettoriale disattivato', 'polite');
 }
 state.vectorPoints = [];
 
 // Disabilita il focus sull'area
 const focusArea = document.getElementById('vector-focus-area');
 if (focusArea) {
 focusArea.setAttribute('tabindex', '-1');
 focusArea.blur(); // Rimuovi il focus se c'è
 }
 
 updateVectorUI();
 scheduleRender();
 }
 
 function showVectorDrawTypeMenu() {
 const message = `Scegli il tipo di disegno:
 
1. POLILINEA (punti collegati con linee rette)
 - Ideale per forme geometriche precise
 - Vertici ben definiti
 
2. PENNARELLO SMOOTH (tracciato fluido e continuo)
 - Ideale per disegno artistico
 - Curve morbide e naturali
 
Premi 1 per Polilinea, 2 per Pennarello Smooth, ESC per annullare`;
 
 announceGemini(message, 'assertive');
 
 // Crea un dialog modale accessibile
 const dialog = document.createElement('div');
 dialog.setAttribute('role', 'dialog');
 dialog.setAttribute('aria-modal', 'true');
 dialog.setAttribute('aria-labelledby', 'vector-dialog-title');
 dialog.style.cssText = `
 position: fixed;
 top: 50%;
 left: 50%;
 transform: translate(-50%, -50%);
 background: white;
 padding: 30px;
 border-radius: 12px;
 box-shadow: 0 10px 40px rgba(0,0,0,0.3);
 z-index: 10000;
 max-width: 500px;
 width: 90%;
 `;
 
 dialog.innerHTML = `
 <h2 id="vector-dialog-title" style="margin: 0 0 20px 0; color: var(--primary-color);">Scegli il tipo di disegno</h2>
 <div style="display: flex; flex-direction: column; gap: 15px;">
 <button id="vector-choice-polyline" class="btn btn-primary btn-full" style="padding: 20px; text-align: left;">
 <strong style="font-size: 18px;">1. Polilinea</strong>
 <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">Punti collegati con linee rette - Ideale per forme geometriche</div>
 </button>
 <button id="vector-choice-smooth" class="btn btn-primary btn-full" style="padding: 20px; text-align: left;">
 <strong style="font-size: 18px;">2. Pennarello Smooth</strong>
 <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">Tracciato fluido con curve morbide - Ideale per disegno artistico</div>
 </button>
 <button id="vector-choice-cancel" class="btn btn-secondary btn-full">
 Annulla (ESC)
 </button>
 </div>
 `;
 
 // Overlay scuro
 const overlay = document.createElement('div');
 overlay.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 background: rgba(0,0,0,0.5);
 z-index: 9999;
 `;
 
 document.body.appendChild(overlay);
 document.body.appendChild(dialog);
 
 // Focus sul primo pulsante
 const firstBtn = document.getElementById('vector-choice-polyline');
 setTimeout(() => firstBtn.focus(), 100);
 
 // Flag per prevenire chiamate multiple
 let choiceMade = false;
 
 // Handler per la scelta con cleanup
 function handleChoice(type) {
 // Previeni chiamate multiple
 if (choiceMade) return;
 choiceMade = true;
 
 // Rimuovi tutti i listener PRIMA di procedere
 cleanup();
 
 if (type) {
 state.vectorDrawType = type;
 state.vectorDrawMode = true;
 state.vectorPoints = [];
 state.vectorCursor = { x: canvas.width / 2, y: canvas.height / 2 };
 
 const typeName = type === 'polyline' ? 'Polilinea' : 'Pennarello Smooth';
 announceGemini(`${typeName} selezionato. Disegno vettoriale attivato. Usa le frecce per muovere il cursore, Invio per posizionare punti, O per tracciato aperto, C per chiudere la forma`, 'assertive');
 
 // Abilita il focus sull'area
 const focusArea = document.getElementById('vector-focus-area');
 if (focusArea) {
 focusArea.setAttribute('tabindex', '0');
 console.log(' tabindex impostato su 0');
 }
 
 // Dai focus all'area di disegno per NVDA/JAWS
 setTimeout(() => {
 if (focusArea) {
 focusArea.focus();
 console.log(' Focus forzato sull\'area di disegno');
 console.log(' Elemento attivo:', document.activeElement);
 console.log(' È l\'area corretta?', document.activeElement === focusArea);
 announceGemini('Area di disegno attiva. Ora puoi usare le frecce per muovere il cursore.', 'polite');
 }
 }, 150);
 
 updateVectorUI();
 scheduleRender();
 } else {
 announceGemini('Selezione annullata', 'polite');
 }
 }
 
 // Funzione cleanup per rimuovere listener e elementi
 function cleanup() {
 // Rimuovi listener dai pulsanti
 const polyBtn = document.getElementById('vector-choice-polyline');
 const smoothBtn = document.getElementById('vector-choice-smooth');
 const cancelBtn = document.getElementById('vector-choice-cancel');
 
 if (polyBtn) polyBtn.replaceWith(polyBtn.cloneNode(true));
 if (smoothBtn) smoothBtn.replaceWith(smoothBtn.cloneNode(true));
 if (cancelBtn) cancelBtn.replaceWith(cancelBtn.cloneNode(true));
 
 // Rimuovi listener da dialog e overlay
 const newDialog = dialog.cloneNode(true);
 const newOverlay = overlay.cloneNode(true);
 dialog.replaceWith(newDialog);
 overlay.replaceWith(newOverlay);
 
 // Rimuovi elementi dal DOM
 setTimeout(() => {
 if (newOverlay.parentNode) newOverlay.remove();
 if (newDialog.parentNode) newDialog.remove();
 }, 10);
 }
 
 // Event listeners con riferimenti per cleanup
 const polylineHandler = () => handleChoice('polyline');
 const smoothHandler = () => handleChoice('smooth');
 const cancelHandler = () => handleChoice(null);
 const keyHandler = (e) => {
 if (e.key === '1') {
 e.preventDefault();
 handleChoice('polyline');
 } else if (e.key === '2') {
 e.preventDefault();
 handleChoice('smooth');
 } else if (e.key === 'Escape') {
 e.preventDefault();
 handleChoice(null);
 }
 };
 const overlayClickHandler = () => handleChoice(null);
 
 document.getElementById('vector-choice-polyline').addEventListener('click', polylineHandler);
 document.getElementById('vector-choice-smooth').addEventListener('click', smoothHandler);
 document.getElementById('vector-choice-cancel').addEventListener('click', cancelHandler);
 dialog.addEventListener('keydown', keyHandler);
 overlay.addEventListener('click', overlayClickHandler);
 }
 
 // Esponi le funzioni per il listener globale
 window.addVectorPoint = addVectorPoint;
 window.closeVectorShape = closeVectorShape;
 window.scheduleRender = scheduleRender;
 window.announce = announce;
 window.canvas = canvas;
 window.state = state;
 
 // Esponi le funzioni di rendering per la conversione layer→immagine
 window.renderShape = renderShape;
 window.renderText = renderText;
 window.renderPolygon = renderPolygon;
 
 // ESPORTAZIONI FUNZIONI CRITICHE
 window.addLayer = addLayer;
 window.render = render;
 window.updateUI = updateUI;
 window.updateLayerList = updateLayerList;
 window.announceGemini = announceGemini;
 
 function addVectorPoint() {
 if (!state.vectorDrawMode) return;
 
 state.vectorPoints.push({ x: state.vectorCursor.x, y: state.vectorCursor.y });
 updateVectorUI();
 scheduleRender();
 
 // FEEDBACK AUDIO MIGLIORATO: Pattern diversi per smooth/polyline
 const isSmooth = state.vectorDrawType === 'smooth';
 const numPoints = state.vectorPoints.length;
 
 if (isSmooth) {
 // Pennarello smooth: tono ascendente graduale (più melodioso)
 // Clamp la frequenza a range udibile piacevole: 400-800Hz
 const baseFreq = 400;
 const maxFreq = 800;
 const freq = baseFreq + Math.min((numPoints - 1) * 40, maxFreq - baseFreq);
 playBeep(freq, 120); // Leggermente più lungo per smoothness
 } else {
 // Polilinea: toni alternati (più meccanico/preciso)
 const freq = numPoints % 2 === 0 ? 550 : 440; // Alterna tra due toni
 playBeep(freq, 80); // Più corto e secco
 }
 
 announceGemini(`Punto ${state.vectorPoints.length} posizionato a X: ${Math.round(state.vectorCursor.x)}, Y: ${Math.round(state.vectorCursor.y)}`, 'assertive');
 }
 
 // ---- Funzioni per Smooth Curve (Catmull-Rom Splines) ----
 
 /**
 * Calcola punti intermedi per curve smooth usando Catmull-Rom splines
 * @param {Array} points - Array di punti {x, y}
 * @param {number} tension - Intensità dello smoothing (0-1, default 0.5)
 * @param {boolean} closed - Se true, la curva è chiusa
 * @returns {Array} - Array di punti che formano la curva smooth
 */
 function calculateSmoothCurve(points, tension = 0.5, closed = false) {
 if (points.length < 2) return points;
 
 // VALIDAZIONE: Assicura che tension sia nel range valido
 tension = Math.max(0, Math.min(1, tension));
 if (isNaN(tension)) {
 console.warn('️ Tensione smooth non valida, uso default 0.5');
 tension = 0.5;
 }
 
 const smoothPoints = [];
 
 // OTTIMIZZAZIONE: Adatta numSegments al numero di punti
 // Pochi punti = più dettaglio, molti punti = meno dettaglio per performance
 let numSegments;
 if (points.length <= 10) {
 numSegments = 16; // Massimo dettaglio per pochi punti
 } else if (points.length <= 30) {
 numSegments = 12; // Medio dettaglio
 } else if (points.length <= 50) {
 numSegments = 8; // Dettaglio ridotto
 } else {
 numSegments = 6; // Minimo dettaglio per molti punti
 }
 
 // Se la curva è chiusa, aggiungi punti di wrap-around per continuità
 const pts = closed ? [points[points.length - 1], ...points, points[0], points[1]] : points;
 
 for (let i = 0; i < pts.length - 3; i++) {
 const p0 = pts[i];
 const p1 = pts[i + 1];
 const p2 = pts[i + 2];
 const p3 = pts[i + 3];
 
 for (let t = 0; t < numSegments; t++) {
 const t_norm = t / numSegments;
 const point = catmullRomInterpolate(p0, p1, p2, p3, t_norm, tension);
 smoothPoints.push(point);
 }
 }
 
 // Aggiungi l'ultimo punto
 if (!closed && points.length > 0) {
 smoothPoints.push(points[points.length - 1]);
 }
 
 return smoothPoints;
 }
 
 /**
 * Interpolazione Catmull-Rom tra 4 punti di controllo
 */
 function catmullRomInterpolate(p0, p1, p2, p3, t, tension) {
 const t2 = t * t;
 const t3 = t2 * t;
 
 const v0 = (p2.x - p0.x) * tension;
 const v1 = (p3.x - p1.x) * tension;
 
 const x = (2 * p1.x - 2 * p2.x + v0 + v1) * t3 +
 (-3 * p1.x + 3 * p2.x - 2 * v0 - v1) * t2 +
 v0 * t + p1.x;
 
 const w0 = (p2.y - p0.y) * tension;
 const w1 = (p3.y - p1.y) * tension;
 
 const y = (2 * p1.y - 2 * p2.y + w0 + w1) * t3 +
 (-3 * p1.y + 3 * p2.y - 2 * w0 - w1) * t2 +
 w0 * t + p1.y;
 
 return { x, y };
 }
 
 function closeVectorShape(shouldClose = true) {
 if (!state.vectorDrawMode) return;
 
 const minPoints = shouldClose ? 3 : 2;
 if (state.vectorPoints.length < minPoints) {
 announceGemini(`Servono almeno ${minPoints} punti per ${shouldClose ? 'chiudere una forma' : 'creare un tracciato aperto'}`, 'assertive');
 return;
 }
 
 // Determina se usare smooth o polyline
 const useSmooth = state.vectorDrawType === 'smooth';
 
 // Crea il layer poligono
 let points = [...state.vectorPoints];
 
 // Se è smooth, calcola i punti interpolati CON ARIA-BUSY E PERFORMANCE TRACKING
 if (useSmooth) {
 // Imposta aria-busy per screen reader
 canvas.setAttribute('aria-busy', 'true');
 srAssert.textContent = 'Generazione curva smooth in corso...';
 
 // Usa setTimeout per permettere al browser di aggiornare l'UI
 setTimeout(() => {
 const perfStart = performance.now();
 points = calculateSmoothCurve(points, state.vectorSmoothIntensity, shouldClose);
 const perfEnd = performance.now();
 const duration = perfEnd - perfStart;
 
 console.log(` Smooth curve generata: ${state.vectorPoints.length} input → ${points.length} output in ${duration.toFixed(2)}ms`);
 
 // Rimuovi aria-busy
 canvas.setAttribute('aria-busy', 'false');
 
 // Avvisa se la generazione è lenta
 if (duration > 100) {
 console.warn(`️ Generazione smooth lenta! Considera di ridurre i punti o il dettaglio.`);
 }
 
 // Continua con la creazione del layer
 finishClosingShape(points, shouldClose, useSmooth);
 }, 10);
 
 return; // Esci e lascia che il setTimeout completi
 }
 
 // Se non è smooth, procedi direttamente
 finishClosingShape(points, shouldClose, useSmooth);
 }
 
 // Helper function per completare la chiusura della forma
 function finishClosingShape(points, shouldClose, useSmooth) {
 
 // Calcola bounding box
 let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
 points.forEach(p => {
 minX = Math.min(minX, p.x);
 minY = Math.min(minY, p.y);
 maxX = Math.max(maxX, p.x);
 maxY = Math.max(maxY, p.y);
 });
 
 const width = maxX - minX;
 const height = maxY - minY;
 
 // Normalizza punti rispetto al bounding box
 const normalizedPoints = points.map(p => ({
 x: p.x - minX,
 y: p.y - minY
 }));
 
 const shapeType = shouldClose ? 'forma' : 'tracciato';
 const shapeName = useSmooth 
 ? `Pennarello Smooth ${shapeType} (${state.vectorPoints.length} campioni)` 
 : `Poligono ${shapeType} (${state.vectorPoints.length} punti)`;
 
 const layer = {
 type: 'polygon',
 name: shapeName,
 x: minX,
 y: minY,
 width: width,
 height: height,
 color: state.vectorFillColor,
 useStroke: true,
 stroke: {
 color: state.vectorStrokeColor,
 width: state.vectorStrokeWidth
 },
 polygonPoints: normalizedPoints,
 closePath: shouldClose, // Salva se è chiuso o aperto
 isSmooth: useSmooth, // Salva il tipo per riferimento futuro
 rotation: 0,
 opacity: 100,
 locked: false
 };
 
 addLayer(layer);
 
 // Resetta modalità
 state.vectorDrawMode = false;
 state.vectorPoints = [];
 updateVectorUI();
 
 const typeDesc = useSmooth ? 'tracciato smooth' : 'poligono';
 const closeDesc = shouldClose ? 'chiuso' : 'aperto';
 announceGemini(`${shapeName} creato! ${typeDesc} ${closeDesc} con ${state.vectorPoints.length > 0 ? state.vectorPoints.length : points.length} punti.`, 'assertive');
 }
 
 function updateVectorUI() {
 const statusIndicator = document.getElementById('vector-status-indicator');
 const statusText = document.getElementById('vector-status-text');
 const toggleBtn = document.getElementById('btn-toggle-vector');
 const activeControls = document.getElementById('vector-active-controls');
 const pointsInfo = document.getElementById('vector-points-info');
 const pointsCount = document.getElementById('vector-points-count');
 
 // Safety check - se gli elementi non esistono ancora, riprova dopo
 if (!statusIndicator || !statusText || !toggleBtn || !activeControls || !pointsInfo || !pointsCount) {
 console.warn('updateVectorUI: Alcuni elementi non trovati, riprovo tra 100ms');
 setTimeout(updateVectorUI, 100);
 return;
 }
 
 if (state.vectorDrawMode) {
 const drawTypeName = state.vectorDrawType === 'smooth' ? 'Pennarello Smooth' : 'Polilinea';
 const colorIndicator = state.vectorDrawType === 'smooth' ? '#8b5cf6' : '#10b981'; // Viola per smooth, verde per polilinea
 
 statusIndicator.style.backgroundColor = colorIndicator;
 statusText.textContent = `${drawTypeName} attivo`;
 toggleBtn.textContent = 'Disattiva Disegno Vettoriale (Ctrl+P)';
 toggleBtn.classList.remove('btn-primary');
 toggleBtn.classList.add('btn-danger');
 activeControls.style.display = 'block';
 pointsInfo.style.display = 'block';
 
 const pointsLabel = state.vectorDrawType === 'smooth' ? 'campion' : 'punt';
 const pointsSuffix = state.vectorPoints.length === 1 ? 'e' : 'i';
 
 if (state.vectorPoints.length === 0) {
 pointsCount.textContent = 'Nessun punto. Usa Invio per posizionare.';
 } else if (state.vectorPoints.length === 1) {
 pointsCount.textContent = `1 ${pointsLabel}e posizionato. Servono almeno 2 punti per O (aperto) o 3 per C (chiuso).`;
 } else if (state.vectorPoints.length === 2) {
 pointsCount.textContent = `2 ${pointsLabel}i posizionati. Premi O per tracciato aperto o aggiungi punti per C (chiuso).`;
 } else {
 pointsCount.textContent = `${state.vectorPoints.length} ${pointsLabel}i posizionati. Premi O (aperto) o C (chiuso).`;
 }
 } else {
 statusIndicator.style.backgroundColor = 'var(--secondary-color)'; // Grigio
 statusText.textContent = 'Modalità disattivata';
 toggleBtn.textContent = 'Attiva Disegno Vettoriale (Ctrl+P)';
 toggleBtn.classList.remove('btn-danger');
 toggleBtn.classList.add('btn-primary');
 activeControls.style.display = 'none';
 pointsInfo.style.display = 'none';
 }
 }
 
 // ---- Funzioni Crop ----
 
 function startCrop() {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image') {
 announceGemini('Seleziona un\'immagine per ritagliarla', 'polite');
 return;
 }
 
 state.cropMode = true;
 state.cropLayer = layer;
 state.cropRect = {
 x: layer.x,
 y: layer.y,
 width: layer.width,
 height: layer.height
 };
 
 announceGemini('Modalità ritaglio attivata. Regola i bordi e premi Invio per applicare, Esc per annullare.', 'assertive');
 scheduleRender();
 }
 
 function applyCrop() {
 if (!state.cropMode || !state.cropLayer || !state.cropRect) return;
 
 const layer = state.cropLayer;
 const crop = state.cropRect;
 
 // Crea un canvas temporaneo per il ritaglio
 const tempCanvas = document.createElement('canvas');
 // Cleanup will be automatic via garbage collection
 tempCanvas.dataset.temporary = 'true';
 const tempCtx = tempCanvas.getContext('2d');
 
 // Calcola le coordinate relative all'immagine originale
 const sx = (crop.x - layer.x) * (layer.imageElement.width / layer.width);
 const sy = (crop.y - layer.y) * (layer.imageElement.height / layer.height);
 const sw = crop.width * (layer.imageElement.width / layer.width);
 const sh = crop.height * (layer.imageElement.height / layer.height);
 
 tempCanvas.width = Math.max(1, Math.min(4096, sw));
 tempCanvas.height = sh;
 tempCtx.drawImage(layer.imageElement, sx, sy, sw, sh, 0, 0, sw, sh);
 
 // Aggiorna il layer
 const newImg = new Image();
 newImg.onload = () => {
 layer.imageElement = newImg;
 layer.imageData = tempCanvas.toDataURL();
 layer.x = crop.x;
 layer.y = crop.y;
 layer.width = crop.width;
 layer.height = crop.height;
 
 cancelCrop();
 saveState('Immagine ritagliata');
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announceGemini('Immagine ritagliata con successo', 'assertive');
 };
 newImg.onerror = () => {
 announceGemini('Errore durante il ritaglio dell\'immagine', 'assertive');
 cancelCrop();
 };
 newImg.src = tempCanvas.toDataURL();
 }
 
 function cancelCrop() {
 state.cropMode = false;
 state.cropRect = null;
 state.cropLayer = null;
 scheduleRender();
 announceGemini('Ritaglio annullato', 'polite');
 }
 
 // ---- Aggiornamento UI ----
 
 // Nasconde/Mostra tutti i pannelli di modifica
 function hideAllEditControls() {
 const panels = [
 'layer-name-controls', 'text-edit-controls', 'font-controls', 'text-spacing-controls', 'text-style-controls',
 'text-align-controls', 'color-controls', 'gradient-panel', 'stroke-panel', 
 'transform-controls', 'corner-radius-group', 'rotation-controls', 'flip-controls',
 'crop-group', 'opacity-controls', 'mask-controls', 'filters-panel',
 'image-transform-controls', 'image-crop-controls', 'ai-extract-controls',
 'ai-ocr-controls', 'ai-rembg-controls', 'ai-upscale-controls'
 ];
 panels.forEach(id => {
 const el = document.getElementById(id);
 if(el) el.style.display = 'none';
 });
 // v44.2: Nascondi anche pulsante Zona Sicura
 const btnSafe = document.getElementById("btn-center-safe");
 if (btnSafe) btnSafe.style.display = "none";
 document.getElementById('edit-description').textContent = 'Seleziona un livello per modificarlo';
 }
 
 // ═══════════════════════════════════════════════════════════════
 // MAPPA COLORI GLOBALE - Converte nomi in codici HEX
 // ═══════════════════════════════════════════════════════════════
 const COLOR_MAP = {
 // Nomi inglesi (mantenuti per retrocompatibilità)
 'white': '#ffffff',
 'black': '#000000',
 'red': '#ff0000',
 'green': '#00ff00',
 'blue': '#0000ff',
 'yellow': '#ffff00',
 'magenta': '#ff00ff',
 'cyan': '#00ffff',
 'orange': '#ffa500',
 'purple': '#800080',
 'pink': '#ffc0cb',
 'gray': '#808080',
 'grey': '#808080',
 'brown': '#a52a2a',
 'gold': '#ffd700',
 'silver': '#c0c0c0',
 'darkblue': '#1e40af',
 'lightblue': '#3b82f6',
 'transparent': 'transparent',
 // Nomi italiani (per accessibilità NVDA)
 'Bianco': '#ffffff',
 'Nero': '#000000',
 'Rosso': '#ff0000',
 'Verde': '#00ff00',
 'Blu': '#0000ff',
 'Giallo': '#ffff00',
 'Magenta': '#ff00ff',
 'Ciano': '#00ffff',
 'Arancione': '#ffa500',
 'Viola': '#800080',
 'Rosa': '#ffc0cb',
 'Grigio': '#808080',
 'Marrone': '#a52a2a',
 'Trasparente': 'transparent',
 // Alias per gestire anche "custom"
 'custom': null,
 'Personalizzato': null
 };
 
 // Funzione helper globale per ottenere il codice HEX da un nome o value
 function getColorHex(value) {
 // Se è già un codice HEX, ritorna così com'è
 if (value && value.startsWith('#')) return value;
 // Se è nella mappa, ritorna il valore mappato
 if (COLOR_MAP[value]) return COLOR_MAP[value];
 // Altrimenti ritorna il valore originale
 return value;
 }
 
 // Funzione inversa globale: converte HEX in nome (per popolare i select)
 function getColorName(hexValue) {
 // Se è transparent, ritorna così
 if (hexValue === 'transparent') return 'transparent';
 // Se non è un HEX, ritorna così
 if (!hexValue || !hexValue.startsWith('#')) return hexValue;
 // Cerca nella mappa il nome corrispondente
 for (const [name, hex] of Object.entries(COLOR_MAP)) {
 if (hex.toLowerCase() === hexValue.toLowerCase()) {
 return name;
 }
 }
 // Se non trovato, ritorna 'custom' per permettere uso colori personalizzati
 return 'custom';
 }
 
 // ═══════════════════════════════════════════════════════════════
 // FIX: updateLayerColorPreview - Funzione globale per anteprima colore
 // ═══════════════════════════════════════════════════════════════
 function updateLayerColorPreview(color) {
 const layerColorPreview = document.getElementById('layer-color-preview');
 if (layerColorPreview) {
 layerColorPreview.style.background = color;
 }
 }

 function updateUI() {
 const layer = getSelectedLayer();
 updateLayerList(); // Aggiorna sempre la lista
 
 if (!layer) {
 hideAllEditControls();
 return;
 }

 // FLAG: Disabilita annunci durante aggiornamento programmatico
 window._updatingProgrammatically = true;

 // Mostra controlli comuni
 document.getElementById('edit-description').textContent = 'Modificando: ' + layer.name;
 
 // Rimuovi hidden e mostra i controlli
 const showControl = (id) => {
 const el = document.getElementById(id);
 if (el) {
 el.style.display = 'block';
 el.classList.remove('hidden');
 }
 };
 
 showControl('layer-name-controls');
 showControl('color-controls');
 showControl('gradient-panel');
 showControl('stroke-panel');
 showControl('transform-controls');
 showControl('rotation-controls');
 showControl('flip-controls');
 showControl('opacity-controls');
 
 document.getElementById('layer-name-input').value = layer.name;
 
 // Popola controlli comuni - aggiornato per nuovo sistema colore
 const layerColor = layer.color || '#000000';
 // Converte HEX in nome per il preset
 const colorName = getColorName(layerColor);
 if (colorName !== 'custom') {
 layerColorPreset.value = colorName;
 layerColorCustomSection.style.display = 'none';
 } else {
 layerColorPreset.value = 'custom';
 layerColorCustomSection.style.display = 'block';
 layerColorHex.value = layerColor;
 const rgb = hexToRgb(layerColor);
 if (rgb) {
 layerColorR.value = rgb.r;
 layerColorG.value = rgb.g;
 layerColorB.value = rgb.b;
 }
 }
 updateLayerColorPreview(layerColor);
 
 document.getElementById('use-gradient').checked = layer.useGradient || false;
 const gradientControls = document.getElementById('gradient-controls');
 if (layer.useGradient) {
 gradientControls.classList.remove('hidden');
 } else {
 gradientControls.classList.add('hidden');
 }
 if (layer.gradient) {
 document.getElementById('gradient-type').value = layer.gradient.type;
 document.getElementById('gradient-color1').value = layer.gradient.color1;
 document.getElementById('gradient-color2').value = layer.gradient.color2;
 document.getElementById('gradient-color1-hex').value = layer.gradient.color1;
 document.getElementById('gradient-color2-hex').value = layer.gradient.color2;
 
 // Sincronizza anche i campi RGB
 syncHexToRgb(layer.gradient.color1, 'gradient-color1');
 syncHexToRgb(layer.gradient.color2, 'gradient-color2');
 
 document.getElementById('gradient-angle').value = layer.gradient.angle;
 document.getElementById('gradient-angle-value').textContent = layer.gradient.angle + '°';
 updateGradientPreview();
 }
 document.getElementById('use-stroke').checked = layer.useStroke || false;
 const strokeControls = document.getElementById('stroke-controls');
 if (layer.useStroke) {
 strokeControls.classList.remove('hidden');
 } else {
 strokeControls.classList.add('hidden');
 }
 if (layer.stroke) {
 const colorName = getColorName(layer.stroke.color);
 
 // Se il colore non è nei preset, usa "custom"
 if (colorName === layer.stroke.color) {
 // Il colore è custom (getColorName ha restituito l'HEX)
 document.getElementById('sc').value = 'custom';
 document.getElementById('stroke-color-custom-section').style.display = 'block';
 document.getElementById('stroke-color-hex').value = layer.stroke.color;
 document.getElementById('stroke-color-picker').value = layer.stroke.color;
 document.getElementById('stroke-color-preview').style.background = layer.stroke.color;
 syncHexToRgb(layer.stroke.color, 'stroke-color');
 } else {
 // Il colore è un preset
 document.getElementById('sc').value = colorName;
 document.getElementById('stroke-color-custom-section').style.display = 'none';
 }
 
 document.getElementById('stroke-width').value = layer.stroke.width;
 }
 document.getElementById('pos-x').value = Math.round(layer.x);
 document.getElementById('pos-y').value = Math.round(layer.y);
 document.getElementById('width').value = Math.round(layer.width);
 document.getElementById('height').value = Math.round(layer.height);
 document.getElementById('rotation').value = layer.rotation;
 document.getElementById('rotation-value').textContent = layer.rotation + '°';
 document.getElementById('opacity').value = layer.opacity ?? 100;
 document.getElementById('opacity-value').textContent = (layer.opacity ?? 100) + '%';
 
 // Popola Drop Shadow (Pannello 4)
 if (layer.dropShadow) {
 document.getElementById('shadow-enabled').checked = layer.dropShadow.enabled;
 document.getElementById('shadow-controls').style.display = layer.dropShadow.enabled ? 'block' : 'none';
 
 const colorName = getColorName(layer.dropShadow.color);
 
 // Se il colore non è nei preset, usa "custom"
 if (colorName === layer.dropShadow.color) {
 // Il colore è custom (getColorName ha restituito l'HEX)
 document.getElementById('shc').value = 'custom';
 document.getElementById('shadow-color-custom-section').style.display = 'block';
 document.getElementById('shadow-color-hex').value = layer.dropShadow.color;
 document.getElementById('shadow-color-picker').value = layer.dropShadow.color;
 document.getElementById('shadow-color-preview').style.background = layer.dropShadow.color;
 syncHexToRgb(layer.dropShadow.color, 'shadow-color');
 } else {
 // Il colore è un preset
 document.getElementById('shc').value = colorName;
 document.getElementById('shadow-color-custom-section').style.display = 'none';
 }
 
 document.getElementById('shadow-blur').value = layer.dropShadow.blur;
 document.getElementById('shadow-blur-value').textContent = layer.dropShadow.blur + ' px';
 document.getElementById('shadow-x').value = layer.dropShadow.x;
 document.getElementById('shadow-x-value').textContent = layer.dropShadow.x + ' px';
 document.getElementById('shadow-y').value = layer.dropShadow.y;
 document.getElementById('shadow-y-value').textContent = layer.dropShadow.y + ' px';
 }
 document.getElementById('blend-mode').value = layer.blendMode || 'source-over';


 // Controlli specifici per TIPO
 if (layer.type === 'text') {
 document.getElementById('text-edit-controls').style.display = 'block';
 document.getElementById('font-controls').style.display = 'block';
 document.getElementById('text-spacing-controls').style.display = 'block';
 document.getElementById('text-style-controls').style.display = 'block';
 document.getElementById('text-align-controls').style.display = 'block';
 // Nascondi quelli non di testo
 document.getElementById('corner-radius-group').style.display = 'none';
 document.getElementById('crop-group').style.display = 'none';
 document.getElementById('mask-controls').style.display = 'none';
 document.getElementById('mask-clipping-controls').style.display = 'none';
 document.getElementById('filters-panel').style.display = 'none';
 document.getElementById('image-transform-controls').style.display = 'none';
 document.getElementById('image-crop-controls').style.display = 'none';

 // Popola controlli testo
 document.getElementById('text-edit').value = layer.text;
 document.getElementById('ff').value = layer.fontFamily;
 document.getElementById('font-size').value = layer.fontSize;
 document.getElementById('fw').value = layer.fontWeight || '400';
 document.getElementById('letter-spacing').value = layer.letterSpacing || 0;
 document.getElementById('letter-spacing-value').textContent = (layer.letterSpacing || 0) + ' px';
 document.getElementById('line-height').value = layer.lineHeight || 1.2;
 document.getElementById('line-height-value').textContent = (layer.lineHeight || 1.2);
 updateTextPreview();

 } else if (layer.type === 'shape') {
 // Nascondi quelli di testo e immagine
 const hideControl = (id) => {
 const el = document.getElementById(id);
 if (el) {
 el.style.display = 'none';
 el.classList.add('hidden');
 }
 };
 
 hideControl('text-edit-controls');
 hideControl('font-controls');
 hideControl('text-spacing-controls');
 hideControl('text-style-controls');
 hideControl('text-align-controls');
 hideControl('crop-group');
 hideControl('mask-controls');
 hideControl('mask-clipping-controls');
 hideControl('filters-panel');
 hideControl('image-transform-controls');
 hideControl('image-crop-controls');
 
 // Mostra corner-radius solo per rettangoli
 if (layer.shape === 'rect') {
 const cornerGroup = document.getElementById('corner-radius-group');
 if (cornerGroup) {
 cornerGroup.style.display = 'block';
 cornerGroup.classList.remove('hidden');
 }
 document.getElementById('corner-radius').value = layer.cornerRadius || 0;
 document.getElementById('corner-radius-value').textContent = (layer.cornerRadius || 0) + ' px';
 } else {
 const cornerGroup = document.getElementById('corner-radius-group');
 if (cornerGroup) {
 cornerGroup.style.display = 'none';
 cornerGroup.classList.add('hidden');
 }
 }

 } else if (layer.type === 'image') {
 // Nascondi quelli di testo e forme
 document.getElementById('text-edit-controls').style.display = 'none';
 document.getElementById('font-controls').style.display = 'none';
 document.getElementById('text-spacing-controls').style.display = 'none';
 document.getElementById('text-style-controls').style.display = 'none';
 document.getElementById('text-align-controls').style.display = 'none';
 document.getElementById('corner-radius-group').style.display = 'none';
 
 // Mostra controlli immagine
 document.getElementById('image-transform-controls').style.display = 'block';
 document.getElementById('image-crop-controls').style.display = 'block';
 document.getElementById('crop-group').style.display = 'block';
 
 // v44.2: Mostra "Centra in Zona Sicura" solo se NON è template custom
 const btnCenterSafe = document.getElementById("btn-center-safe");
 if (btnCenterSafe) {
 // btnCenterSafe.style.display = (state.currentTemplate !== "custom") ? "block" : "none"; // DISABLED: pulsante social sempre visibile

 }
 document.getElementById('mask-controls').style.display = 'block';
 document.getElementById('mask-clipping-controls').style.display = 'block';
 document.getElementById('filters-panel').style.display = 'block';
 document.getElementById('ai-extract-controls').style.display = 'block';
 document.getElementById('ai-ocr-controls').style.display = 'block';
 document.getElementById('ai-rembg-controls').style.display = 'block';
 document.getElementById('ai-upscale-controls').style.display = 'block';
 
 // Popola maschera
 if (layer.maskShape) {
 document.getElementById('mask-shape').value = layer.maskShape;
 } else {
 document.getElementById('mask-shape').value = 'none';
 }
 
 // Popola filtri
 if (layer.filters) {
 document.getElementById('filter-preset').value = layer.filters.preset || 'none';
 document.getElementById('filter-brightness').value = layer.filters.brightness || 0;
 document.getElementById('filter-brightness-value').textContent = layer.filters.brightness || 0;
 document.getElementById('filter-contrast').value = layer.filters.contrast || 0;
 document.getElementById('filter-contrast-value').textContent = layer.filters.contrast || 0;
 document.getElementById('filter-saturation').value = layer.filters.saturation || 0;
 document.getElementById('filter-saturation-value').textContent = layer.filters.saturation || 0;
 document.getElementById('filter-hue').value = layer.filters.hue || 0;
 document.getElementById('filter-hue-value').textContent = (layer.filters.hue || 0) + '°';
 document.getElementById('filter-sepia').value = layer.filters.sepia || 0;
 document.getElementById('filter-sepia-value').textContent = (layer.filters.sepia || 0) + '%';
 document.getElementById('filter-blur').value = layer.filters.blur || 0;
 document.getElementById('filter-blur-value').textContent = (layer.filters.blur || 0) + ' px';
 }
 document.getElementById('mask-shape').value = layer.mask || 'none';
 
 } else if (layer.type === 'polygon') {
 // Nascondi tutti i controlli specifici
 document.getElementById('text-edit-controls').style.display = 'none';
 document.getElementById('font-controls').style.display = 'none';
 document.getElementById('text-spacing-controls').style.display = 'none';
 document.getElementById('text-style-controls').style.display = 'none';
 document.getElementById('text-align-controls').style.display = 'none';
 document.getElementById('corner-radius-group').style.display = 'none';
 document.getElementById('crop-group').style.display = 'none';
 document.getElementById('mask-controls').style.display = 'none';
 document.getElementById('mask-clipping-controls').style.display = 'none';
 document.getElementById('filters-panel').style.display = 'none';
 }
 
 // Resetta flag dopo aggiornamento
 setTimeout(() => { window._updatingProgrammatically = false; }, 50);
 }
 
 function updateLayerList() {
 const list = document.getElementById('layer-list');
 if (!list) {
 logError('updateLayerList', new Error('layer-list element non trovato'), 'Elemento DOM mancante');
 return;
 }
 
 // Performance: usa DocumentFragment per ridurre reflow
 const fragment = document.createDocumentFragment();
 
 // PERFORMANCE: Limita visualizzazione se troppi layer
 const MAX_VISIBLE_LAYERS = 100;
 const layersToShow = state.layers.length > MAX_VISIBLE_LAYERS 
 ? state.layers.slice(-MAX_VISIBLE_LAYERS) 
 : state.layers;
 
 if (state.layers.length > MAX_VISIBLE_LAYERS) {
 const warning = document.createElement('div');
 warning.style.cssText = 'padding: 8px; background: #fef3c7; border-left: 3px solid #f59e0b; margin-bottom: 8px; font-size: 12px;';
 warning.textContent = `️ Visualizzati ultimi ${MAX_VISIBLE_LAYERS} di ${state.layers.length} layer per performance`;
 warning.setAttribute('role', 'alert');
 fragment.appendChild(warning);
 }
 
 // Inverti ordine per mostrare i top layer in alto
 [...layersToShow].reverse().forEach(layer => {
 const item = document.createElement('div');
 item.className = 'layer-item';
 if (state.selectedIds.includes(layer.id)) {
 item.classList.add('selected');
 }
 if (layer.locked) {
 item.classList.add('locked');
 }
 
 // Accessibilità
 item.setAttribute('role', 'listitem');
 item.setAttribute('tabindex', '0');
 const visibleStatus = (layer.visible !== false) ? 'visibile' : 'nascosto';
 const lockStatus = layer.locked ? 'bloccato' : 'sbloccato';
 item.setAttribute('aria-label', 
 `Livello ${layer.name}, tipo ${layer.type}, ${visibleStatus}, ${lockStatus}`);
 
 // Click handler con multiselect support
 const handleSelect = (e) => {
 if (!layer.locked) {
 const multiselect = e.ctrlKey || e.metaKey; // Support Mac Cmd
 toggleLayerSelection(layer.id, multiselect);
 } else {
 announceGemini(`Il livello ${layer.name} è bloccato`, 'polite');
 }
 };
 
 item.onclick = handleSelect;
 
 // Keyboard navigation
 item.onkeydown = (e) => {
 if (e.key === 'Enter' || e.key === ' ') {
 e.preventDefault();
 handleSelect(e);
 }
 };
 
 const icon = document.createElement('div');
 icon.className = 'layer-icon';
 icon.style.backgroundColor = layer.type === 'text' ? 'var(--primary-color)' : 
 layer.type === 'shape' || layer.type === 'polygon' ? 'var(--success-color)' : 
 'var(--info-color)';
 icon.textContent = layer.type === 'text' ? 'T' : 
 layer.type === 'shape' ? '■' : 
 layer.type === 'polygon' ? '⬡' : '';
 icon.setAttribute('aria-hidden', 'true'); // Decorativo
 
 const info = document.createElement('div');
 info.className = 'layer-info';
 
 const name = document.createElement('div');
 name.className = 'layer-name';
 // Truncate long names per performance
 const displayName = layer.name.length > 30 ? layer.name.substring(0, 27) + '...' : layer.name;
 name.textContent = displayName + (layer.locked ? ' ' : '');
 
 const type = document.createElement('div');
 type.className = 'layer-type';
 type.textContent = layer.type === 'text' ? 'Testo' : 
 layer.type === 'shape' ? 'Forma' : 
 layer.type === 'polygon' ? 'Poligono' : 'Immagine';
 
 info.appendChild(name);
 info.appendChild(type);
 item.appendChild(icon);
 item.appendChild(info);
 fragment.appendChild(item);
 });
 
 // Update DOM once (performance)
 list.innerHTML = '';
 list.appendChild(fragment);
 
 if (state.layers.length === 0) {
 list.innerHTML = '<p style="text-align:center; color:var(--text-secondary); padding:20px;">Nessun livello</p>';
 }
 }
 
 function updateTextPreview() {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'text') return;
 
 const preview = document.getElementById('text-preview');
 preview.textContent = layer.text || 'Anteprima';
 preview.style.fontFamily = layer.fontFamily;
 preview.style.fontSize = Math.min(layer.fontSize, 32) + 'px';
 preview.style.fontWeight = layer.fontWeight || '400';
 preview.style.color = layer.color;
 preview.style.fontStyle = layer.italic ? 'italic' : 'normal';
 preview.style.textDecoration = layer.underline ? 'underline' : layer.lineThrough ? 'line-through' : 'none';
 preview.style.textAlign = layer.textAlign || 'left';
 }
 
 function updateGradientPreview() {
 const layer = getSelectedLayer();
 if (!layer || !layer.gradient) return;
 
 const preview = document.getElementById('gradient-preview');
 const g = layer.gradient;
 
 if (g.type === 'linear') {
 preview.style.background = `linear-gradient(${g.angle}deg, ${g.color1}, ${g.color2})`;
 } else {
 preview.style.background = `radial-gradient(circle, ${g.color1}, ${g.color2})`;
 }
 }
 
 function updateColorPalette() {
 const palette = document.getElementById('color-palette');
 palette.innerHTML = '';
 
 state.colorPalette.forEach((color, index) => {
 const swatch = document.createElement('div');
 swatch.className = 'color-swatch';
 swatch.style.backgroundColor = color;
 swatch.title = color;
 swatch.setAttribute('role', 'button');
 swatch.setAttribute('aria-label', `Colore ${color}`);
 swatch.onclick = () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.color = color;
 // Aggiorna il nuovo selettore
 layerColorPreset.value = getColorName(color);
 layerColorCustomSection.style.display = 'none';
 updateLayerColorPreview(color);
 saveState('Colore modificato');
 scheduleRender();
 updateUI();
 announceGemini('Colore applicato: ' + color, 'polite');
 }
 };
 palette.appendChild(swatch);
 });
 }
 
 // ---- INTERAZIONE CANVAS ----
 
 canvas.addEventListener('click', e => {
 if (state.vectorDrawMode) return; // Non gestire click in modalità vettoriale
 if (state.eyedropperActive) {
 pickColor(e);
 return;
 }
 
 const rect = canvas.getBoundingClientRect();
 const x = (e.clientX - rect.left) / state.zoom;
 const y = (e.clientY - rect.top) / state.zoom;
 
 let clickedLayer = null;
 // Scorri layer dall'alto verso il basso (gli ultimi sono in cima)
 for (let i = state.layers.length - 1; i >= 0; i--) {
 const layer = state.layers[i];
 if (layer.locked) continue;
 
 // Hit test semplificato
 if (x >= layer.x && x <= layer.x + layer.width &&
 y >= layer.y && y <= layer.y + layer.height) {
 clickedLayer = layer;
 break;
 }
 }
 
 if (clickedLayer) {
 state.selectedIds = [clickedLayer.id];
 // Aggiorna anche currentLayerIndex per allineare selezione e target effetti
 const index = state.layers.findIndex(l => l.id === clickedLayer.id);
 if (index !== -1) {
 state.currentLayerIndex = index;
 }
 // RIMOSSO (ridondante): announceGemini(`Selezionato: ${clickedLayer.name}`, 'polite');
 } else {
 state.selectedIds = [];
 announceGemini('Deselezionato', 'polite');
 }
 
 scheduleRender();
 updateUI();
 });
 
 // ---- MOUSE TRACKING SUL CANVAS ----
 let lastAnnouncedLayer = null;
 let lastAnnouncedX = -1000;
 let lastAnnouncedY = -1000;
 let mouseMoveDebounceTimer = null;
 
 canvas.addEventListener('mousemove', e => {
 const rect = canvas.getBoundingClientRect();
 const x = Math.floor((e.clientX - rect.left) / state.zoom);
 const y = Math.floor((e.clientY - rect.top) / state.zoom);
 
 // Trova layer sotto il mouse
 let layerUnderMouse = null;
 for (let i = state.layers.length - 1; i >= 0; i--) {
 const layer = state.layers[i];
 if (x >= layer.x && x <= layer.x + layer.width &&
 y >= layer.y && y <= layer.y + layer.height) {
 layerUnderMouse = layer;
 break;
 }
 }
 
 // SEMPRE annuncia se cambia elemento (anche se ti muovi di 1 pixel)
 // OPPURE annuncia se ti muovi di almeno 50 pixel sullo stesso elemento (o vuoto)
 const layerChanged = (layerUnderMouse?.id || null) !== (lastAnnouncedLayer?.id || null);
 const movedEnough = Math.abs(x - lastAnnouncedX) >= 50 || Math.abs(y - lastAnnouncedY) >= 50;
 
 if (layerChanged || movedEnough) {
 // Cancella timer precedente
 if (mouseMoveDebounceTimer) {
 clearTimeout(mouseMoveDebounceTimer);
 }
 
 // Se cambia layer, annuncia SUBITO (no debounce)
 // Se cambia solo posizione, aspetta 200ms
 const delay = layerChanged ? 100 : 200;
 
 mouseMoveDebounceTimer = setTimeout(() => {
 let message = `X ${x}, Y ${y}`;
 
 if (layerUnderMouse) {
 const typeStr = layerUnderMouse.type === 'text' ? 'Testo' :
 layerUnderMouse.type === 'image' ? 'Immagine' :
 layerUnderMouse.type === 'shape' ? 'Forma' :
 layerUnderMouse.type === 'vector' ? 'Disegno' : 'Elemento';
 message += `. ${typeStr}: ${layerUnderMouse.name}`;
 
 // Aggiungi info dimensioni
 const w = Math.floor(layerUnderMouse.width);
 const h = Math.floor(layerUnderMouse.height);
 message += `. Dimensioni: ${w} per ${h} pixel`;
 } else {
 message += '. Spazio vuoto';
 }
 
 announceGemini(message, 'polite');
 lastAnnouncedLayer = layerUnderMouse;
 lastAnnouncedX = x;
 lastAnnouncedY = y;
 }, delay);
 }
 });
 
 // ---- CONTAGOCCE ----
 function activateEyedropper() {
 state.eyedropperActive = true;
 canvas.style.cursor = 'crosshair';
 announceGemini('Contagocce attivo. Clicca su un punto del canvas per prelevare il colore', 'assertive');
 }
 
 function deactivateEyedropper() {
 state.eyedropperActive = false;
 canvas.style.cursor = 'default';
 }
 
 function pickColor(e) {
 const rect = canvas.getBoundingClientRect();
 const x = Math.floor((e.clientX - rect.left) / state.zoom);
 const y = Math.floor((e.clientY - rect.top) / state.zoom);
 
 // Preleva pixel
 const imageData = ctx.getImageData(x, y, 1, 1);
 const [r, g, b] = imageData.data;
 
 // Converti in hex
 const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
 
 // Applica al layer corrente
 const layer = getSelectedLayer();
 if (layer) {
 layer.color = hex;
 // Aggiorna il nuovo selettore
 layerColorPreset.value = 'custom';
 layerColorCustomSection.style.display = 'block';
 layerColorHex.value = hex;
 const rgbVals = hexToRgb(hex);
 if (rgbVals) {
 layerColorR.value = rgbVals.r;
 layerColorG.value = rgbVals.g;
 layerColorB.value = rgbVals.b;
 }
 updateLayerColorPreview(hex);
 saveState('Colore prelevato');
 scheduleRender();
 updateUI();
 }
 
 deactivateEyedropper();
 announceGemini('Colore prelevato: ' + hex, 'assertive');
 }
 
 // ---- MAPPA SONORA (da v3.29) ----
 function toggleGridMode() {
 state.isGridModeActive = !state.isGridModeActive;
 if (state.isGridModeActive) {
 state.gridCell = { x: 1, y: 1 };
 scheduleRender();
 describeGridCell(state.gridCell.x, state.gridCell.y);
 // RIMOSSO (ridondante): announceGemini('Mappa sonora attivata. Usa le frecce per navigare. Premi Ctrl+M per uscire.', 'assertive');
 } else {
 scheduleRender();
 announceGemini('Mappa sonora disattivata', 'polite');
 }
 }
 
 function describeGridCell(x, y) {
 const cellW = canvas.width / 3;
 const cellH = canvas.height / 3;
 const cellX = x * cellW;
 const cellY = y * cellH;
 
 // Trova layer in questa cella
 const layersInCell = state.layers.filter(L => {
 const cx = L.x + L.width / 2;
 const cy = L.y + L.height / 2;
 return cx >= cellX && cx < cellX + cellW && cy >= cellY && cy < cellY + cellH;
 });
 
 const position = ['Alto', 'Centro', 'Basso'][y] + ' ' + ['Sinistra', 'Centro', 'Destra'][x];
 const frequency = 200 + (x * 200) + (y * 100);
 playBeep(frequency, 100);
 
 if (layersInCell.length === 0) {
 // RIMOSSO (ridondante): announceGemini(`${position}: Vuoto`, 'assertive');
 } else {
 const layerNames = layersInCell.map(L => L.name).join(', ');
 announceGemini(`${position}: ${layersInCell.length} element${layersInCell.length > 1 ? 'i' : 'o'}: ${layerNames}`, 'assertive');
 }
 }
 
 // ---- ZOOM ----
 function setZoom(newZoom) {
 state.zoom = Math.max(0.1, Math.min(3, newZoom));
 canvas.style.transform = `scale(${state.zoom})`;
 document.getElementById('zoom-display').textContent = Math.round(state.zoom * 100) + '%';
 announceDebounced('Zoom: ' + Math.round(state.zoom * 100) + '%', 'polite', 200);
 }
 
 // ---- ESPORTA ----
 function exportImage(format) {
 try {
 // Render pulito senza selezioni
 const selection = [...state.selectedIds];
 state.selectedIds = [];
 
 // Usa renderSync per assicurare che il render sia completo prima di toBlob
 renderSync();
 
 // Ripristina selezione SUBITO dopo il render per evitare race condition
 state.selectedIds = selection;
 
 canvas.toBlob(blob => {
 if (!blob) {
 announceGemini('Errore nella creazione dell\'immagine', 'assertive');
 return;
 }
 
 const url = URL.createObjectURL(blob);
 const a = document.createElement('a');
 a.href = url;
 a.download = 'design.' + format;
 a.click();
 URL.revokeObjectURL(url);
 
 announceGemini('Immagine esportata come ' + format.toUpperCase(), 'assertive');
 }, 'image/' + format);
 } catch (error) {
 console.error('Errore esportazione:', error);
 announceGemini('Errore durante l\'esportazione dell\'immagine', 'assertive');
 }
 }
 
 function saveProject() {
 try {
 const project = {
 version: '28',
 layers: JSON.parse(JSON.stringify(state.layers, (key, value) => 
 (key === 'imageElement') ? undefined : value
 )),
 backgroundColor: state.backgroundColor,
 tpl: state.tpl,
 colorPalette: state.colorPalette
 };
 
 const json = JSON.stringify(project, null, 2);
 const blob = new Blob([json], { type: 'application/json' });
 const url = URL.createObjectURL(blob);
 const a = document.createElement('a');
 a.href = url;
 a.download = 'progetto-' + Date.now() + '.json';
 a.click();
 URL.revokeObjectURL(url);
 announceGemini('Progetto salvato con successo', 'assertive');
 } catch (error) {
 console.error('Errore salvataggio progetto:', error);
 announceGemini('Errore durante il salvataggio del progetto', 'assertive');
 }
 }
 
 function loadProject(file) {
 const reader = new FileReader();
 reader.onload = async e => {
 try {
 const project = JSON.parse(e.target.result);
 
 // Carica stato
 state.backgroundColor = project.backgroundColor;
 state.tpl = project.tpl;
 canvas.width = state.tpl.w;
 canvas.height = state.tpl.h;
 
 if (project.colorPalette) {
 state.colorPalette = project.colorPalette;
 updateColorPalette();
 }
 
 // Carica layers
 const newLayers = project.layers;
 
 // Ricarica immagini
 const imagePromises = newLayers.map(layer => {
 if (layer.type === 'image' && layer.imageData) {
 return new Promise((resolve) => {
 const img = new Image();
 img.onload = () => {
 layer.imageElement = img;
 resolve();
 };
 img.onerror = () => {
 console.error("Impossibile ricaricare immagine");
 resolve();
 };
 img.src = layer.imageData;
 });
 }
 return Promise.resolve();
 });
 
 await Promise.all(imagePromises);
 state.layers = newLayers;
 state.selectedIds = [];
 
 // Valida e aggiusta currentLayerIndex
 if (state.currentLayerIndex >= state.layers.length) {
 state.currentLayerIndex = Math.max(0, state.layers.length - 1);
 }
 
 saveState('Progetto caricato');
 scheduleRender();
 updateUI();
 announceGemini('Progetto caricato con successo', 'assertive');
 } catch (err) {
 console.error('Errore caricamento progetto:', err);
 let errorMsg = 'Errore nel caricamento del progetto';
 if (err instanceof SyntaxError) {
 errorMsg = 'File progetto non valido o corrotto';
 } else if (err.message.includes('version')) {
 errorMsg = 'Versione progetto non compatibile';
 }
 announceGemini(errorMsg, 'assertive');
 }
 };
 reader.readAsText(file);
 }
 
 // ---- ALLINEAMENTO ----
 function alignLayer(position) {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da allineare', 'polite');
 return;
 }
 
 const cw = canvas.width;
 const ch = canvas.height;
 const lw = layer.width;
 const lh = layer.height;
 
 switch(position) {
 case 'top-left': layer.x = 0; layer.y = 0; break;
 case 'top-center': layer.x = (cw - lw) / 2; layer.y = 0; break;
 case 'top-right': layer.x = cw - lw; layer.y = 0; break;
 case 'middle-left': layer.x = 0; layer.y = (ch - lh) / 2; break;
 case 'center': layer.x = (cw - lw) / 2; layer.y = (ch - lh) / 2; break;
 case 'middle-right': layer.x = cw - lw; layer.y = (ch - lh) / 2; break;
 case 'bottom-left': layer.x = 0; layer.y = ch - lh; break;
 case 'bottom-center': layer.x = (cw - lw) / 2; layer.y = ch - lh; break;
 case 'bottom-right': layer.x = cw - lw; layer.y = ch - lh; break;
 }
 
 saveState('Livello allineato');
 scheduleRender();
 updateUI();
 announceGemini('Livello allineato: ' + position.replace('-', ' '), 'polite');
 }
 
 // Allinea elementi tra loro
 function alignLayersRelative(type) {
 const selectedLayers = getSelectedLayers(); // Usa la nuova funzione sicura
 
 if (selectedLayers.length < 2) {
 announceGemini('Seleziona almeno 2 elementi (Ctrl+Click) per allinearli tra loro', 'assertive');
 return;
 }
 
 // Validazione tipo allineamento
 const validTypes = ['left', 'center-h', 'right', 'top', 'center-v', 'bottom'];
 if (!validTypes.includes(type)) {
 logError('alignLayersRelative', new Error('Tipo allineamento non valido: ' + type), 'Tipo non supportato');
 return;
 }
 
 // Trova l'elemento di riferimento (primo selezionato)
 const reference = selectedLayers[0];
 
 // Validazione reference
 if (!reference || !reference.width || !reference.height) {
 logError('alignLayersRelative', new Error('Layer riferimento non valido'), 'Dati layer incompleti');
 announceGemini('Errore durante l\'allineamento', 'assertive');
 return;
 }
 
 let alignedCount = 0;
 
 selectedLayers.forEach((layer, idx) => {
 if (idx === 0) return; // Skip reference
 
 // Validazione layer
 if (!layer || !layer.width || !layer.height) {
 console.warn('Layer non valido ignorato durante allineamento:', layer);
 return;
 }
 
 // Non allineare layer bloccati
 if (layer.locked) {
 console.warn('Layer bloccato ignorato durante allineamento:', layer.name);
 return;
 }
 
 try {
 switch(type) {
 case 'left':
 layer.x = reference.x;
 break;
 case 'center-h':
 layer.x = reference.x + (reference.width / 2) - (layer.width / 2);
 break;
 case 'right':
 layer.x = reference.x + reference.width - layer.width;
 break;
 case 'top':
 layer.y = reference.y;
 break;
 case 'center-v':
 layer.y = reference.y + (reference.height / 2) - (layer.height / 2);
 break;
 case 'bottom':
 layer.y = reference.y + reference.height - layer.height;
 break;
 }
 alignedCount++;
 } catch (e) {
 logError('alignLayersRelative', e, 'Errore durante allineamento layer: ' + layer.name);
 }
 });
 
 if (alignedCount === 0) {
 announceGemini('Nessun layer allineato', 'polite');
 return;
 }
 
 saveState('Elementi allineati');
 scheduleRender();
 updateUI();
 
 const typeNames = {
 'left': 'a sinistra',
 'center-h': 'al centro orizzontale',
 'right': 'a destra',
 'top': 'in alto',
 'center-v': 'al centro verticale',
 'bottom': 'in basso'
 };
 announceGemini(`${alignedCount + 1} elementi allineati ${typeNames[type]}`, 'polite');
 }
 
 // Distribuzione uniforme
 function distributeLayersUniform(direction) {
 const selectedLayers = getSelectedLayers(); // Usa funzione sicura
 
 if (selectedLayers.length < 3) {
 announceGemini('Seleziona almeno 3 elementi per distribuirli', 'assertive');
 return;
 }
 
 // Validazione direzione
 if (direction !== 'horizontal' && direction !== 'vertical') {
 logError('distributeLayersUniform', new Error('Direzione non valida: ' + direction), 'Direzione deve essere horizontal o vertical');
 return;
 }
 
 // Filtra layer bloccati
 const unlockedLayers = selectedLayers.filter(l => !l.locked);
 if (unlockedLayers.length < 3) {
 announceGemini('Servono almeno 3 elementi sbloccati per distribuirli', 'assertive');
 return;
 }
 
 // Validazione dimensioni layer
 const invalidLayers = unlockedLayers.filter(l => !l.width || !l.height || l.width <= 0 || l.height <= 0);
 if (invalidLayers.length > 0) {
 logError('distributeLayersUniform', new Error('Layer con dimensioni non valide'), 'Alcuni layer hanno width/height <= 0');
 // RIMOSSO (ridondante): announceGemini('Alcuni layer hanno dimensioni non valide e saranno ignorati', 'polite');
 // Continua con i layer validi
 const validLayers = unlockedLayers.filter(l => l.width > 0 && l.height > 0);
 if (validLayers.length < 3) {
 announceGemini('Non ci sono abbastanza layer validi per la distribuzione', 'assertive');
 return;
 }
 }
 
 try {
 // Ordina per posizione
 if (direction === 'horizontal') {
 unlockedLayers.sort((a, b) => a.x - b.x);
 } else {
 unlockedLayers.sort((a, b) => a.y - b.y);
 }
 
 const first = unlockedLayers[0];
 const last = unlockedLayers[unlockedLayers.length - 1];
 
 if (direction === 'horizontal') {
 const totalSpace = (last.x + last.width) - first.x;
 const usedSpace = unlockedLayers.reduce((sum, l) => sum + l.width, 0);
 const gap = (totalSpace - usedSpace) / (unlockedLayers.length - 1);
 
 // Validazione gap
 if (gap < 0) {
 announceGemini('Layer troppo vicini per distribuirli. Sposta i layer estremi più lontano.', 'assertive');
 return;
 }
 
 let currentX = first.x + first.width + gap;
 for (let i = 1; i < unlockedLayers.length - 1; i++) {
 unlockedLayers[i].x = Math.round(currentX);
 currentX += unlockedLayers[i].width + gap;
 }
 } else {
 const totalSpace = (last.y + last.height) - first.y;
 const usedSpace = unlockedLayers.reduce((sum, l) => sum + l.height, 0);
 const gap = (totalSpace - usedSpace) / (unlockedLayers.length - 1);
 
 // Validazione gap
 if (gap < 0) {
 announceGemini('Layer troppo vicini per distribuirli. Sposta i layer estremi più lontano.', 'assertive');
 return;
 }
 
 let currentY = first.y + first.height + gap;
 for (let i = 1; i < unlockedLayers.length - 1; i++) {
 unlockedLayers[i].y = Math.round(currentY);
 currentY += unlockedLayers[i].height + gap;
 }
 }
 
 saveState('Elementi distribuiti');
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announceGemini(`${unlockedLayers.length} elementi distribuiti uniformemente ${direction === 'horizontal' ? 'orizzontalmente' : 'verticalmente'}`, 'polite');
 
 } catch (e) {
 logError('distributeLayersUniform', e, 'Errore durante distribuzione');
 announceGemini('Errore durante la distribuzione', 'assertive');
 }
 }
 
 // ---- Guida (F1) ----
 function showKeyboardGuide() {
 const guide = `EDITOR GRAFICO v28.7 - GUIDA COMPLETA\n\n` +
 `=== TASTI RAPIDI ===\n` +
 `Ctrl+Z = Annulla\n` +
 `Ctrl+Y = Ripeti\n` +
 `Ctrl+C = Copia livello\n` +
 `Ctrl+V = Incolla livello\n` +
 `Ctrl+D = Duplica livello\n` +
 `Ctrl+P = Attiva/Disattiva Disegno Vettoriale\n` +
 `Delete = Elimina livello\n` +
 `+ / - = Zoom In / Zoom Out\n` +
 `F1 = Questa guida\n` +
 `F2 = Aiuto contestuale sul controllo selezionato\n` +
 `Alt+A = Anteprima Schermo Intero\n` +
 `Ctrl+M = Attiva/Disattiva Mappa Sonora (griglia 3x3)\n` +
 `Esc = Chiudi modali / Annulla operazioni\n\n` +
 `=== NAVIGAZIONE CANVAS ===\n` +
 `Frecce = Esplora canvas 1 pixel\n` +
 `Shift+Frecce = Esplora canvas 25 pixel\n` +
 `Ctrl+Frecce = Esplora canvas 50 pixel\n` +
 `NVDA annuncia coordinate e cosa c'è sotto\n\n` +
 `=== CREAZIONE RAPIDA (NUOVO!) ===\n` +
 `Durante esplorazione canvas:\n` +
 `T = Aggiungi Testo alla posizione corrente\n` +
 `I = Aggiungi Immagine alla posizione corrente\n` +
 `F = Aggiungi Forma alla posizione corrente\n` +
 `D = Attiva Disegno alla posizione corrente\n` +
 `Escape = Annulla operazione\n\n` +
 `ESEMPIO:\n` +
 `1. Ctrl+Frecce per andare al centro (540,540)\n` +
 `2. Premi T per testo\n` +
 `3. Scrivi "BENVENUTI"\n` +
 `4. Testo aggiunto al centro!\n\n` +
 `=== DISEGNO VETTORIALE ===\n` +
 `Ctrl+P o D durante esplorazione = Attiva\n` +
 `Frecce = Muovi cursore (1px)\n` +
 `Shift+Frecce = Muovi cursore (25px)\n` +
 `Ctrl+Frecce = Muovi cursore (50px)\n` +
 `Invio = Posiziona punto\n` +
 `C = Chiudi forma (min 3 punti)\n` +
 `Escape = Annulla\n\n` +
 `=== FUNZIONALITÀ PRINCIPALI ===\n` +
 `1. CANVAS: Scegli template o dimensioni personalizzate\n` +
 `2. TESTO: Scrivi e clicca "Aggiungi Testo al Canvas"\n` +
 ` Impostazioni Avanzate per allineamento e posizione\n` +
 `3. FORME: Rettangoli, Cerchi, Stelle, ecc.\n` +
 `4. IMMAGINI: Carica foto\n` +
 `5. MODIFICA LIVELLO: Mostra elemento SELEZIONATO\n` +
 `6. GESTIONE LIVELLI: Lista TUTTI gli elementi\n` +
 `7. EFFETTI: Ombra, Filtri, Maschere\n` +
 `8. ALLINEAMENTO: Centra o allinea ai bordi\n` +
 `9. ESPORTA: Salva PNG/JPEG o progetto JSON\n\n` +
 `=== MODIFICA vs GESTIONE ===\n` +
 `MODIFICA LIVELLO = Solo elemento selezionato corrente\n` +
 `GESTIONE LIVELLI = Lista completa tutti elementi\n` +
 `Workflow: Gestione (scegli) → Modifica (cambia)\n\n` +
 `=== ALLINEAMENTO vs POSIZIONE ===\n` +
 `ALLINEAMENTO = Controlla il significato della coordinata X:\n` +
 ` - Sinistra: X è il bordo sinistro del testo\n` +
 ` - Centro: X è il centro del testo\n` +
 ` - Destra: X è il bordo destro del testo\n` +
 `POSIZIONE X,Y = DOVE mettere il punto di ancoraggio\n` +
 `"Centra nel Canvas" imposta X=540, Y=540 e allineamento Centro`;
 
 document.getElementById('guideBody').textContent = guide;
 openModal(modalGuide);
 announceGemini('Guida completa mostrata', 'polite');
 }
 
 // ---- ANALISI E REVISIONE (Funzioni da v3.29) ----
 
 function getCompositionAnalysis() {
 if (state.layers.length === 0) return { balance: "è vuota", focus: "nessuno", advice: null };
 let totalWeight = 0, weightedX = 0, weightedY = 0;
 let dominantLayer = null, maxArea = -1;
 
 state.layers.forEach(L => { 
 const area = (L.width * L.height) || 1000; // Stima area
 weightedX += (L.x + L.width / 2) * area; 
 weightedY += (L.y + L.height / 2) * area; 
 totalWeight += area; 
 if (area > maxArea) { maxArea = area; dominantLayer = L; } 
 });
 
 const centerX = totalWeight > 0 ? weightedX / totalWeight : 0;
 const centerY = totalWeight > 0 ? weightedY / totalWeight : 0;
 const canvasCenterX = canvas.width / 2;
 const canvasCenterY = canvas.height / 2;
 
 let balanceDesc, advice = null;
 if (Math.abs(centerX - canvasCenterX) < canvas.width * 0.1 && Math.abs(centerY - canvasCenterY) < canvas.height * 0.1) {
 balanceDesc = "appare ben bilanciata.";
 } else { 
 const horiz = centerX < canvasCenterX ? 'sinistra' : 'destra'; 
 const vert = centerY < canvasCenterY ? 'in alto' : 'in basso'; 
 balanceDesc = `ha il suo peso visivo sbilanciato verso ${vert} a ${horiz}.`;
 advice = `CONSIGLIO: Prova a spostare l'elemento dominante ("${dominantLayer?.name}") verso il centro o aggiungi un contrappeso nell'angolo opposto.`;
 }
 const focusDesc = dominantLayer ? `L'elemento che cattura l'attenzione sembra essere "${dominantLayer.name}".` : "Nessun elemento spicca in particolare.";
 return { balance: balanceDesc, focus: focusDesc, advice: advice };
 }

 function getColorAnalysis() {
 const colors = state.layers
 .filter(L => L.color)
 .map(L => hexToRgb(L.color));
 colors.push(hexToRgb(state.backgroundColor));
 
 if (colors.length < 2) return "L'atmosfera è minimalista.";
 
 const avgLightness = colors.reduce((acc, c) => acc + rgbToHsl(c.r, c.g, c.b)[2], 0) / colors.length;
 
 if (avgLightness > 70) return "La palette di colori crea un'atmosfera leggera, delicata e ariosa.";
 if (avgLightness < 30) return "La palette di colori comunica un'atmosfera elegante, intensa e scura.";
 return "La palette di colori ha un'atmosfera bilanciata e professionale.";
 }
 
 function rgbToHumanName(r, g, b) { 
 const l = rgbToHsl(r,g,b)[2]; 
 if (l < 15) return "nero o molto scuro"; 
 if (l > 90) return "bianco o molto chiaro"; 
 const h = rgbToHsl(r,g,b)[0]; 
 if (h < 30 || h > 330) return "rosso"; 
 if (h < 70) return "giallo o arancione"; 
 if (h < 150) return "verde"; 
 if (h < 250) return "blu o ciano"; 
 if (h < 330) return "viola o magenta"; 
 return "colorato"; 
 }
 
 function getHumanPosition(x, y, width, height) { 
 const horiz_third = (x + width/2) / canvas.width; 
 const vert_third = (y + height/2) / canvas.height; 
 let v_pos = "al centro"; 
 if (vert_third < 0.33) v_pos = "in alto"; 
 else if (vert_third > 0.66) v_pos = "in basso"; 
 let h_pos = ""; 
 if (horiz_third < 0.33) h_pos = " a sinistra"; 
 else if (horiz_third > 0.66) h_pos = " a destra"; 
 if (v_pos === "al centro" && h_pos === "") return "perfettamente al centro"; 
 return v_pos + h_pos; 
 }

 function runFullAnalysis() {
 let finalReport = [];
 let report = [];
 
 // 1. Contrasto Testo
 const badContrastLayers = state.layers.filter(L => L.type === 'text' && getContrastRatio(hexToRgb(L.color), hexToRgb(state.backgroundColor)) < 4.5);
 report.push(badContrastLayers.length === 0 ? " Contrasto: OK." : `️ Contrasto: ${badContrastLayers.length} testo/i hanno un contrasto insufficiente con lo sfondo.`);
 
 // 2. Margini (Safe Zone - da v3.29)
 const sz = state.tpl.safe;
 const szBox = { x: sz.left, y: sz.top, width: canvas.width - sz.left - sz.right, height: canvas.height - sz.top - sz.bottom };
 const outOfBoundsReport = [];
 state.layers.forEach(L => {
 const bbox = getLayerBbox(L);
 let sides = [];
 if(bbox.left < szBox.x) sides.push('a sinistra');
 if(bbox.right > szBox.x + szBox.width) sides.push('a destra');
 if(bbox.top < szBox.y) sides.push('in alto');
 if(bbox.bottom > szBox.y + szBox.height) sides.push('in basso');
 if (sides.length > 0) { outOfBoundsReport.push(`️ Margini: L'elemento "${L.name}" sborda ${sides.join(' e ')} dalla zona sicura.`); }
 });
 if (outOfBoundsReport.length === 0) { report.push(" Margini: OK."); } else { report = report.concat(outOfBoundsReport); }
 
 finalReport.push("--- CHECKLIST ACCESSIBILITÀ ---\n" + report.join('\n'));
 
 // 3. Composizione
 const { balance, focus, advice } = getCompositionAnalysis(); 
 let compReport = `EQUILIBRIO: La composizione ${balance}\n\nPUNTO FOCALE: ${focus}`;
 if(advice) compReport += `\n\n${advice}`;
 finalReport.push("\n--- ANALISI COMPOSIZIONE ---\n" + compReport);
 
 // 4. Colore
 finalReport.push("\n--- ANALISI COLORE ---\n" + getColorAnalysis());
 
 // Mostra
 document.getElementById('analysisBody').textContent = finalReport.join('\n');
 openModal(modalAnalysis);
 announceGemini('Analisi completata', 'assertive');
 }
 
 function generateAltText() {
 if (state.layers.length === 0) {
 altTextBody.textContent = "Il canvas è vuoto.";
 openModal(modalAltText);
 return;
 }
 
 let altText = `Un'immagine con sfondo ${rgbToHumanName(...Object.values(hexToRgb(state.backgroundColor)))}. `;
 
 state.layers.forEach(L => {
 if (L.type === 'text') {
 altText += `Testo "${L.text}" posizionato ${getHumanPosition(L.x, L.y, L.width, L.height)}. `;
 } else if (L.type === 'shape' || L.type === 'polygon') {
 const shapeName = L.type === 'polygon' ? 'poligono' : L.shape === 'rect' ? 'rettangolo' : L.shape === 'circle' ? 'cerchio' : L.shape;
 altText += `Forma ${shapeName} di colore ${rgbToHumanName(...Object.values(hexToRgb(L.color)))} posizionat${L.type === 'polygon' ? 'o' : 'a'} ${getHumanPosition(L.x, L.y, L.width, L.height)}. `;
 } else if (L.type === 'image') {
 altText += `Un'immagine posizionata ${getHumanPosition(L.x, L.y, L.width, L.height)}. `;
 }
 });
 
 altTextBody.textContent = altText;
 openModal(modalAltText);
 announceGemini('Testo alternativo generato', 'assertive');
 }
 
 // ---- LISTENERS ----
 function setupListeners() {
 // PROTEZIONE: Evita listener duplicati se setupListeners viene chiamata più volte
 if (window.__listenersSetup) {
 console.warn('️ setupListeners già eseguito, skip per evitare duplicati');
 return;
 }
 window.__listenersSetup = true;
 
 // Pannelli collassabili
 // ═══════════════════════════════════════════════════════════════
 // RIMOSSO: Section headers non sono più pulsanti cliccabili
 // Le sezioni sono sempre visibili (non più collassabili)
 // ═══════════════════════════════════════════════════════════════
 /*
 document.querySelectorAll('.section-header').forEach(header => {
 header.addEventListener('click', () => {
 const content = header.nextElementSibling;
 content.classList.toggle('collapsed');
 // La sincronizzazione aria-expanded è gestita dal MutationObserver
 const isNowCollapsed = content.classList.contains('collapsed');
 announceGemini(isNowCollapsed ? 'Sezione chiusa' : 'Sezione aperta', 'polite');
 });
 });
 */
 
 // Pulsanti toggle sezioni avanzate
 document.querySelectorAll('.btn-toggle-advanced').forEach(btn => {
 btn.addEventListener('click', () => {
 const targetId = btn.getAttribute('aria-controls');
 const target = document.getElementById(targetId);
 if (target) {
 target.classList.toggle('collapsed');
 // La sincronizzazione aria-expanded è gestita dal MutationObserver
 const isNowCollapsed = target.classList.contains('collapsed');
 announceGemini(isNowCollapsed ? 'Impostazioni avanzate chiuse' : 'Impostazioni avanzate aperte', 'polite');
 }
 });
 });
 
 // Sezione 1: Canvas
 document.getElementById('tpl').addEventListener('change', e => {
 document.getElementById('tplCustom').style.display = (e.target.value === 'custom') ? 'flex' : 'none';
 // Annuncia il template selezionato
 const templates = {
 'instagram-post': 'Post Instagram 1080 per 1080 pixel',
 'instagram-story': 'Storia Instagram 1080 per 1920 pixel',
 'tiktok': 'TikTok Video 1080 per 1920 pixel',
 'facebook-post': 'Post Facebook 1200 per 630 pixel',
 'twitter-post': 'Post Twitter 1600 per 900 pixel',
 'youtube-thumb': 'Miniatura YouTube 1280 per 720 pixel',
 'linkedin-post': 'Post LinkedIn 1200 per 627 pixel',
 'custom': 'Dimensioni personalizzate'
 };
 const selectedTemplate = templates[e.target.value] || e.target.value;
 // v44.2: Memorizza template corrente e gestisci pulsante "Centra in Zona Sicura"
 state.currentTemplate = e.target.value;
 const btnCenterSafe = document.getElementById("btn-center-safe");
 if (btnCenterSafe) {
 // Mostra il pulsante solo per template social (NON per custom)
 // btnCenterSafe.style.display = (e.target.value !== "custom") ? "block" : "none"; // DISABLED: pulsante social sempre visibile

 }
 // DISABLED: announceGemini(`${selectedTemplate}. Premi Applica Dimensioni Canvas per confermare.`, 'polite');
 });

 document.getElementById('btn-apply-canvas').addEventListener('click', () => {
 const val = document.getElementById('tpl').value;
 let w = 1080, h = 1080, t = 60, r = 60, b = 60, l = 60;
 
 if (val === 'custom') { 
 w = Number(document.getElementById('canvas-width').value) || 1080; 
 h = Number(document.getElementById('canvas-height').value) || 1080; 
 }
 else if (val === 'instagram-post') { w = 1080; h = 1080; }
 else if (val === 'instagram-story') { 
 w = 1080; 
 h = 1920; 
 t = 270; // v39.1: 14% of 1920 = 268.8 → 270px (Instagram UI top)
 b = 384; // v39.1: 20% of 1920 = 384px (Instagram swipe-up + pulsanti)
 l = 80; // v39.1: ~7.4% lateral safe zone
 r = 80; // v39.1: ~7.4% lateral safe zone
 }
 else if (val === 'tiktok') {
 w = 1080;
 h = 1920;
 t = 288; // v39.1: 15% of 1920 (TikTok UI più aggressiva di Instagram)
 b = 480; // v39.1: 25% of 1920 (pulsanti like/share laterali + caption)
 l = 80; // v39.1: ~7.4% lateral safe zone
 r = 80; // v39.1: ~7.4% lateral safe zone
 }
 else if (val === 'facebook-post') { w = 1200; h = 630; t = 63; b = 63; l = 120; r = 120; } // 10% margins

 else if (val === 'twitter-post') { w = 1600; h = 900; t = 90; b = 90; l = 160; r = 160; } // 10% margins

 else if (val === 'youtube-thumb') { w = 1280; h = 720; t = b = 90; l = r = 160; }
 else if (val === 'youtube-shorts') {
 w = 1080;
 h = 1920;
 t = 288; // 15% of 1920 (UI YouTube Shorts in alto)
 b = 480; // 25% of 1920 (Like/Dislike, commenti, iscrizione)
 l = 80; // ~7.4% lateral safe zone
 r = 80; // ~7.4% lateral safe zone
 }
 else if (val === 'linkedin-post') { w = 1200; h = 627; t = 63; b = 63; l = 120; r = 120; } // 10% margins

 else if (val === 'instagram-reel') {
 w = 1080;
 h = 1920;
 t = 270; // 14% of 1920 (UI Instagram in alto)
 b = 480; // 25% of 1920 (Più della Story - pulsanti Reel, audio, caption)
 l = 80; // ~7.4% lateral safe zone
 r = 80; // ~7.4% lateral safe zone
 }
 
 state.tpl = { w, h, safe: { top: t, right: r, bottom: b, left: l } };
 // v44.2: Memorizza template corrente
 state.currentTemplate = val;
 canvas.width = w;
 canvas.height = h;
 
 saveState('Canvas ridimensionato');
 scheduleRender();
 updateUI();
 // *** CORREZIONE BUG NVDA ***
 announceGemini(`Canvas ridimensionato a ${w} per ${h} pixel`, 'polite');
 
 // Forzare render immediato per feedback visivo
 if (window.render) {
 setTimeout(() => window.render(), 50);
 }
 });
 
 // Listener per tipo sfondo (mostra/nascondi controlli)
 document.getElementById('bg-type').addEventListener('change', e => {
 const type = e.target.value;
 const colorControls = document.getElementById('bg-color-controls');
 const gradientControls = document.getElementById('bg-gradient-controls');
 const imageControls = document.getElementById('bg-image-controls');
 
 // Funzione helper per mostrare/nascondere completamente
 function setControlsVisibility(element, visible) {
 if (visible) {
 element.style.display = 'block';
 element.removeAttribute('aria-hidden');
 element.removeAttribute('inert');
 // Riabilita tutti gli input figli
 element.querySelectorAll('input, select, button, textarea').forEach(el => {
 el.removeAttribute('tabindex');
 el.removeAttribute('disabled');
 });
 } else {
 element.style.display = 'none';
 element.setAttribute('aria-hidden', 'true');
 element.setAttribute('inert', '');
 // Disabilita tutti gli input figli
 element.querySelectorAll('input, select, button, textarea').forEach(el => {
 el.setAttribute('tabindex', '-1');
 el.setAttribute('disabled', 'disabled');
 });
 }
 }
 
 // Applica visibilità corretta
 setControlsVisibility(colorControls, type === 'color');
 setControlsVisibility(gradientControls, type === 'gradient');
 setControlsVisibility(imageControls, type === 'image');
 
 // Annunci NVDA chiari e descrittivi (NVDA legge già il nome, qui solo la spiegazione)
 const typeDescriptions = {
 'color': 'Lo sfondo sarà un solo colore uniforme',
 'gradient': 'Lo sfondo sarà una sfumatura tra due colori',
 'image': 'Lo sfondo sarà una foto o texture'
 };
 announceGemini(typeDescriptions[type], 'polite'); // Si triggera solo quando selezioni (Enter/click), non durante navigazione frecce
 });
 
 // Listener per slider angolo gradiente
 document.getElementById('bg-gradient-angle').addEventListener('input', e => {
 document.getElementById('bg-gradient-angle-value').textContent = e.target.value + '°';
 });
 
 // Listener per toggle HEX/RGB nel gradiente
 document.querySelectorAll('input[name="bg-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const isHex = e.target.value === 'hex';
 document.getElementById('bg-gradient-hex-controls').style.display = isHex ? 'block' : 'none';
 document.getElementById('bg-gradient-rgb-controls').style.display = isHex ? 'none' : 'block';
 document.getElementById('bg-gradient-hex-controls-2').style.display = isHex ? 'block' : 'none';
 document.getElementById('bg-gradient-rgb-controls-2').style.display = isHex ? 'none' : 'block';
 });
 });
 
 // Sincronizzazione Colore 1: HEX → RGB
 document.getElementById('bg-gradient-color1-hex').addEventListener('input', e => {
 const hex = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 const r = parseInt(hex.slice(1, 3), 16);
 const g = parseInt(hex.slice(3, 5), 16);
 const b = parseInt(hex.slice(5, 7), 16);
 document.getElementById('bg-gradient-color1-r').value = r;
 document.getElementById('bg-gradient-color1-g').value = g;
 document.getElementById('bg-gradient-color1-b').value = b;
 document.getElementById('bg-gradient-color1').value = hex;
 }
 });
 
 // Sincronizzazione Colore 1: RGB → HEX
 ['bg-gradient-color1-r', 'bg-gradient-color1-g', 'bg-gradient-color1-b'].forEach(id => {
 document.getElementById(id).addEventListener('input', () => {
 const r = parseInt(document.getElementById('bg-gradient-color1-r').value) || 0;
 const g = parseInt(document.getElementById('bg-gradient-color1-g').value) || 0;
 const b = parseInt(document.getElementById('bg-gradient-color1-b').value) || 0;
 const hex = '#' + [r, g, b].map(x => {
 const h = Math.max(0, Math.min(255, x)).toString(16);
 return h.length === 1 ? '0' + h : h;
 }).join('');
 document.getElementById('bg-gradient-color1-hex').value = hex;
 document.getElementById('bg-gradient-color1').value = hex;
 });
 });
 
 // Sincronizzazione Colore 1: color picker → HEX e RGB
 document.getElementById('bg-gradient-color1').addEventListener('input', e => {
 const hex = e.target.value;
 document.getElementById('bg-gradient-color1-hex').value = hex;
 const r = parseInt(hex.slice(1, 3), 16);
 const g = parseInt(hex.slice(3, 5), 16);
 const b = parseInt(hex.slice(5, 7), 16);
 document.getElementById('bg-gradient-color1-r').value = r;
 document.getElementById('bg-gradient-color1-g').value = g;
 document.getElementById('bg-gradient-color1-b').value = b;
 });
 
 // Sincronizzazione Colore 2: HEX → RGB
 document.getElementById('bg-gradient-color2-hex').addEventListener('input', e => {
 const hex = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 const r = parseInt(hex.slice(1, 3), 16);
 const g = parseInt(hex.slice(3, 5), 16);
 const b = parseInt(hex.slice(5, 7), 16);
 document.getElementById('bg-gradient-color2-r').value = r;
 document.getElementById('bg-gradient-color2-g').value = g;
 document.getElementById('bg-gradient-color2-b').value = b;
 document.getElementById('bg-gradient-color2').value = hex;
 }
 });
 
 // Sincronizzazione Colore 2: RGB → HEX
 ['bg-gradient-color2-r', 'bg-gradient-color2-g', 'bg-gradient-color2-b'].forEach(id => {
 document.getElementById(id).addEventListener('input', () => {
 const r = parseInt(document.getElementById('bg-gradient-color2-r').value) || 0;
 const g = parseInt(document.getElementById('bg-gradient-color2-g').value) || 0;
 const b = parseInt(document.getElementById('bg-gradient-color2-b').value) || 0;
 const hex = '#' + [r, g, b].map(x => {
 const h = Math.max(0, Math.min(255, x)).toString(16);
 return h.length === 1 ? '0' + h : h;
 }).join('');
 document.getElementById('bg-gradient-color2-hex').value = hex;
 document.getElementById('bg-gradient-color2').value = hex;
 });
 });
 
 // Sincronizzazione Colore 2: color picker → HEX e RGB
 document.getElementById('bg-gradient-color2').addEventListener('input', e => {
 const hex = e.target.value;
 document.getElementById('bg-gradient-color2-hex').value = hex;
 const r = parseInt(hex.slice(1, 3), 16);
 const g = parseInt(hex.slice(3, 5), 16);
 const b = parseInt(hex.slice(5, 7), 16);
 document.getElementById('bg-gradient-color2-r').value = r;
 document.getElementById('bg-gradient-color2-g').value = g;
 document.getElementById('bg-gradient-color2-b').value = b;
 });
 
 // Listener per tipo sfumatura con radio buttons
 document.querySelectorAll('input[name="bg-gradient-type"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const isLinear = e.target.value === 'linear';
 document.getElementById('bg-gradient-angle-container').style.display = isLinear ? 'block' : 'none';
 });
 });
 
 // Listener per caricamento immagine sfondo
 let bgImageElement = null;
 document.getElementById('bg-image-upload').addEventListener('change', e => {
 const file = e.target.files[0];
 if (!file) return;
 
 const reader = new FileReader();
 reader.onload = res => {
 const img = new Image();
 img.onload = () => {
 bgImageElement = img;
 // RIMOSSO: announceGemini('Immagine sfondo caricata. Clicca "Applica Sfondo" per utilizzarla.', 'polite'); // NVDA già legge il valore dello slider
 };
 img.src = res.target.result;
 };
 reader.readAsDataURL(file);
 });
 
 // Gestione nuovo selettore colore sfondo con preset
 
 const bgColorPreset = document.getElementById('c');
 const bgColorCustomSection = document.getElementById('bg-color-custom-section');
 const bgColorHex = document.getElementById('bg-color-hex');
 const bgColorR = document.getElementById('bg-color-r');
 const bgColorG = document.getElementById('bg-color-g');
 const bgColorB = document.getElementById('bg-color-b');
 const bgColorPreview = document.getElementById('bg-color-preview');
 
 // Funzione per convertire RGB in HEX
 function rgbToHex(r, g, b) {
 return '#' + [r, g, b].map(x => {
 const hex = parseInt(x).toString(16);
 return hex.length === 1 ? '0' + hex : hex;
 }).join('');
 }
 
 // Funzione helper per sincronizzare valori HEX ai campi RGB
 function syncHexToRgb(hexValue, baseId) {
 const rgb = hexToRgb(hexValue);
 if (rgb) {
 const rInput = document.getElementById(baseId + '-r');
 const gInput = document.getElementById(baseId + '-g');
 const bInput = document.getElementById(baseId + '-b');
 
 if (rInput) rInput.value = rgb.r;
 if (gInput) gInput.value = rgb.g;
 if (bInput) bInput.value = rgb.b;
 }
 }
 
 // Funzione per aggiornare l'anteprima colore
 function updateColorPreview(color) {
 if (color === 'transparent') {
 bgColorPreview.style.background = 'repeating-conic-gradient(#ddd 0% 25%, white 0% 50%) 50% / 20px 20px';
 document.getElementById('bg-color-preview-text').textContent = 'Trasparente';
 } else {
 bgColorPreview.style.background = color;
 document.getElementById('bg-color-preview-text').textContent = color.toUpperCase();
 }
 }
 
 // Quando cambia il preset
 bgColorPreset.addEventListener('change', (e) => {
 const value = e.target.value;
 
 if (value === 'custom' || value === 'Personalizzato') {
 bgColorCustomSection.style.display = 'block';
 announceGemini('Modalità colore personalizzato attivata. Usa Tab per navigare tra i campi HEX e RGB', 'polite');
 } else {
 bgColorCustomSection.style.display = 'none';
 const hexColor = getColorHex(value);
 updateColorPreview(hexColor);
 
 // Aggiorna anche i campi RGB/HEX nel caso l'utente torni su personalizzato
 if (hexColor !== 'transparent') {
 const rgb = hexToRgb(hexColor);
 if (rgb) {
 bgColorR.value = rgb.r;
 bgColorG.value = rgb.g;
 bgColorB.value = rgb.b;
 bgColorHex.value = hexColor;
 }
 }
 
 const colorName = e.target.options[e.target.selectedIndex].text;
 // DISABLED: announceGemini(`Colore sfondo: ${colorName}`, 'polite');
 }
 });
 
 // Sincronizza HEX con RGB
 bgColorHex.addEventListener('input', (e) => {
 let hex = e.target.value;
 if (!hex.startsWith('#')) hex = '#' + hex;
 
 const rgb = hexToRgb(hex);
 if (rgb) {
 bgColorR.value = rgb.r;
 bgColorG.value = rgb.g;
 bgColorB.value = rgb.b;
 updateColorPreview(hex);
 }
 });
 
 // Sincronizza RGB con HEX
 function syncRgbToHex() {
 const r = parseInt(bgColorR.value) || 0;
 const g = parseInt(bgColorG.value) || 0;
 const b = parseInt(bgColorB.value) || 0;
 const hex = rgbToHex(r, g, b);
 bgColorHex.value = hex;
 updateColorPreview(hex);
 }
 
 bgColorR.addEventListener('input', syncRgbToHex);
 bgColorG.addEventListener('input', syncRgbToHex);
 bgColorB.addEventListener('input', syncRgbToHex);
 
 // Gestione selettore colore TESTO con preset (stesso sistema dello sfondo)
 const textColorPreset = document.getElementById('tc');
 const textColorCustomSection = document.getElementById('text-color-custom-section');
 const textColorHex = document.getElementById('text-color-hex');
 const textColorR = document.getElementById('text-color-r');
 const textColorG = document.getElementById('text-color-g');
 const textColorB = document.getElementById('text-color-b');
 const textColorPreview = document.getElementById('text-color-preview');
 
 // Funzione per aggiornare l'anteprima colore testo
 function updateTextColorPreview(color) {
 textColorPreview.style.background = color;
 document.getElementById('text-color-preview-text').textContent = color.toUpperCase();
 }
 
 // Quando cambia il preset testo
 textColorPreset.addEventListener('change', (e) => {
 const value = e.target.value;
 
 if (value === 'custom') {
 textColorCustomSection.style.display = 'block';
 announceGemini('Modalità colore testo personalizzato attivata. Usa Tab per navigare tra i campi HEX e RGB', 'polite');
 } else {
 textColorCustomSection.style.display = 'none';
 const hexColor = getColorHex(value);
 updateTextColorPreview(hexColor);
 
 // Aggiorna anche i campi RGB/HEX
 const rgb = hexToRgb(hexColor);
 if (rgb) {
 textColorR.value = rgb.r;
 textColorG.value = rgb.g;
 textColorB.value = rgb.b;
 textColorHex.value = hexColor;
 }
 
 const colorName = e.target.options[e.target.selectedIndex].text;
 // DISABLED: announceGemini(`Colore testo: ${colorName}`, 'polite');
 }
 });
 
 // Sincronizza HEX con RGB per testo
 textColorHex.addEventListener('input', (e) => {
 let hex = e.target.value;
 if (!hex.startsWith('#')) hex = '#' + hex;
 
 const rgb = hexToRgb(hex);
 if (rgb) {
 textColorR.value = rgb.r;
 textColorG.value = rgb.g;
 textColorB.value = rgb.b;
 updateTextColorPreview(hex);
 }
 });
 
 // Sincronizza RGB con HEX per testo
 function syncTextRgbToHex() {
 const r = parseInt(textColorR.value) || 0;
 const g = parseInt(textColorG.value) || 0;
 const b = parseInt(textColorB.value) || 0;
 const hex = rgbToHex(r, g, b);
 textColorHex.value = hex;
 updateTextColorPreview(hex);
 }
 
 textColorR.addEventListener('input', syncTextRgbToHex);
 textColorG.addEventListener('input', syncTextRgbToHex);
 textColorB.addEventListener('input', syncTextRgbToHex);
 
 // Pulsante applica sfondo
 document.getElementById('btn-apply-bg').addEventListener('click', () => {
 const bgType = document.getElementById('bg-type').value;
 
 if (bgType === 'color') {
 const presetValue = bgColorPreset.value;
 
 if (presetValue === 'custom') {
 // Usa il valore HEX personalizzato
 state.backgroundColor = bgColorHex.value;
 } else {
 // Converte il nome del colore in HEX usando la mappa
 state.backgroundColor = getColorHex(presetValue);
 }
 
 state.backgroundType = 'color';
 const colorText = state.backgroundColor === 'transparent' ? 'Trasparente' : state.backgroundColor;
 announceGemini('Sfondo colore applicato: ' + colorText, 'assertive');
 } else if (bgType === 'gradient') {
 state.backgroundType = 'gradient';
 const gradientType = document.querySelector('input[name="bg-gradient-type"]:checked')?.value || 'linear';
 state.backgroundGradient = {
 type: gradientType,
 color1: document.getElementById('bg-gradient-color1').value,
 color2: document.getElementById('bg-gradient-color2').value,
 angle: parseInt(document.getElementById('bg-gradient-angle').value)
 };
 const gradientTypeText = gradientType === 'linear' ? 'lineare' : 'radiale';
 const angleText = gradientType === 'linear' ? `, angolo ${state.backgroundGradient.angle}°` : '';
 announceGemini(`Sfondo gradiente ${gradientTypeText} applicato${angleText}`, 'assertive');
 } else if (bgType === 'image') {
 if (!bgImageElement) {
 announceGemini('Carica prima un\'immagine sfondo', 'assertive');
 return;
 }
 state.backgroundType = 'image';
 state.backgroundImage = {
 element: bgImageElement,
 fit: document.getElementById('bg-image-fit').value
 };
 announceGemini('Sfondo immagine applicato', 'polite');
 }
 
 saveState('Sfondo modificato');
 scheduleRender();
 
 // Forzare render immediato per feedback visivo
 if (window.render) {
 setTimeout(() => window.render(), 50);
 }
 });
 
 
 
 document.getElementById('show-grid').addEventListener('change', e => {
 state.showGrid = e.target.checked;
 document.getElementById('grid-controls').style.display = e.target.checked ? 'block' : 'none';
 scheduleRender();
 // RIMOSSO: announceGemini(e.target.checked ? 'Griglia attivata' : 'Griglia disattivata', 'polite'); // NVDA già legge il valore dello slider
 });
 
 // v39.1: Toggle Safe Zone Overlay
 document.getElementById('show-safe-zone').addEventListener('change', e => {
 state.showSafeZone = e.target.checked;
 scheduleRender();
 // RIMOSSO: announceGemini(e.target.checked ? 'Safe zone visibili. Zone rosse indicano margini pericolosi per social media.' : 'Safe zone nascoste', 'polite'); // NVDA già legge il valore dello slider
 });
 
 document.getElementById('grid-size').addEventListener('input', e => {
 state.gridSize = parseInt(e.target.value) || 20;
 scheduleRender();
 announceDebounced('Dimensione griglia: ' + state.gridSize + ' pixel', 'polite');
 });
 
 // Sezione 2: Aggiungi Livelli
 document.getElementById('btn-add-text').addEventListener('click', () => {
 const text = document.getElementById('text-input').value || 'Nuovo Testo';
 const fontFamily = document.getElementById('nff').value;
 const fontSize = parseInt(document.getElementById('new-font-size').value);
 const fontWeight = document.getElementById('nfw').value;
 const lineHeight = parseFloat(document.getElementById('new-line-height').value);
 const letterSpacing = parseFloat(document.getElementById('new-letter-spacing').value);
 
 // Ottieni colore dal nuovo sistema preset/personalizzato
 const colorPreset = textColorPreset.value;
 const color = (colorPreset === 'custom') ? textColorHex.value : getColorHex(colorPreset);
 
 const x = parseInt(document.getElementById('new-text-x').value);
 const y = parseInt(document.getElementById('new-text-y').value);
 
 // Determina allineamento dai bottoni
 let textAlign = 'left';
 const btnLeft = document.getElementById('new-btn-align-left');
 const btnCenter = document.getElementById('new-btn-align-center');
 const btnRight = document.getElementById('new-btn-align-right');
 if (btnCenter.classList.contains('active')) textAlign = 'center';
 else if (btnRight.classList.contains('active')) textAlign = 'right';
 
 // Calcola numero di righe
 const lines = text.split('\n').length;
 
 addLayer({
 type: 'text', name: text, text: text,
 x: x, y: y,
 fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight,
 color: color, rotation: 0, opacity: 100,
 textAlign: textAlign, letterSpacing: letterSpacing, lineHeight: lineHeight
 });
 document.getElementById('text-input').value = '';
 const lineText = lines === 1 ? '1 riga' : `${lines} righe`;
 announceGemini(`Testo "${text}" aggiunto in posizione X:${x}, Y:${y}. Occupa ${lineText} sul canvas.`, 'polite');
 
 // Aggiorna il box delle dimensioni dopo 500ms
 if (typeof window.showTextDimensions === 'function') {
 setTimeout(window.showTextDimensions, 500);
 }
 });
 
 document.getElementById('btn-add-rect').addEventListener('click', () => {
 console.log(' [DEBUG] Click su btn-add-rect - aggiungendo rettangolo');
 addLayer({ type: 'shape', shape: 'rect', name: 'Rettangolo',
 x: 50, y: 50, width: 200, height: 150,
 color: '#3b82f6', rotation: 0, opacity: 100
 });
 // Mostra il controllo corner radius per i rettangoli
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'block';
 });
 
 document.getElementById('btn-add-circle').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'circle', name: 'Cerchio',
 x: 50, y: 50, width: 150, height: 150,
 color: '#10b981', rotation: 0, opacity: 100
 });
 // Nascondi corner radius per cerchi
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 });
 
 document.getElementById('btn-add-triangle').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'triangle', name: 'Triangolo',
 x: 50, y: 50, width: 150, height: 150,
 color: '#f59e0b', rotation: 0, opacity: 100
 });
 // Nascondi corner radius per triangoli
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 });
 
 document.getElementById('btn-add-star').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'star', name: 'Stella',
 x: 50, y: 50, width: 150, height: 150,
 color: '#eab308', rotation: 0, opacity: 100
 });
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 });
 
 document.getElementById('btn-add-line').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'line', name: 'Linea',
 x: 50, y: 100, width: 200, height: 0,
 color: '#0f172a', rotation: 0, opacity: 100,
 useStroke: true, stroke: {width: 5, color: '#0f172a'}
 });
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 });
 
 document.getElementById('btn-add-hexagon').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'hexagon', name: 'Esagono',
 x: 50, y: 50, width: 150, height: 130,
 color: '#8b5cf6', rotation: 0, opacity: 100
 });
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 });
 
 document.getElementById('btn-add-arrow').addEventListener('click', () => {
 addLayer({ type: 'shape', shape: 'arrow', name: 'Freccia',
 x: 50, y: 50, width: 200, height: 50,
 color: '#06b6d4', rotation: 0, opacity: 100,
 locked: false
 });
 const cornerGroup = document.getElementById('new-rect-corner-group');
 if (cornerGroup) cornerGroup.style.display = 'none';
 announceGemini('Freccia aggiunta! Usa i controlli per modificarla.', 'polite');
 });
 
 document.getElementById('image-upload').addEventListener('change', e => {
 const file = e.target.files[0];
 if (!file) return;
 
 const reader = new FileReader();
 reader.onload = res => {
 const img = new Image();
 img.onload = () => {
 // Usa le dimensioni e posizione dai nuovi controlli se visibili
 const sizeControls = document.getElementById('new-image-size-controls');
 const posControls = document.getElementById('new-image-position-controls');
 
 let width = img.width;
 let height = img.height;
 let x = 50;
 let y = 50;
 
 if (sizeControls.style.display !== 'none') {
 width = parseInt(document.getElementById('new-img-width').value) || img.width;
 height = parseInt(document.getElementById('new-img-height').value) || img.height;
 }
 
 if (posControls.style.display !== 'none') {
 x = parseInt(document.getElementById('new-img-x').value);
 y = parseInt(document.getElementById('new-img-y').value);
 }
 
 addLayer({
 type: 'image', name: file.name.split('.')[0],
 x: x, y: y, width: width, height: height,
 rotation: 0, opacity: 100,
 imageElement: img,
 filters: { brightness: 0, contrast: 0, saturation: 0, hue: 0, sepia: 0, blur: 0, preset: 'none' }
 });
 
 // Nascondi i controlli dopo aver aggiunto
 sizeControls.style.display = 'none';
 posControls.style.display = 'none';
 // RIMOSSO: announceGemini(`Immagine "${file.name}" caricata in posizione X:${x}, Y:${y}`, 'polite'); // NVDA già legge il valore dello slider
 };
 img.src = res.target.result;
 };
 reader.readAsDataURL(file);
 });
 
 // Mostra controlli quando si clicca sul campo immagine
 document.getElementById('image-upload').addEventListener('click', () => {
 document.getElementById('new-image-size-controls').style.display = 'block';
 document.getElementById('new-image-position-controls').style.display = 'block';
 });
 
 // Gestione proporzioni immagine
 document.getElementById('new-img-width').addEventListener('input', e => {
 if (document.getElementById('new-img-lock-ratio').checked) {
 const ratio = parseInt(document.getElementById('new-img-height').getAttribute('data-ratio') || 1);
 document.getElementById('new-img-height').value = Math.round(parseInt(e.target.value) * ratio);
 }
 });
 
 document.getElementById('new-img-height').addEventListener('input', e => {
 if (document.getElementById('new-img-lock-ratio').checked) {
 const ratio = parseInt(document.getElementById('new-img-width').getAttribute('data-ratio') || 1);
 document.getElementById('new-img-width').value = Math.round(parseInt(e.target.value) / ratio);
 }
 });
 
 // Listener per i controlli del nuovo testo
 document.getElementById('new-line-height').addEventListener('input', e => {
 document.getElementById('new-line-height-value').textContent = e.target.value;
 });
 
 document.getElementById('new-letter-spacing').addEventListener('input', e => {
 document.getElementById('new-letter-spacing-value').textContent = e.target.value + ' px';
 });
 
 // Bottoni allineamento testo (nuovo pannello)
 ['new-btn-align-left', 'new-btn-align-center', 'new-btn-align-right'].forEach(id => {
 document.getElementById(id).addEventListener('click', function() {
 // Rimuovi active da tutti
 document.getElementById('new-btn-align-left').classList.remove('active');
 document.getElementById('new-btn-align-center').classList.remove('active');
 document.getElementById('new-btn-align-right').classList.remove('active');
 // Aggiungi active a questo
 this.classList.add('active');
 
 // Annuncia il cambio
 const alignText = id.includes('left') ? 'sinistra' : id.includes('center') ? 'centro' : 'destra';
 announceGemini(`Allineamento righe: ${alignText}`, 'polite');
 });
 });
 // Imposta left come default
 document.getElementById('new-btn-align-left').classList.add('active');
 
 // Pulsante centra testo nel canvas
 document.getElementById('btn-center-text-position').addEventListener('click', () => {
 // Calcola il centro in base alle dimensioni del canvas attuale
 const centerX = Math.round(state.tpl.w / 2);
 const centerY = Math.round(state.tpl.h / 2);
 
 document.getElementById('new-text-x').value = centerX;
 document.getElementById('new-text-y').value = centerY;
 
 // Imposta automaticamente l'allineamento su "Centro" per garantire che funzioni correttamente
 document.getElementById('new-btn-align-left').classList.remove('active');
 document.getElementById('new-btn-align-center').classList.add('active');
 document.getElementById('new-btn-align-right').classList.remove('active');
 
 // Annuncio immediato e assertive così viene letto subito
 announceGemini(`Testo centrato nel canvas. Posizione: X ${centerX}, Y ${centerY}. Allineamento: Centro.`, 'assertive');
 });
 
 // Aggiorna forme per usare i nuovi controlli di posizione
 const updateShapeButtons = () => {
 const shapes = ['rect', 'circle', 'triangle', 'star', 'star8', 'heart', 'speech', 'line', 'hexagon', 'arrow'];
 const colors = {
 rect: '#3b82f6',
 circle: '#10b981',
 triangle: '#f59e0b',
 star: '#eab308',
 star8: '#f59e0b',
 heart: '#ef4444',
 speech: '#06b6d4',
 line: '#0f172a',
 hexagon: '#8b5cf6',
 arrow: '#ec4899'
 };
 
 shapes.forEach(shape => {
 const btn = document.getElementById(`btn-add-${shape}`);
 if (!btn) return; // Skip se non esiste
 
 const originalListener = btn.onclick;
 btn.onclick = null; // Rimuovi vecchio listener
 
 btn.addEventListener('click', () => {
 const x = parseInt(document.getElementById('new-shape-x').value);
 const y = parseInt(document.getElementById('new-shape-y').value);
 const fill = document.getElementById('new-shape-fill').value;
 const stroke = document.getElementById('new-shape-stroke').value;
 const lineStyle = document.getElementById('new-line-style').value;
 const cornerRadius = parseInt(document.getElementById('new-corner-radius').value);
 
 // Dimensioni personalizzate per forma
 let width = 150, height = 150;
 if (shape === 'line') { width = 200; height = 0; }
 else if (shape === 'speech') { width = 200; height = 150; }
 else if (shape === 'arrow') { width = 200; height = 50; }
 
 const layerData = {
 type: 'shape', 
 shape: shape, 
 name: shape === 'star8' ? 'Stella 8' : 
 shape === 'heart' ? 'Cuore' :
 shape === 'speech' ? 'Fumetto' :
 shape.charAt(0).toUpperCase() + shape.slice(1),
 x: x, 
 y: y, 
 width: width, 
 height: height,
 color: fill, 
 rotation: 0, 
 opacity: 100
 };
 
 // Angoli arrotondati per rettangoli
 if (shape === 'rect' && cornerRadius > 0) {
 layerData.cornerRadius = (Math.min(width, height) * cornerRadius) / 100;
 }
 
 // Linea sempre con stroke
 if (shape === 'line') {
 layerData.useStroke = true;
 layerData.stroke = {width: 5, color: stroke, style: lineStyle};
 } else {
 // Altre forme possono avere bordo opzionale
 if (lineStyle !== 'solid' || shape === 'arrow' || shape === 'hexagon') {
 layerData.useStroke = true;
 layerData.stroke = {width: 2, color: stroke, style: lineStyle};
 }
 }
 
 addLayer(layerData);
 announceGemini(`${layerData.name} aggiunto in posizione X:${x}, Y:${y}`, 'polite');
 });
 });
 };
 
 // Rimuovi i vecchi listener e aggiungi i nuovi
 updateShapeButtons();
 
 // Listener per corner radius slider
 document.getElementById('new-corner-radius').addEventListener('input', e => {
 document.getElementById('new-corner-radius-value').textContent = e.target.value + '%';
 });
 
 // Nascondi corner radius per forme diverse dal rettangolo
 ['circle', 'triangle', 'star', 'star8', 'heart', 'speech', 'line', 'hexagon', 'arrow'].forEach(shape => {
 const btn = document.getElementById(`btn-add-${shape}`);
 if (btn) {
 btn.addEventListener('click', () => {
 document.getElementById('new-rect-corner-group').style.display = 'none';
 });
 }
 });
 
 // Sezione 2.5: Disegno Vettoriale
 const vectorToggleBtn = document.getElementById('btn-toggle-vector');
 if (vectorToggleBtn) {
 console.log(' Pulsante disegno vettoriale trovato, aggiungo listener');
 vectorToggleBtn.addEventListener('click', () => {
 console.log('️ Click su pulsante disegno vettoriale');
 toggleVectorMode();
 });
 } else {
 console.error(' Pulsante btn-toggle-vector non trovato!');
 }
 
 // Listener per l'area di focus del disegno vettoriale
 const vectorFocusArea = document.getElementById('vector-focus-area');
 if (vectorFocusArea) {
 console.log(' Area di focus vettoriale trovata');
 
 vectorFocusArea.addEventListener('click', () => {
 console.log('️ Click su area di focus, vectorDrawMode:', state.vectorDrawMode);
 if (!state.vectorDrawMode) {
 toggleVectorMode();
 } else {
 vectorFocusArea.focus();
 console.log(' Focus dato all\'area');
 }
 });
 
 vectorFocusArea.addEventListener('focus', () => {
 console.log(' Focus ricevuto dall\'area di disegno');
 vectorFocusArea.style.borderColor = '#10b981';
 vectorFocusArea.style.borderStyle = 'solid';
 vectorFocusArea.style.borderWidth = '3px';
 vectorFocusArea.style.backgroundColor = '#f0fdf4';
 vectorFocusArea.innerHTML = '<strong style="color: #10b981; font-size: 16px;"> ATTIVO - Usa le frecce della tastiera</strong>';
 });
 
 vectorFocusArea.addEventListener('blur', () => {
 console.log(' Focus perso dall\'area di disegno');
 if (state.vectorDrawMode) {
 vectorFocusArea.style.borderColor = '#ef4444';
 vectorFocusArea.style.borderStyle = 'dashed';
 vectorFocusArea.style.borderWidth = '2px';
 vectorFocusArea.style.backgroundColor = '#fef2f2';
 vectorFocusArea.innerHTML = '<strong style="color: #ef4444;">️ CLICCA QUI per riattivare i controlli tastiera</strong>';
 } else {
 vectorFocusArea.style.borderColor = 'var(--primary-color)';
 vectorFocusArea.style.borderStyle = 'dashed';
 vectorFocusArea.style.borderWidth = '2px';
 vectorFocusArea.style.backgroundColor = 'white';
 vectorFocusArea.textContent = 'Clicca qui per attivare i controlli tastiera';
 }
 });
 
 vectorFocusArea.addEventListener('keydown', (e) => {
 console.log('⌨️ Tasto premuto nell\'area:', e.key, 'vectorDrawMode:', state.vectorDrawMode);
 
 if (!state.vectorDrawMode) return;
 
 // DELEGAZIONE: Non gestisco qui, lascio propagare al listener globale
 // che ha già tutta la logica consolidata
 // Questo listener serve SOLO per garantire che i tasti arrivino
 // quando l'area ha il focus
 
 // Log per debug
 console.log(' Evento delegato al listener globale');
 });
 } else {
 console.error(' Area vector-focus-area non trovata!');
 }
 
 document.getElementById('vector-step').addEventListener('input', e => {
 state.vectorStep = parseInt(e.target.value);
 document.getElementById('vector-step-value').textContent = state.vectorStep + ' px';
 });
 
 document.getElementById('vfc').addEventListener('input', e => {
 state.vectorFillColor = getColorHex(e.target.value);
 });
 
 document.getElementById('vsc').addEventListener('input', e => {
 state.vectorStrokeColor = getColorHex(e.target.value);
 });
 
 document.getElementById('vector-stroke-width').addEventListener('input', e => {
 state.vectorStrokeWidth = parseInt(e.target.value);
 });
 
 // Sezione 3: Modifica (Listeners dinamici)
 
 // Testo
 document.getElementById('btn-apply-text-edit').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.text = document.getElementById('text-edit').value;
 layer.name = layer.text.substring(0, 20); // Aggiorna nome
 ctx.font = (layer.fontWeight || '400') + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
 const metrics = ctx.measureText(layer.text);
 layer.width = metrics.width + (layer.text.length * (layer.letterSpacing || 0));
 layer.height = layer.fontSize * (layer.lineHeight || 1.2);
 saveState('Testo modificato');
 scheduleRender();
 updateUI();
 announce('Testo aggiornato');
 
 // Forzare render immediato per feedback visivo
 if (window.render) {
 setTimeout(() => window.render(), 50);
 }
 }
 });
 
 // Font
 ['ff', 'font-size', 'fw'].forEach(id => {
 document.getElementById(id).addEventListener('change', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.fontFamily = document.getElementById('ff').value;
 layer.fontSize = parseInt(document.getElementById('font-size').value);
 layer.fontWeight = document.getElementById('fw').value;
 
 // Ricalcola dimensioni
 ctx.font = layer.fontWeight + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
 const metrics = ctx.measureText(layer.text);
 layer.width = metrics.width + (layer.text.length * (layer.letterSpacing || 0));
 layer.height = layer.fontSize * (layer.lineHeight || 1.2);
 
 saveState('Font modificato');
 scheduleRender();
 updateUI();
 // RIMOSSO: announceGemini('Font aggiornato', 'polite'); // NVDA già legge il valore dello slider
 }
 });
 });
 
 // Letter Spacing
 document.getElementById('letter-spacing').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.letterSpacing = parseFloat(e.target.value);
 document.getElementById('letter-spacing-value').textContent = layer.letterSpacing + ' px';
 
 // Ricalcola larghezza
 ctx.font = (layer.fontWeight || '400') + ' ' + layer.fontSize + 'px ' + layer.fontFamily;
 const metrics = ctx.measureText(layer.text);
 layer.width = metrics.width + (layer.text.length * layer.letterSpacing);
 
 scheduleRender();
 announceDebounced('Spaziatura: ' + layer.letterSpacing + ' pixel', 'polite');
 }
 });
 
 document.getElementById('letter-spacing').addEventListener('change', () => {
 saveState('Spaziatura lettere modificata');
 updateUI();
 });
 
 // Line Height
 document.getElementById('line-height').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.lineHeight = parseFloat(e.target.value);
 document.getElementById('line-height-value').textContent = layer.lineHeight;
 layer.height = layer.fontSize * layer.lineHeight;
 scheduleRender();
 announceDebounced('Altezza riga: ' + layer.lineHeight, 'polite');
 }
 });
 
 document.getElementById('line-height').addEventListener('change', () => {
 saveState('Altezza riga modificata');
 updateUI();
 });
 
 // Stili testo
 document.getElementById('btn-italic').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.italic = !layer.italic;
 saveState('Corsivo');
 scheduleRender();
 updateUI();
 announceGemini(layer.italic ? 'Corsivo attivato' : 'Corsivo disattivato', 'polite');
 }
 });
 
 document.getElementById('btn-underline').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.underline = !layer.underline;
 saveState('Sottolineato');
 scheduleRender();
 updateUI();
 announceGemini(layer.underline ? 'Sottolineato attivato' : 'Sottolineato disattivato', 'polite');
 }
 });
 
 document.getElementById('btn-line-through').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.lineThrough = !layer.lineThrough;
 saveState('Barrato');
 scheduleRender();
 updateUI();
 announceGemini(layer.lineThrough ? 'Barrato attivato' : 'Barrato disattivato', 'polite');
 }
 });
 
 // Allineamento testo
 ['btn-align-left', 'btn-align-center', 'btn-align-right'].forEach(id => {
 document.getElementById(id).addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 layer.textAlign = id.split('-')[2]; // left, center, right
 saveState('Allineamento testo');
 scheduleRender();
 updateUI();
 announceGemini('Allineamento: ' + layer.textAlign, 'polite');
 }
 });
 });
 
 // Centra testo nel canvas (posizionamento visivo)
 document.getElementById('btn-center-in-canvas').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 // Calcola la larghezza reale del blocco testo
 const textWidth = calculateTextBlockWidth(layer);
 
 // Calcola il centro del canvas
 const centerCanvas = canvas.width / 2;
 
 // Calcola la X per centrare il blocco
 // Se il testo è allineato a sinistra: newX = centro - metà larghezza
 // Se il testo è allineato al centro: newX = centro (layer.x è già il centro)
 // Se il testo è allineato a destra: newX = centro + metà larghezza
 const textAlign = layer.textAlign || 'left';
 let newX;
 
 if (textAlign === 'center') {
 // Il punto di riferimento è il centro del testo
 newX = centerCanvas;
 } else if (textAlign === 'left') {
 // Il punto di riferimento è il bordo sinistro del testo
 newX = centerCanvas - (textWidth / 2);
 } else { // right
 // Il punto di riferimento è il bordo destro del testo
 newX = centerCanvas + (textWidth / 2);
 }
 
 // Applica la nuova posizione
 layer.x = newX; // Centratura matematica pura

 
 // Centra anche verticalmente
 const textHeight = calculateTextBlockHeight(layer);
 const centerY = (canvas.height - textHeight) / 2;
 layer.y = centerY; // Centratura matematica pura

 
 saveState('Testo centrato nel canvas');
 scheduleRender();
 updateUI();
 announceGemini('Testo centrato matematicamente nel canvas', 'polite');
 }
 });

 // CENTRA TESTO PER SOCIAL (Safe Zone Universale)
 if (document.getElementById('btn-center-social')) {
 document.getElementById('btn-center-social').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'text') {
 // Ottieni safe zone universale in pixel
 // Context-aware: usa safe zone del template attivo o universale per custom
 let safe;
 if (state.currentTemplate !== 'custom') {
 // Template specifico: usa i suoi margini ottimizzati
 safe = state.tpl.safe;
 } else {
 // Canvas custom: usa safe zone universale (fallback sicuro)
 safe = getUniversalSafeZonePixels();
 }
 
 // Calcola area sicura
 const safeWidth = canvas.width - safe.left - safe.right;
 const safeHeight = canvas.height - safe.top - safe.bottom;
 const safeCenterX = safe.left + (safeWidth / 2);
 const safeCenterY = safe.top + (safeHeight / 2);
 
 // Calcola dimensioni testo
 const textWidth = calculateTextBlockWidth(layer);
 const textHeight = calculateTextBlockHeight(layer);
 
 // Calcola posizione basata su allineamento
 const textAlign = layer.textAlign || 'left';
 let newX, newY;
 
 if (textAlign === 'center') {
 newX = safeCenterX;
 } else if (textAlign === 'left') {
 newX = safeCenterX - (textWidth / 2);
 } else { // right
 newX = safeCenterX + (textWidth / 2);
 }
 
 newY = safeCenterY - (textHeight / 2);
 
 // Assicura che rimanga nella safe zone - CLAMP CORRETTO in base a textAlign
 if (textAlign === 'left') {
 // Per left: x è il bordo sinistro del testo
 layer.x = Math.max(safe.left, Math.min(newX, canvas.width - safe.right - textWidth));
 } else if (textAlign === 'center') {
 // Per center: x è il centro del testo
 const halfWidth = textWidth / 2;
 layer.x = Math.max(safe.left + halfWidth, Math.min(newX, canvas.width - safe.right - halfWidth));
 } else { // right
 // Per right: x è il bordo destro del testo
 layer.x = Math.max(safe.left + textWidth, Math.min(newX, canvas.width - safe.right));
 }
 
 layer.y = Math.max(safe.top, Math.min(newY, canvas.height - safe.bottom - textHeight));
 
 saveState('Testo centrato per social (safe zone universale)');
 scheduleRender();
 updateUI();
 const templateName = state.currentTemplate === 'custom' ? 'safe zone universale' : `safe zone ${state.currentTemplate.replace('-', ' ')}`;

 announceGemini(`Testo centrato nella ${templateName}`, 'polite');

 }
 });
 }
 
 // 🆕 PULSANTE CENTRA IMMAGINE (non solo testo!)
 if (document.getElementById('btn-center-canvas')) {
 document.getElementById('btn-center-canvas').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 // Calcola il centro del canvas
 const centerX = canvas.width / 2;
 const centerY = canvas.height / 2;
 
 // Calcola le dimensioni dell'immagine scalata
 const imgWidth = layer.width * (layer.scale || 1);
 const imgHeight = layer.height * (layer.scale || 1);
 
 // Centra l'immagine (la posizione x,y è l'angolo top-left)
 layer.x = centerX - (imgWidth / 2);
 layer.y = centerY - (imgHeight / 2);
 
 
 saveState('Immagine centrata nel canvas');
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce('Immagine centrata nel canvas completo');
 // RIMOSSO (ridondante): announceGemini('Immagine centrata nel canvas completo', 'polite');
 } else if (layer && layer.type === 'text') {
 // RIMOSSO (ridondante): announce('️ Usa il pulsante "Centra Testo" per centrare il testo');
 announceGemini('Per centrare il testo, utilizza il pulsante dedicato Centra Testo nella sezione testo', 'assertive');
 } else {
 // RIMOSSO (ridondante): announce('️ Seleziona un\'immagine da centrare');
 announceGemini('Nessuna immagine selezionata. Seleziona un layer immagine per centrarlo', 'assertive');
 }
 });
 }
 
 // PULSANTE CENTRA IN ZONA SICURA (v44.2)
 if (document.getElementById('btn-center-safe')) {
 document.getElementById('btn-center-social-img').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 // Ottieni safe zone del template corrente
 // Context-aware: usa safe zone del template attivo o universale per custom
 let safe;
 if (state.currentTemplate !== 'custom') {
 // Template specifico: usa i suoi margini ottimizzati
 safe = state.tpl.safe;
 } else {
 // Canvas custom: usa safe zone universale (fallback sicuro)
 safe = getUniversalSafeZonePixels();
 }

 
 // Calcola il centro della zona sicura
 const safeWidth = canvas.width - safe.left - safe.right;
 const safeHeight = canvas.height - safe.top - safe.bottom;
 const safeCenterX = safe.left + (safeWidth / 2);
 const safeCenterY = safe.top + (safeHeight / 2);
 
 // Calcola le dimensioni dell'immagine scalata
 const imgWidth = layer.width * (layer.scale || 1);
 const imgHeight = layer.height * (layer.scale || 1);
 
 // Centra l'immagine nella zona sicura
 layer.x = safeCenterX - (imgWidth / 2);
 layer.y = safeCenterY - (imgHeight / 2);
 
 // Assicurati che l'immagine rimanga dentro la safe zone
 layer.x = Math.max(safe.left, Math.min(layer.x, canvas.width - safe.right - imgWidth));
 layer.y = Math.max(safe.top, Math.min(layer.y, canvas.height - safe.bottom - imgHeight));
 
 saveState('Immagine centrata nella zona sicura');
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce(`Immagine centrata nella zona sicura del template ${state.currentTemplate}`);
 const templateName = state.currentTemplate === 'custom' ? 'safe zone universale' : `safe zone ${state.currentTemplate.replace('-', ' ')}`;

 announceGemini(`Immagine centrata nella ${templateName}`, 'polite');


 } else if (layer && layer.type === 'text') {
 // RIMOSSO (ridondante): announce('️ Il pulsante Zona Sicura funziona solo con immagini');
 announceGemini('Questo pulsante funziona solo con layer immagine. Seleziona un\'immagine.', 'assertive');
 } else {
 // RIMOSSO (ridondante): announce('️ Seleziona un\'immagine da centrare');
 announceGemini('Nessuna immagine selezionata. Seleziona un layer immagine per centrarlo nella zona sicura', 'assertive');
 }
 });
 }
 
 // 🆕 SINCRONIZZAZIONE COLOR PICKER ↔ HEX INPUT per gradienti TESTO
 const gradColor1 = document.getElementById('gradient-color1');
 const gradColor1Hex = document.getElementById('gradient-color1-hex');
 const gradColor2 = document.getElementById('gradient-color2');
 const gradColor2Hex = document.getElementById('gradient-color2-hex');
 
 if (gradColor1 && gradColor1Hex) {
 gradColor1.addEventListener('input', (e) => {
 gradColor1Hex.value = e.target.value;
 announceGemini(`Colore 1 gradiente impostato a ${e.target.value}`, 'polite');
 });
 
 gradColor1Hex.addEventListener('input', (e) => {
 let hex = e.target.value.trim();
 if (hex && !hex.startsWith('#')) {
 hex = '#' + hex;
 e.target.value = hex;
 }
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 gradColor1.value = hex;
 e.target.style.borderColor = '#10b981';
 // RIMOSSO (ridondante): announceGemini(`Colore 1 gradiente: ${hex} valido`, 'polite');
 } else if (hex.length === 7) {
 e.target.style.borderColor = '#ef4444';
 announceGemini('Formato colore non valido. Usa #RRGGBB', 'assertive');
 } else {
 e.target.style.borderColor = '#cbd5e1';
 }
 });
 
 gradColor1Hex.addEventListener('blur', (e) => {
 e.target.style.borderColor = '#cbd5e1';
 });
 }
 
 if (gradColor2 && gradColor2Hex) {
 gradColor2.addEventListener('input', (e) => {
 gradColor2Hex.value = e.target.value;
 announceGemini(`Colore 2 gradiente impostato a ${e.target.value}`, 'polite');
 });
 
 gradColor2Hex.addEventListener('input', (e) => {
 let hex = e.target.value.trim();
 if (hex && !hex.startsWith('#')) {
 hex = '#' + hex;
 e.target.value = hex;
 }
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 gradColor2.value = hex;
 e.target.style.borderColor = '#10b981';
 // RIMOSSO (ridondante): announceGemini(`Colore 2 gradiente: ${hex} valido`, 'polite');
 } else if (hex.length === 7) {
 e.target.style.borderColor = '#ef4444';
 announceGemini('Formato colore non valido. Usa #RRGGBB', 'assertive');
 } else {
 e.target.style.borderColor = '#cbd5e1';
 }
 });
 
 gradColor2Hex.addEventListener('blur', (e) => {
 e.target.style.borderColor = '#cbd5e1';
 });
 }
 
 // 🆕 SINCRONIZZAZIONE COLOR PICKER ↔ HEX INPUT per gradienti SFONDO
 const bgGradColor1 = document.getElementById('bg-gradient-color1');
 const bgGradColor1Hex = document.getElementById('bg-gradient-color1-hex');
 const bgGradColor2 = document.getElementById('bg-gradient-color2');
 const bgGradColor2Hex = document.getElementById('bg-gradient-color2-hex');
 
 if (bgGradColor1 && bgGradColor1Hex) {
 bgGradColor1.addEventListener('input', (e) => {
 bgGradColor1Hex.value = e.target.value;
 announceGemini(`Colore 1 sfondo gradiente impostato a ${e.target.value}`, 'polite');
 });
 
 bgGradColor1Hex.addEventListener('input', (e) => {
 let hex = e.target.value.trim();
 if (hex && !hex.startsWith('#')) {
 hex = '#' + hex;
 e.target.value = hex;
 }
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 bgGradColor1.value = hex;
 e.target.style.borderColor = '#10b981';
 // RIMOSSO (ridondante): announceGemini(`Colore 1 sfondo: ${hex} valido`, 'polite');
 } else if (hex.length === 7) {
 e.target.style.borderColor = '#ef4444';
 announceGemini('Formato colore non valido. Usa #RRGGBB', 'assertive');
 } else {
 e.target.style.borderColor = '#cbd5e1';
 }
 });
 
 bgGradColor1Hex.addEventListener('blur', (e) => {
 e.target.style.borderColor = '#cbd5e1';
 });
 }
 
 if (bgGradColor2 && bgGradColor2Hex) {
 bgGradColor2.addEventListener('input', (e) => {
 bgGradColor2Hex.value = e.target.value;
 announceGemini(`Colore 2 sfondo gradiente impostato a ${e.target.value}`, 'polite');
 });
 
 bgGradColor2Hex.addEventListener('input', (e) => {
 let hex = e.target.value.trim();
 if (hex && !hex.startsWith('#')) {
 hex = '#' + hex;
 e.target.value = hex;
 }
 if (/^#[0-9A-Fa-f]{6}$/.test(hex)) {
 bgGradColor2.value = hex;
 e.target.style.borderColor = '#10b981';
 // RIMOSSO (ridondante): announceGemini(`Colore 2 sfondo: ${hex} valido`, 'polite');
 } else if (hex.length === 7) {
 e.target.style.borderColor = '#ef4444';
 announceGemini('Formato colore non valido. Usa #RRGGBB', 'assertive');
 } else {
 e.target.style.borderColor = '#cbd5e1';
 }
 });
 
 bgGradColor2Hex.addEventListener('blur', (e) => {
 e.target.style.borderColor = '#cbd5e1';
 });
 }
 
 // Funzione per calcolare la larghezza massima del blocco testo
 function calculateTextBlockWidth(layer) {
 if (!layer || layer.type !== 'text') return 0;
 
 // Crea un contesto temporaneo per misurare il testo
 const tempCanvas = document.createElement('canvas');
 const ctx = tempCanvas.getContext('2d');
 
 // Imposta lo stesso font del layer
 let fontStyle = '';
 if (layer.bold) fontStyle += 'bold ';
 if (layer.italic) fontStyle += 'italic ';
 fontStyle += layer.fontSize + 'px ';
 fontStyle += layer.fontFamily;
 ctx.font = fontStyle;
 
 // Splitta il testo in righe
 const lines = (layer.text || '').split('\n');
 const maxCanvasWidth = canvas.width - (2 * SAFE_ZONE_PADDING);
 
 // Array per contenere tutte le righe con word wrap
 const wrappedLines = [];
 
 lines.forEach(line => {
 if (line.trim() === '') {
 wrappedLines.push('');
 return;
 }
 
 // Word wrapping
 const words = line.split(' ');
 let currentLine = '';
 
 for (let i = 0; i < words.length; i++) {
 const word = words[i];
 const testLine = currentLine ? currentLine + ' ' + word : word;
 const metrics = ctx.measureText(testLine);
 const testWidth = metrics.width + (layer.letterSpacing ? testLine.length * (layer.letterSpacing || 0) : 0);
 
 if (testWidth > maxCanvasWidth && currentLine !== '') {
 wrappedLines.push(currentLine);
 currentLine = word;
 } else {
 currentLine = testLine;
 }
 }
 
 if (currentLine) {
 wrappedLines.push(currentLine);
 }
 });
 
 // Calcola la larghezza massima tra tutte le righe
 let maxWidth = 0;
 wrappedLines.forEach(line => {
 if (line.trim() === '') return;
 
 const metrics = ctx.measureText(line);
 const lineWidth = metrics.width + (layer.letterSpacing ? line.length * (layer.letterSpacing || 0) : 0);
 
 if (lineWidth > maxWidth) {
 maxWidth = lineWidth;
 }
 });
 
 return maxWidth;
 }
 
 // Funzione per calcolare l'altezza totale del blocco testo
 function calculateTextBlockHeight(layer) {
 if (!layer || layer.type !== 'text') return 0;
 
 const lines = (layer.text || '').split('\n');
 const lineHeight = layer.fontSize * (layer.lineHeight || 1.2);
 
 // Crea un contesto temporaneo per il word wrapping
 const tempCanvas = document.createElement('canvas');
 const ctx = tempCanvas.getContext('2d');
 
 let fontStyle = '';
 if (layer.bold) fontStyle += 'bold ';
 if (layer.italic) fontStyle += 'italic ';
 fontStyle += layer.fontSize + 'px ';
 fontStyle += layer.fontFamily;
 ctx.font = fontStyle;
 
 const maxCanvasWidth = canvas.width - (2 * SAFE_ZONE_PADDING);
 let totalLines = 0;
 
 lines.forEach(line => {
 if (line.trim() === '') {
 totalLines++;
 return;
 }
 
 const words = line.split(' ');
 let currentLine = '';
 
 for (let i = 0; i < words.length; i++) {
 const word = words[i];
 const testLine = currentLine ? currentLine + ' ' + word : word;
 const metrics = ctx.measureText(testLine);
 const testWidth = metrics.width + (layer.letterSpacing ? testLine.length * (layer.letterSpacing || 0) : 0);
 
 if (testWidth > maxCanvasWidth && currentLine !== '') {
 totalLines++;
 currentLine = word;
 } else {
 currentLine = testLine;
 }
 }
 
 if (currentLine) {
 totalLines++;
 }
 });
 
 return totalLines * lineHeight;
 }
 
 // Gestione colore livello con nuovo sistema preset
 
 
 layerColorPreset.addEventListener('change', (e) => {
 const value = e.target.value;
 const layer = getSelectedLayer();
 
 if (value === 'custom') {
 layerColorCustomSection.style.display = 'block';
 // RIMOSSO (ridondante): announceGemini('Modalità colore personalizzato. Usa Tab per i campi RGB', 'polite');
 } else if (value === 'eyedropper') {
 layerColorCustomSection.style.display = 'none';
 activateEyedropper();
 announceGemini('Contagocce attivato. Clicca sul canvas per prelevare un colore', 'assertive');
 } else {
 layerColorCustomSection.style.display = 'none';
 const hexColor = getColorHex(value);
 if (layer) {
 layer.color = hexColor;
 const rgb = hexToRgb(hexColor);
 if (rgb) {
 layerColorR.value = rgb.r;
 layerColorG.value = rgb.g;
 layerColorB.value = rgb.b;
 layerColorHex.value = hexColor;
 }
 updateLayerColorPreview(hexColor);
 scheduleRender();
 saveState('Colore modificato');
 }
 const colorName = e.target.options[e.target.selectedIndex].text;
 // DISABLED: announceGemini(`Colore: ${colorName}`, 'polite');
 }
 });
 
 layerColorHex.addEventListener('input', (e) => {
 let hex = e.target.value;
 if (!hex.startsWith('#')) hex = '#' + hex;
 const rgb = hexToRgb(hex);
 if (rgb) {
 layerColorR.value = rgb.r;
 layerColorG.value = rgb.g;
 layerColorB.value = rgb.b;
 updateLayerColorPreview(hex);
 const layer = getSelectedLayer();
 if (layer) {
 layer.color = hex;
 scheduleRender();
 }
 }
 });
 
 function syncLayerRgbToHex() {
 const r = parseInt(layerColorR.value) || 0;
 const g = parseInt(layerColorG.value) || 0;
 const b = parseInt(layerColorB.value) || 0;
 const hex = rgbToHex(r, g, b);
 layerColorHex.value = hex;
 updateLayerColorPreview(hex);
 const layer = getSelectedLayer();
 if (layer) {
 layer.color = hex;
 scheduleRender();
 }
 }
 
 layerColorR.addEventListener('input', syncLayerRgbToHex);
 layerColorG.addEventListener('input', syncLayerRgbToHex);
 layerColorB.addEventListener('input', syncLayerRgbToHex);
 
 layerColorHex.addEventListener('change', () => {
 saveState('Colore modificato');
 announceGemini('Colore aggiornato: ' + layerColorHex.value, 'polite');
 });
 
 
 // Gradiente
 document.getElementById('use-gradient').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.useGradient = e.target.checked;
 if (layer.useGradient && !layer.gradient) {
 layer.gradient = { type: 'linear', color1: '#ff0000', color2: '#0000ff', angle: 0 };
 }
 // Aggiorna subito la visibilità dei controlli gradiente - RIMUOVI/AGGIUNGI classe hidden
 const gradientControls = document.getElementById('gradient-controls');
 if (layer.useGradient) {
 gradientControls.classList.remove('hidden');
 // Popola i campi con i valori correnti
 document.getElementById('gradient-type').value = layer.gradient.type;
 document.getElementById('gradient-color1').value = layer.gradient.color1;
 document.getElementById('gradient-color2').value = layer.gradient.color2;
 document.getElementById('gradient-color1-hex').value = layer.gradient.color1;
 document.getElementById('gradient-color2-hex').value = layer.gradient.color2;
 
 // Sincronizza anche i campi RGB
 syncHexToRgb(layer.gradient.color1, 'gradient-color1');
 syncHexToRgb(layer.gradient.color2, 'gradient-color2');
 
 document.getElementById('gradient-angle').value = layer.gradient.angle;
 document.getElementById('gradient-angle-value').textContent = layer.gradient.angle + '°';
 updateGradientPreview();
 } else {
 gradientControls.classList.add('hidden');
 }
 saveState('Gradiente');
 scheduleRender();
 updateUI();
 // RIMOSSO: announceGemini(layer.useGradient ? 'Gradiente attivato' : 'Gradiente disattivato', 'polite'); // NVDA già legge il valore dello slider
 }
 });
 
 // Gradient type con annuncio NVDA esplicativo
 document.getElementById('gradient-type').addEventListener('change', (e) => {
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 const newType = e.target.value;
 layer.gradient.type = newType;
 saveState('Tipo gradiente modificato');
 scheduleRender();
 updateUI();
 
 // Annuncio NVDA semplificato (NVDA legge già "Lineare" o "Radiale")
 const typeDescription = newType === 'linear' 
 ? 'Sfumatura dritta da un punto all\'altro'
 : 'Sfumatura circolare dal centro ai bordi';
 announceGemini(typeDescription, 'polite');
 }
 });
 
 // === Descrizioni utili per preset filtri (NVDA legge solo quando selezioni) ===
 
 // Clarity preset
 const claritySelect = document.getElementById('clarity-preset');
 if (claritySelect) {
 claritySelect.addEventListener('change', (e) => {
 const descriptions = {
 'custom': 'Personalizza manualmente intensità e raggio',
 'subtle': 'Effetto sottile ideale per ritratti delicati',
 'moderate': 'Intensità moderata per uso generale',
 'strong': 'Effetto forte per paesaggi drammatici',
 'extreme': 'Intensità estrema con effetto HDR'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Denoise preset
 const denoiseSelect = document.getElementById('denoise-preset');
 if (denoiseSelect) {
 denoiseSelect.addEventListener('change', (e) => {
 const descriptions = {
 'custom': 'Personalizza manualmente i parametri di riduzione rumore',
 'light': 'Riduzione leggera per foto con ISO 800-1600',
 'moderate': 'Riduzione moderata per foto con ISO 1600-3200',
 'strong': 'Riduzione forte per foto con ISO 3200-6400',
 'aggressive': 'Riduzione aggressiva per rumore estremo sopra ISO 6400'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Gradient Map preset
 const gradmapSelect = document.getElementById('gradmap-preset');
 if (gradmapSelect) {
 gradmapSelect.addEventListener('change', (e) => {
 const descriptions = {
 'custom': 'Personalizza i colori ombre e luci manualmente',
 'goldenblue': 'Golden Hour: effetto tramonto con tonalità oro verso blu',
 'cyanred': 'Cinema Teal: look cinematografico con ciano verso rosso',
 'purpleorange': 'Sunset Dream: tramonto magico viola verso arancio',
 'greenmint': 'Nature Fresh: tonalità naturali verde verso menta',
 'retrowarm': 'Retro Warm: stile vintage anni 70 marrone verso crema'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Background Image Fit
 const bgFitSelect = document.getElementById('bg-image-fit');
 if (bgFitSelect) {
 bgFitSelect.addEventListener('change', (e) => {
 const descriptions = {
 'cover': 'Copri tutto: riempie l\'area tagliando se necessario',
 'contain': 'Contenuto: mostra l\'immagine intera senza tagliarla',
 'stretch': 'Allunga: deforma l\'immagine per riempire l\'area',
 'tile': 'Ripeti: crea un pattern ripetendo l\'immagine'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Sharpen preset
 const sharpenSelect = document.getElementById('sharpen-preset');
 if (sharpenSelect) {
 sharpenSelect.addEventListener('change', (e) => {
 const descriptions = {
 'custom': 'Personalizza manualmente l\'intensità dello sharpening',
 'light': 'Sharpening leggero per dettagli sottili',
 'medium': 'Sharpening medio per uso generale',
 'strong': 'Sharpening forte per massima nitidezza'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Noise type
 const noiseSelect = document.getElementById('noise-type');
 if (noiseSelect) {
 noiseSelect.addEventListener('change', (e) => {
 const descriptions = {
 'mono': 'Grana monocromatica: effetto pellicola bianco e nero classica',
 'color': 'Grana colorata: effetto pellicola a colori vintage'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Curves preset
 const curvesSelect = document.getElementById('curves-preset');
 if (curvesSelect) {
 curvesSelect.addEventListener('change', (e) => {
 const descriptions = {
 'linear': 'Lineare: nessun effetto sulla curva tonale',
 'scurve': 'S-Curve: aumenta contrasto nei mezzitoni ideale per ritratti',
 'fade': 'Fade: riduce contrasto per look vintage e analogico',
 'contrast': 'High Contrast: effetto drammatico con neri profondi e bianchi brillanti'
 };
 if (descriptions[e.target.value]) {
 announceGemini(descriptions[e.target.value], 'polite');
 }
 });
 }
 
 // Gradient colors
 ['gradient-color1', 'gradient-color2'].forEach(id => {
 document.getElementById(id).addEventListener('change', () => {
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.color1 = document.getElementById('gradient-color1').value;
 layer.gradient.color2 = document.getElementById('gradient-color2').value;
 // Sincronizza i campi HEX
 document.getElementById('gradient-color1-hex').value = layer.gradient.color1;
 document.getElementById('gradient-color2-hex').value = layer.gradient.color2;
 // Sincronizza anche i campi RGB
 syncHexToRgb(layer.gradient.color1, 'gradient-color1');
 syncHexToRgb(layer.gradient.color2, 'gradient-color2');
 saveState('Colori gradiente modificati');
 scheduleRender();
 updateGradientPreview();
 }
 });
 });
 
 // Listener per i campi HEX del gradiente
 document.getElementById('gradient-color1-hex').addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.color1 = value;
 document.getElementById('gradient-color1').value = value;
 
 // Sincronizza anche i campi RGB se visibili
 syncHexToRgb(value, 'gradient-color1');
 
 scheduleRender();
 updateGradientPreview();
 }
 }
 });
 
 document.getElementById('gradient-color1-hex').addEventListener('change', () => {
 saveState('Colore 1 gradiente modificato');
 });
 
 document.getElementById('gradient-color2-hex').addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.color2 = value;
 document.getElementById('gradient-color2').value = value;
 
 // Sincronizza anche i campi RGB se visibili
 syncHexToRgb(value, 'gradient-color2');
 
 scheduleRender();
 updateGradientPreview();
 }
 }
 });
 
 document.getElementById('gradient-color2-hex').addEventListener('change', () => {
 saveState('Colore 2 gradiente modificato');
 });
 
 document.getElementById('gradient-angle').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.angle = parseInt(e.target.value);
 document.getElementById('gradient-angle-value').textContent = layer.gradient.angle + '°';
 scheduleRender();
 updateGradientPreview();
 announceDebounced('Angolo gradiente: ' + layer.gradient.angle + ' gradi', 'polite');
 }
 });
 
 document.getElementById('gradient-angle').addEventListener('change', () => {
 saveState('Angolo gradiente modificato');
 });
 
 // Toggle HEX/RGB per gradiente forme
 document.querySelectorAll('input[name="layer-gradient-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls1 = document.getElementById('layer-gradient-hex-controls-1');
 const hexControls2 = document.getElementById('layer-gradient-hex-controls-2');
 const rgbControls1 = document.getElementById('layer-gradient-rgb-controls-1');
 const rgbControls2 = document.getElementById('layer-gradient-rgb-controls-2');
 
 if (format === 'hex') {
 hexControls1.style.display = '';
 hexControls2.style.display = '';
 rgbControls1.style.display = 'none';
 rgbControls2.style.display = 'none';
 announce('Modalità codice HEX attivata per gradiente', 'polite');
 } else {
 hexControls1.style.display = 'none';
 hexControls2.style.display = 'none';
 rgbControls1.style.display = '';
 rgbControls2.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const color1 = document.getElementById('gradient-color1-hex').value;
 const color2 = document.getElementById('gradient-color2-hex').value;
 if (color1) syncHexToRgb(color1, 'gradient-color1');
 if (color2) syncHexToRgb(color2, 'gradient-color2');
 
 announce('Modalità valori RGB attivata per gradiente', 'polite');
 }
 });
 });
 
 // Listener per campi RGB del gradiente forme - Colore 1
 ['gradient-color1-r', 'gradient-color1-g', 'gradient-color1-b'].forEach(id => {
 document.getElementById(id).addEventListener('input', () => {
 const r = parseInt(document.getElementById('gradient-color1-r').value) || 0;
 const g = parseInt(document.getElementById('gradient-color1-g').value) || 0;
 const b = parseInt(document.getElementById('gradient-color1-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('gradient-color1-hex').value = hex;
 document.getElementById('gradient-color1').value = hex;
 
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.color1 = hex;
 scheduleRender();
 updateGradientPreview();
 }
 });
 
 document.getElementById(id).addEventListener('change', () => {
 saveState('Colore 1 gradiente modificato (RGB)');
 });
 });
 
 // Listener per campi RGB del gradiente forme - Colore 2
 ['gradient-color2-r', 'gradient-color2-g', 'gradient-color2-b'].forEach(id => {
 document.getElementById(id).addEventListener('input', () => {
 const r = parseInt(document.getElementById('gradient-color2-r').value) || 0;
 const g = parseInt(document.getElementById('gradient-color2-g').value) || 0;
 const b = parseInt(document.getElementById('gradient-color2-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('gradient-color2-hex').value = hex;
 document.getElementById('gradient-color2').value = hex;
 
 const layer = getSelectedLayer();
 if (layer && layer.gradient) {
 layer.gradient.color2 = hex;
 scheduleRender();
 updateGradientPreview();
 }
 });
 
 document.getElementById(id).addEventListener('change', () => {
 saveState('Colore 2 gradiente modificato (RGB)');
 });
 });
 
 // Bordo
 document.getElementById('use-stroke').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.useStroke = e.target.checked;
 if (layer.useStroke && !layer.stroke) {
 layer.stroke = { color: '#000000', width: 2 };
 }
 saveState('Bordo');
 scheduleRender();
 updateUI();
 // RIMOSSO: announceGemini(layer.useStroke ? 'Bordo attivato' : 'Bordo disattivato', 'polite'); // NVDA già legge il valore dello slider
 }
 });
 
 ['sc', 'stroke-width'].forEach(id => {
 document.getElementById(id).addEventListener('change', () => {
 const layer = getSelectedLayer();
 if (layer && layer.stroke) {
 const scValue = document.getElementById('sc').value;
 
 // Se è custom, usa il valore HEX personalizzato
 if (scValue === 'custom') {
 layer.stroke.color = document.getElementById('stroke-color-hex').value;
 } else {
 layer.stroke.color = getColorHex(scValue);
 }
 
 layer.stroke.width = parseInt(document.getElementById('stroke-width').value);
 saveState('Bordo modificato');
 scheduleRender();
 // RIMOSSO: announceGemini('Bordo aggiornato', 'polite'); // NVDA già legge il valore dello slider
 }
 });
 });
 
 // ═══════════════════════════════════════════════════════════════════
 // BORDO - Colore personalizzato con HEX/RGB
 // ═══════════════════════════════════════════════════════════════════
 
 // Mostra/nascondi sezione colore personalizzato
 document.getElementById('sc').addEventListener('change', e => {
 const customSection = document.getElementById('stroke-color-custom-section');
 if (e.target.value === 'custom') {
 customSection.style.display = 'block';
 announce('Modalità colore bordo personalizzato attivata', 'polite');
 } else {
 customSection.style.display = 'none';
 }
 });
 
 // Toggle HEX/RGB per Bordo
 document.querySelectorAll('input[name="stroke-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls = document.getElementById('stroke-hex-controls');
 const rgbControls = document.getElementById('stroke-rgb-controls');
 
 if (format === 'hex') {
 hexControls.style.display = '';
 rgbControls.style.display = 'none';
 announce('Modalità codice HEX attivata per bordo', 'polite');
 } else {
 hexControls.style.display = 'none';
 rgbControls.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const color = document.getElementById('stroke-color-hex').value;
 if (color) syncHexToRgb(color, 'stroke-color');
 
 announce('Modalità valori RGB attivata per bordo', 'polite');
 }
 });
 });
 
 // Listener per campo HEX Bordo
 document.getElementById('stroke-color-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('stroke-color-picker').value = value;
 document.getElementById('stroke-color-preview').style.background = value;
 syncHexToRgb(value, 'stroke-color');
 
 // Aggiorna il colore del bordo se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.stroke && document.getElementById('sc').value === 'custom') {
 layer.stroke.color = value;
 scheduleRender();
 }
 }
 });
 
 // Listener per campi RGB Bordo
 ['stroke-color-r', 'stroke-color-g', 'stroke-color-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('stroke-color-r').value) || 0;
 const g = parseInt(document.getElementById('stroke-color-g').value) || 0;
 const b = parseInt(document.getElementById('stroke-color-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('stroke-color-hex').value = hex;
 document.getElementById('stroke-color-picker').value = hex;
 document.getElementById('stroke-color-preview').style.background = hex;
 
 // Aggiorna il colore del bordo se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.stroke && document.getElementById('sc').value === 'custom') {
 layer.stroke.color = hex;
 scheduleRender();
 }
 });
 });
 
 // Listener per color picker Bordo
 document.getElementById('stroke-color-picker')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('stroke-color-hex').value = value;
 document.getElementById('stroke-color-preview').style.background = value;
 syncHexToRgb(value, 'stroke-color');
 
 // Aggiorna il colore del bordo se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.stroke && document.getElementById('sc').value === 'custom') {
 layer.stroke.color = value;
 scheduleRender();
 }
 });
 
 // Trasformazioni
 ['pos-x', 'pos-y', 'width', 'height'].forEach(id => {
 document.getElementById(id).addEventListener('input', () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.x = parseFloat(document.getElementById('pos-x').value);
 layer.y = parseFloat(document.getElementById('pos-y').value);
 
 const newW = parseFloat(document.getElementById('width').value);
 const newH = parseFloat(document.getElementById('height').value);
 
 // Mantieni proporzioni se checkbox attivo
 if (document.getElementById('maintain-aspect').checked && layer.width && layer.height) {
 const ratio = layer.width / layer.height;
 if (id === 'width') {
 layer.width = newW;
 layer.height = newW / ratio;
 document.getElementById('height').value = Math.round(layer.height);
 } else if (id === 'height') {
 layer.height = newH;
 layer.width = newH * ratio;
 document.getElementById('width').value = Math.round(layer.width);
 } else {
 layer.width = newW;
 layer.height = newH;
 }
 } else {
 layer.width = newW;
 layer.height = newH;
 }
 
 scheduleRender();
 }
 });
 
 document.getElementById(id).addEventListener('change', () => {
 saveState('Trasformazione modificata');
 });
 });
 
 // Corner Radius (solo rettangoli)
 document.getElementById('corner-radius').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.shape === 'rect') {
 layer.cornerRadius = parseInt(e.target.value);
 document.getElementById('corner-radius-value').textContent = layer.cornerRadius + ' px';
 scheduleRender();
 announceDebounced('Arrotondamento: ' + layer.cornerRadius + ' pixel', 'polite');
 }
 });
 
 document.getElementById('corner-radius').addEventListener('change', () => {
 saveState('Arrotondamento modificato');
 });
 
 // Rotazione
 document.getElementById('rotation').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.rotation = parseInt(e.target.value);
 document.getElementById('rotation-value').textContent = layer.rotation + '°';
 scheduleRender();
 announceDebounced('Rotazione: ' + layer.rotation + ' gradi', 'polite');
 }
 });
 
 document.getElementById('rotation').addEventListener('change', () => {
 saveState('Rotazione modificata');
 });
 
 // Flip
 document.getElementById('btn-flip-h').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 layer.flipH = !layer.flipH;
 saveState('Riflesso orizzontale');
 scheduleRender();
 announceGemini('Riflesso orizzontale', 'polite');
 }
 });
 
 document.getElementById('btn-flip-v').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 layer.flipV = !layer.flipV;
 saveState('Riflesso verticale');
 scheduleRender();
 announceGemini('Riflesso verticale', 'polite');
 }
 });
 
 // Opacità
 document.getElementById('opacity').addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.opacity = parseInt(e.target.value);
 document.getElementById('opacity-value').textContent = layer.opacity + '%';
 scheduleRender();
 announceDebounced('Opacità: ' + layer.opacity + '%', 'polite');
 }
 });
 
 document.getElementById('opacity').addEventListener('change', () => {
 saveState('Opacità modificata');
 });
 
 // Sezione 4: Effetti
 
 // Drop Shadow
 document.getElementById('shadow-enabled').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer) {
 if (!layer.dropShadow) {
 layer.dropShadow = { enabled: false, color: '#000000', blur: 10, x: 5, y: 5 };
 }
 layer.dropShadow.enabled = e.target.checked;
 document.getElementById('shadow-controls').style.display = e.target.checked ? 'block' : 'none';
 saveState('Ombra');
 scheduleRender();
 // RIMOSSO: announceGemini(e.target.checked ? 'Ombra attivata' : 'Ombra disattivata', 'polite'); // NVDA già legge il valore dello slider
 }
 });
 
 document.getElementById('shc').addEventListener('change', () => {
 const layer = getSelectedLayer();
 if (layer && layer.dropShadow) {
 const shcValue = document.getElementById('shc').value;
 
 // Se è custom, usa il valore HEX personalizzato
 if (shcValue === 'custom') {
 layer.dropShadow.color = document.getElementById('shadow-color-hex').value;
 } else {
 layer.dropShadow.color = getColorHex(shcValue);
 }
 
 saveState('Colore ombra modificato');
 scheduleRender();
 }
 });
 
 // ═══════════════════════════════════════════════════════════════════
 // DROP SHADOW - Colore personalizzato con HEX/RGB
 // ═══════════════════════════════════════════════════════════════════
 
 // Mostra/nascondi sezione colore personalizzato
 document.getElementById('shc').addEventListener('change', e => {
 const customSection = document.getElementById('shadow-color-custom-section');
 if (e.target.value === 'custom') {
 customSection.style.display = 'block';
 announce('Modalità colore ombra personalizzato attivata', 'polite');
 } else {
 customSection.style.display = 'none';
 }
 });
 
 // Toggle HEX/RGB per Drop Shadow
 document.querySelectorAll('input[name="shadow-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls = document.getElementById('shadow-hex-controls');
 const rgbControls = document.getElementById('shadow-rgb-controls');
 
 if (format === 'hex') {
 hexControls.style.display = '';
 rgbControls.style.display = 'none';
 announce('Modalità codice HEX attivata per ombra', 'polite');
 } else {
 hexControls.style.display = 'none';
 rgbControls.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const color = document.getElementById('shadow-color-hex').value;
 if (color) syncHexToRgb(color, 'shadow-color');
 
 announce('Modalità valori RGB attivata per ombra', 'polite');
 }
 });
 });
 
 // Listener per campo HEX Drop Shadow
 document.getElementById('shadow-color-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('shadow-color-picker').value = value;
 document.getElementById('shadow-color-preview').style.background = value;
 syncHexToRgb(value, 'shadow-color');
 
 // Aggiorna il colore dell'ombra se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.dropShadow && document.getElementById('shc').value === 'custom') {
 layer.dropShadow.color = value;
 scheduleRender();
 }
 }
 });
 
 // Listener per campi RGB Drop Shadow
 ['shadow-color-r', 'shadow-color-g', 'shadow-color-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('shadow-color-r').value) || 0;
 const g = parseInt(document.getElementById('shadow-color-g').value) || 0;
 const b = parseInt(document.getElementById('shadow-color-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('shadow-color-hex').value = hex;
 document.getElementById('shadow-color-picker').value = hex;
 document.getElementById('shadow-color-preview').style.background = hex;
 
 // Aggiorna il colore dell'ombra se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.dropShadow && document.getElementById('shc').value === 'custom') {
 layer.dropShadow.color = hex;
 scheduleRender();
 }
 });
 });
 
 // Listener per color picker Drop Shadow
 document.getElementById('shadow-color-picker')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('shadow-color-hex').value = value;
 document.getElementById('shadow-color-preview').style.background = value;
 syncHexToRgb(value, 'shadow-color');
 
 // Aggiorna il colore dell'ombra se un layer è selezionato
 const layer = getSelectedLayer();
 if (layer && layer.dropShadow && document.getElementById('shc').value === 'custom') {
 layer.dropShadow.color = value;
 scheduleRender();
 }
 });
 
 ['shadow-blur', 'shadow-x', 'shadow-y'].forEach(id => {
 document.getElementById(id).addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.dropShadow) {
 const prop = id.split('-')[1]; // blur, x, y
 layer.dropShadow[prop] = parseInt(e.target.value);
 document.getElementById(id + '-value').textContent = layer.dropShadow[prop] + ' px';
 scheduleRender();
 announceDebounced(`Ombra ${prop}: ${layer.dropShadow[prop]} pixel`, 'polite');
 }
 });
 
 document.getElementById(id).addEventListener('change', () => {
 saveState('Ombra modificata');
 });
 });
 
 // Blend Mode
 document.getElementById('blend-mode').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.blendMode = e.target.value;
 saveState('Modalità fusione modificata');
 scheduleRender();
 // DISABLED: announceGemini('Modalità fusione: ' + e.target.value, 'polite');
 }
 });
 
 // Filtri Immagine
 document.getElementById('filter-preset').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 if (!layer.filters) layer.filters = { brightness: 0, contrast: 0, saturation: 0, hue: 0, sepia: 0, blur: 0, preset: 'none' };
 layer.filters.preset = e.target.value;
 saveState('Preset filtro applicato');
 scheduleRender();
 // DISABLED: announceGemini('Filtro: ' + e.target.value, 'polite');
 }
 });
 
 ['filter-brightness', 'filter-contrast', 'filter-saturation', 'filter-hue', 'filter-sepia', 'filter-blur'].forEach(id => {
 document.getElementById(id).addEventListener('input', e => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 if (!layer.filters) layer.filters = { brightness: 0, contrast: 0, saturation: 0, hue: 0, sepia: 0, blur: 0, preset: 'none' };
 const prop = id.split('-')[1]; // brightness, contrast, saturation, hue, sepia, blur
 layer.filters[prop] = parseInt(e.target.value);
 
 // Formattazione display valore
 let displayValue = layer.filters[prop];
 if (prop === 'blur') {
 displayValue += ' px';
 } else if (prop === 'hue') {
 displayValue += '°';
 } else if (prop === 'sepia') {
 displayValue += '%';
 }
 
 document.getElementById(id + '-value').textContent = displayValue;
 scheduleRender();
 announceDebounced(`${prop}: ${layer.filters[prop]}`, 'polite');
 }
 });
 
 document.getElementById(id).addEventListener('change', () => {
 saveState('Filtro modificato');
 });
 });
 
 // Maschera
 document.getElementById('mask-shape').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 layer.mask = e.target.value;
 saveState('Maschera applicata');
 scheduleRender();
 // DISABLED: announceGemini('Maschera: ' + e.target.value, 'polite');
 }
 });
 
 // Sezione 5: Gestione Livelli
 document.getElementById('btn-move-up').addEventListener('click', () => moveLayer('up'));
 document.getElementById('btn-move-down').addEventListener('click', () => moveLayer('down'));
 document.getElementById('btn-lock').addEventListener('click', toggleLock);
 document.getElementById('btn-delete').addEventListener('click', deleteLayer);
 
 // Sezione 6: Allineamento
 document.getElementById('btn-align-tl').addEventListener('click', () => alignLayer('top-left'));
 document.getElementById('btn-align-tc').addEventListener('click', () => alignLayer('top-center'));
 document.getElementById('btn-align-tr').addEventListener('click', () => alignLayer('top-right'));
 document.getElementById('btn-align-ml').addEventListener('click', () => alignLayer('middle-left'));
 document.getElementById('btn-align-center-2').addEventListener('click', () => alignLayer('center')); // FIX: era btn-align-center
 document.getElementById('btn-align-mr').addEventListener('click', () => alignLayer('middle-right'));
 document.getElementById('btn-align-bl').addEventListener('click', () => alignLayer('bottom-left'));
 document.getElementById('btn-align-bc').addEventListener('click', () => alignLayer('bottom-center'));
 document.getElementById('btn-align-br').addEventListener('click', () => alignLayer('bottom-right'));
 
 // Allineamento Relativo tra Elementi
 document.getElementById('btn-align-left-rel').addEventListener('click', () => alignLayersRelative('left'));
 document.getElementById('btn-align-center-h-rel').addEventListener('click', () => alignLayersRelative('center-h'));
 document.getElementById('btn-align-right-rel').addEventListener('click', () => alignLayersRelative('right'));
 document.getElementById('btn-align-top-rel').addEventListener('click', () => alignLayersRelative('top'));
 document.getElementById('btn-align-center-v-rel').addEventListener('click', () => alignLayersRelative('center-v'));
 document.getElementById('btn-align-bottom-rel').addEventListener('click', () => alignLayersRelative('bottom'));
 
 // Distribuzione Uniforme
 document.getElementById('btn-distribute-h').addEventListener('click', () => distributeLayersUniform('horizontal'));
 document.getElementById('btn-distribute-v').addEventListener('click', () => distributeLayersUniform('vertical'));
 
 // Sezione 7: Palette Colori
 document.getElementById('btn-save-color').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.color) {
 if (!state.colorPalette.includes(layer.color)) {
 state.colorPalette.push(layer.color);
 if (state.colorPalette.length > 10) state.colorPalette.shift(); // Max 10 colori
 localStorage.setItem('colorPalette_v21', JSON.stringify(state.colorPalette));
 updateColorPalette();
 // RIMOSSO (ridondante): announceGemini('Colore salvato nella palette', 'polite');
 } else {
 announceGemini('Colore già presente nella palette', 'polite');
 }
 }
 });
 
 // Sezione 12: Esplorazione Canvas - Pulsanti Step
 
 // Sezione 12: Esporta
 document.getElementById('btn-export-png').addEventListener('click', () => exportImage('png'));
 document.getElementById('btn-export-jpg').addEventListener('click', () => exportImage('jpeg'));
 document.getElementById('btn-save-project').addEventListener('click', saveProject);
 document.getElementById('load-project').addEventListener('change', e => {
 if (e.target.files[0]) {
 loadProject(e.target.files[0]);
 e.target.value = ''; // Reset
 }
 });
 
 // Sezione 9: Analisi
 document.getElementById('btn-analyze').addEventListener('click', runFullAnalysis);
 document.getElementById('btn-generate-alt').addEventListener('click', generateAltText);

 // Rinomina Livello
 document.getElementById('btn-rename-layer').addEventListener('click', () => {
 const layer = getSelectedLayer();
 const newName = document.getElementById('layer-name-input').value.trim();
 
 if (!layer) {
 // RIMOSSO (ridondante): announceGemini('Seleziona un livello da rinominare', 'assertive');
 return;
 }
 
 if (!newName) {
 announceGemini('Inserisci un nome', 'assertive');
 return;
 }
 
 layer.name = newName;
 saveState('Livello rinominato');
 updateLayerList();
 announceGemini(`Livello rinominato in: ${newName}`, 'polite');
 });
 
 // Sostituisci Immagine
 document.getElementById('replace-image').addEventListener('change', e => {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image') return;
 
 const file = e.target.files[0];
 if (!file) return;
 
 const reader = new FileReader();
 reader.onload = res => {
 const img = new Image();
 img.onload = () => {
 // Mantieni dimensioni e posizione attuali
 layer.imageElement = img;
 layer.imageData = res.target.result;
 saveState('Immagine sostituita');
 scheduleRender();
 // RIMOSSO: announceGemini('Immagine sostituita mantenendo dimensioni e posizione', 'polite'); // NVDA già legge il valore dello slider
 };
 img.src = res.target.result;
 };
 reader.readAsDataURL(file);
 e.target.value = ''; // Reset input
 });
 
 // Controlli Immagine - Flip
 document.getElementById('btn-flip-h').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 layer.flipH = !layer.flipH;
 saveState('Flip orizzontale');
 scheduleRender();
 announceGemini(`Immagine ${layer.flipH ? 'specchiata' : 'normale'} orizzontalmente`, 'polite');
 }
 });
 
 document.getElementById('btn-flip-v').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer && layer.type === 'image') {
 layer.flipV = !layer.flipV;
 saveState('Flip verticale');
 scheduleRender();
 announceGemini(`Immagine ${layer.flipV ? 'specchiata' : 'normale'} verticalmente`, 'polite');
 }
 });
 
 // Maschera di Ritaglio
 document.getElementById('btn-apply-mask').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image') {
 announceGemini('Seleziona un\'immagine per applicare la maschera', 'assertive');
 return;
 }
 
 const maskShape = document.getElementById('mask-shape').value;
 if (maskShape === 'none') {
 announceGemini('Seleziona una forma maschera', 'assertive');
 return;
 }
 
 layer.maskShape = maskShape;
 saveState('Maschera applicata');
 scheduleRender();
 
 const shapeNames = {
 'circle': 'Cerchio',
 'rounded': 'Rettangolo Arrotondato',
 'triangle': 'Triangolo',
 'star': 'Stella',
 'heart': 'Cuore',
 'hexagon': 'Esagono'
 };
 announceGemini(`Maschera ${shapeNames[maskShape]} applicata all'immagine`, 'polite');
 });
 
 document.getElementById('btn-remove-mask').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image') {
 // RIMOSSO (ridondante): announceGemini('Seleziona un\'immagine', 'assertive');
 return;
 }
 
 if (!layer.maskShape || layer.maskShape === 'none') {
 announceGemini('Nessuna maschera da rimuovere', 'polite');
 return;
 }
 
 layer.maskShape = 'none';
 saveState('Maschera rimossa');
 scheduleRender();
 announceGemini('Maschera rimossa', 'polite');
 });
 
 // Crop Preset
 document.getElementById('btn-apply-crop-preset').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image' || !layer.imageElement) return;
 
 const preset = document.getElementById('crop-preset').value;
 if (preset === 'none') {
 announceGemini('Seleziona un preset', 'assertive');
 return;
 }
 
 const img = layer.imageElement;
 let newW, newH;
 
 if (preset === 'square' || preset === '1:1') {
 const size = Math.min(img.width, img.height);
 newW = size;
 newH = size;
 } else if (preset === '16:9') {
 if (img.width / img.height > 16/9) {
 newH = img.height;
 newW = newH * 16/9;
 } else {
 newW = img.width;
 newH = newW * 9/16;
 }
 } else if (preset === '9:16') {
 if (img.width / img.height < 9/16) {
 newW = img.width;
 newH = newW * 16/9;
 } else {
 newH = img.height;
 newW = newH * 9/16;
 }
 } else if (preset === '4:3') {
 if (img.width / img.height > 4/3) {
 newH = img.height;
 newW = newH * 4/3;
 } else {
 newW = img.width;
 newH = newW * 3/4;
 }
 }
 
 layer.width = newW;
 layer.height = newH;
 saveState('Immagine ritagliata preset');
 scheduleRender();
 updateUI();
 announceGemini(`Ritaglio ${preset} applicato`, 'polite');
 });
 
 // Crop Manuale
 document.getElementById('btn-apply-crop-manual').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (!layer || layer.type !== 'image' || !layer.imageElement) return;
 
 const left = parseInt(document.getElementById('crop-left').value) || 0;
 const right = parseInt(document.getElementById('crop-right').value) || 0;
 const top = parseInt(document.getElementById('crop-top').value) || 0;
 const bottom = parseInt(document.getElementById('crop-bottom').value) || 0;
 
 if (left + right >= layer.width || top + bottom >= layer.height) {
 announceGemini('Valori di ritaglio troppo grandi', 'assertive');
 return;
 }
 
 layer.x += left;
 layer.y += top;
 layer.width -= (left + right);
 layer.height -= (top + bottom);
 
 // Reset input
 document.getElementById('crop-left').value = 0;
 document.getElementById('crop-right').value = 0;
 document.getElementById('crop-top').value = 0;
 document.getElementById('crop-bottom').value = 0;
 
 saveState('Immagine ritagliata manualmente');
 scheduleRender();
 updateUI();
 announceGemini('Ritaglio manuale applicato', 'polite');
 });
 
 // Rotazione Preset
 document.getElementById('btn-rotate-90').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.rotation = (layer.rotation + 90) % 360;
 document.getElementById('rotation').value = layer.rotation;
 document.getElementById('rotation-value').textContent = layer.rotation + '°';
 saveState('Rotazione 90°');
 scheduleRender();
 announceGemini('Ruotato di 90 gradi', 'polite');
 }
 });
 
 document.getElementById('btn-rotate-180').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.rotation = (layer.rotation + 180) % 360;
 document.getElementById('rotation').value = layer.rotation;
 document.getElementById('rotation-value').textContent = layer.rotation + '°';
 saveState('Rotazione 180°');
 scheduleRender();
 announceGemini('Ruotato di 180 gradi', 'polite');
 }
 });
 
 document.getElementById('btn-rotate-270').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.rotation = (layer.rotation + 270) % 360;
 document.getElementById('rotation').value = layer.rotation;
 document.getElementById('rotation-value').textContent = layer.rotation + '°';
 saveState('Rotazione 270°');
 scheduleRender();
 announceGemini('Ruotato di 270 gradi', 'polite');
 }
 });
 
 document.getElementById('btn-rotate-reset').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (layer) {
 layer.rotation = 0;
 document.getElementById('rotation').value = 0;
 document.getElementById('rotation-value').textContent = '0°';
 saveState('Rotazione reset');
 scheduleRender();
 announceGemini('Rotazione azzerata', 'polite');
 }
 });
 
 // Duplica con Offset
 document.getElementById('btn-duplicate-offset').addEventListener('click', () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da duplicare', 'assertive');
 return;
 }
 
 const offsetX = parseInt(document.getElementById('duplicate-offset-x').value) || 20;
 const offsetY = parseInt(document.getElementById('duplicate-offset-y').value) || 20;
 
 const clone = JSON.parse(JSON.stringify(layer));
 clone.x += offsetX;
 clone.y += offsetY;
 clone.name += ' copia';
 
 if (clone.type === 'image' && clone.imageData) {
 const img = new Image();
 img.onload = () => {
 clone.imageElement = img;
 addLayer(clone);
 // RIMOSSO (ridondante): announceGemini(`Livello duplicato e spostato di ${offsetX},${offsetY} pixel`, 'assertive');
 };
 img.src = clone.imageData;
 } else {
 addLayer(clone);
 announceGemini(`Livello duplicato e spostato di ${offsetX},${offsetY} pixel`, 'assertive');
 }
 });
 
 // Scala Percentuale
 const applyScale = (percent) => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un livello da ridimensionare', 'assertive');
 return;
 }
 
 // Validazione percentuale
 if (!percent || percent <= 0) {
 announceGemini('Percentuale non valida', 'assertive');
 return;
 }
 
 // LIMITE SICUREZZA: evita dimensioni troppo grandi o piccole
 const MIN_SIZE = 1;
 const MAX_SIZE = 10000;
 
 const scale = percent / 100;
 const newWidth = Math.round(layer.width * scale);
 const newHeight = Math.round(layer.height * scale);
 
 // Validazione risultato
 if (newWidth < MIN_SIZE || newHeight < MIN_SIZE) {
 // RIMOSSO (ridondante): announceGemini(`Dimensione troppo piccola. Minimo ${MIN_SIZE}px`, 'assertive');
 return;
 }
 
 if (newWidth > MAX_SIZE || newHeight > MAX_SIZE) {
 announceGemini(`Dimensione troppo grande. Massimo ${MAX_SIZE}px`, 'assertive');
 return;
 }
 
 // Memory check per immagini grandi
 if (layer.type === 'image') {
 const estimatedSize = newWidth * newHeight;
 const MAX_IMAGE_SIZE = 25000000; // 25M pixel
 if (estimatedSize > MAX_IMAGE_SIZE) {
 announceGemini('Immagine troppo grande dopo la scala. Riduci la percentuale.', 'assertive');
 return;
 }
 }
 
 // Applica scala
 layer.width = newWidth;
 layer.height = newHeight;
 
 // Aggiorna UI
 try {
 document.getElementById('width').value = layer.width;
 document.getElementById('height').value = layer.height;
 } catch (e) {
 logError('applyScale', e, 'Errore aggiornamento UI width/height');
 }
 
 saveState(`Scala ${percent}%`);
 scheduleRender();
 updateUI();
 announceGemini(`Livello scalato al ${percent}%. Nuove dimensioni: ${newWidth}x${newHeight} pixel`, 'polite');
 };
 
 document.getElementById('btn-apply-scale').addEventListener('click', () => {
 const percent = parseInt(document.getElementById('scale-percent').value) || 100;
 applyScale(percent);
 });
 
 document.getElementById('btn-scale-50').addEventListener('click', () => applyScale(50));
 document.getElementById('btn-scale-75').addEventListener('click', () => applyScale(75));
 document.getElementById('btn-scale-150').addEventListener('click', () => applyScale(150));
 document.getElementById('btn-scale-200').addEventListener('click', () => applyScale(200));
 
 // Toolbar
 document.getElementById('btn-undo').addEventListener('click', undo);
 document.getElementById('btn-redo').addEventListener('click', redo);
 
 // Guida e Modali
 document.getElementById('btn-keyboard-guide').addEventListener('click', showKeyboardGuide);
 const btnShowGuide = document.getElementById('btn-show-guide');
 if (btnShowGuide) btnShowGuide.addEventListener('click', showKeyboardGuide);
 document.getElementById('closeGuide').addEventListener('click', () => closeModal(modalGuide));
 document.getElementById('closeAnalysis').addEventListener('click', () => closeModal(modalAnalysis));
 document.getElementById('closeAltText').addEventListener('click', () => closeModal(modalAltText));
 
 // Modale API Config
 const btnOpenApiConfig = document.getElementById('btn-open-api-config');
 const btnCloseApiConfig = document.getElementById('closeApiConfig');
 const btnSaveApi = document.getElementById('btn-save-api');
 
 if (btnOpenApiConfig && modalApiConfig) {
 btnOpenApiConfig.addEventListener('click', () => {
 openModal(modalApiConfig);
 announceGemini('Configurazione API aperta', 'polite');
 });
 }
 
 if (btnCloseApiConfig && modalApiConfig) {
 btnCloseApiConfig.addEventListener('click', () => {
 closeModal(modalApiConfig);
 announceGemini('Configurazione API chiusa', 'polite');
 });
 }
 
 if (btnSaveApi && modalApiConfig) {
 btnSaveApi.addEventListener('click', () => {
 closeModal(modalApiConfig);
 announceGemini('API Key salvata', 'polite');
 });
 }
 
 const btnCloseExploreAdd = document.getElementById('closeExploreAdd');
 if (btnCloseExploreAdd && modalExploreAdd) {
 btnCloseExploreAdd.addEventListener('click', () => closeExploreAddModal());
 }

 const btnExploreAddText = document.getElementById('btn-explore-add-text');
 const btnExploreAddImage = document.getElementById('btn-explore-add-image');
 const btnExploreAddShape = document.getElementById('btn-explore-add-shape');
 const btnExploreAddVector = document.getElementById('btn-explore-add-vector');
 if (btnExploreAddText) {
 btnExploreAddText.addEventListener('click', () => {
 closeExploreAddModal();
 exploreAddTextAtCursor();
 });
 }
 if (btnExploreAddImage) {
 btnExploreAddImage.addEventListener('click', () => {
 closeExploreAddModal();
 exploreAddImageAtCursor();
 });
 }
 if (btnExploreAddShape) {
 btnExploreAddShape.addEventListener('click', () => {
 closeExploreAddModal();
 exploreAddShapeAtCursor();
 });
 }
 if (btnExploreAddVector) {
 btnExploreAddVector.addEventListener('click', () => {
 closeExploreAddModal();
 exploreStartVectorAtCursor();
 });
 }

 document.getElementById('copyAltText').addEventListener('click', () => { 
 navigator.clipboard.writeText(altTextBody.textContent);
 announceGemini('Testo copiato.', 'assertive');
 });

 // Zoom
 document.getElementById('btn-zoom-in').addEventListener('click', () => setZoom(state.zoom + 0.1));
 document.getElementById('btn-zoom-out').addEventListener('click', () => setZoom(state.zoom - 0.1));
 document.getElementById('btn-zoom-reset').addEventListener('click', () => setZoom(1));
 
 // Anteprima Fullscreen
 document.getElementById('btn-fullscreen').addEventListener('click', (e) => {
 try {
 elementToFocusAfterFullscreen = e.target;
 const fsCtx = fullscreenCanvas.getContext('2d');
 fullscreenCanvas.width = state.tpl.w;
 fullscreenCanvas.height = state.tpl.h;
 
 // Render pulito senza selezioni
 const selection = [...state.selectedIds];
 state.selectedIds = [];
 
 // Usa renderSync per assicurare che il render sia completo prima di drawImage
 renderSync();
 
 // Ripristina selezione SUBITO dopo il render
 state.selectedIds = selection;
 
 fsCtx.drawImage(canvas, 0, 0);
 
 // Re-renderizza il canvas principale per mostrare la selezione
 scheduleRender();
 
 // Mostra l'anteprima fullscreen
 fullscreenContainer.style.display = 'flex';
 
 // Prova a entrare in modalità fullscreen nativa del browser
 if (fullscreenContainer.requestFullscreen) {
 fullscreenContainer.requestFullscreen();
 } else if (fullscreenContainer.webkitRequestFullscreen) {
 fullscreenContainer.webkitRequestFullscreen();
 } else if (fullscreenContainer.mozRequestFullScreen) {
 fullscreenContainer.mozRequestFullScreen();
 } else if (fullscreenContainer.msRequestFullscreen) {
 fullscreenContainer.msRequestFullscreen();
 }
 } catch (error) {
 console.error('Errore fullscreen:', error);
 announceGemini('Errore durante l\'anteprima fullscreen', 'assertive');
 }
 });
 // Gestione eventi fullscreen per tutti i browser
 const fullscreenChangeHandler = () => {
 if (!document.fullscreenElement && !document.webkitFullscreenElement && 
 !document.mozFullScreenElement && !document.msFullscreenElement) {
 fullscreenContainer.style.display = 'none';
 if (elementToFocusAfterFullscreen) {
 elementToFocusAfterFullscreen.focus();
 elementToFocusAfterFullscreen = null;
 }
 }
 };
 
 // Salvo il handler per poterlo rimuovere durante il cleanup
 window.fullscreenChangeHandler = fullscreenChangeHandler;
 
 document.addEventListener('fullscreenchange', fullscreenChangeHandler);
 document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
 document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
 document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
 
 // Chiudi anteprima cliccando sull'immagine o sullo sfondo
 fullscreenContainer.addEventListener('click', () => {
 if (document.fullscreenElement || document.webkitFullscreenElement || 
 document.mozFullScreenElement || document.msFullscreenElement) {
 if (document.exitFullscreen) {
 document.exitFullscreen();
 } else if (document.webkitExitFullscreen) {
 document.webkitExitFullscreen();
 } else if (document.mozCancelFullScreen) {
 document.mozCancelFullScreen();
 } else if (document.msExitFullscreen) {
 document.msExitFullscreen();
 }
 } else {
 fullscreenContainer.style.display = 'none';
 if (elementToFocusAfterFullscreen) {
 elementToFocusAfterFullscreen.focus();
 elementToFocusAfterFullscreen = null;
 }
 }
 });

 // Mappa Sonora
 document.getElementById('btn-sound-map').addEventListener('click', toggleGridMode);

 // ===== SISTEMA AIUTO F2 =====
 const f2HelpModal = document.getElementById('f2-help-modal');
 const f2HelpBody = document.getElementById('f2-help-body');
 
 // Database delle spiegazioni per ogni elemento
 const helpDatabase = {
 'tpl': {
 title: 'Template Canvas (tpl)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di scegliere un formato predefinito per il canvas (l\'area di lavoro).' },
 { subtitle: 'Come si usa', text: 'Si apre il menu a tendina e si seleziona il preset desiderato (es. Post Instagram, Storia, Miniatura YouTube). Scegliendo "Personalizzato", si possono inserire manualmente larghezza e altezza.' },
 { subtitle: 'Consiglio', text: 'Usare i preset è il modo più rapido per essere sicuri che il progetto abbia le dimensioni corrette per la piattaforma social a cui è destinato (es. 1080x1080 per un post Instagram).' }
 ]
 },
 'canvas-width': {
 title: 'Larghezza canvas (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce la larghezza del canvas in pixel, solo quando il "Template" è impostato su "Personalizzato".' },
 { subtitle: 'Come si usa', text: 'Si digita un valore numerico nel campo. La larghezza determina la base orizzontale del progetto.' },
 { subtitle: 'Consiglio', text: 'Utile per formati non standard o per progetti destinati alla stampa che richiedono risoluzioni specifiche (es. 3000px).' }
 ]
 },
 'canvas-height': {
 title: 'Altezza canvas (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce l\'altezza del canvas in pixel, solo quando il "Template" è impostato su "Personalizzato".' },
 { subtitle: 'Come si usa', text: 'Si digita un valore numerico nel campo. Insieme alla larghezza, determina l\'orientamento (orizzontale, verticale, quadrato).' },
 { subtitle: 'Consiglio', text: 'Per un post quadrato inserire lo stesso valore di "Larghezza canvas" (es. 1080).' }
 ]
 },
 'show-grid': {
 title: 'Mostra griglia di aiuto',
 sections: [
 { subtitle: 'Cosa fa', text: 'Visualizza una griglia a quadretti sopra il canvas, utile come riferimento per allineare gli elementi.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella di spunta. La griglia non apparirà nell\'immagine finale esportata.' },
 { subtitle: 'Consiglio', text: 'È fondamentale per creare layout ordinati e per assicurarsi che testi e immagini siano allineati tra loro in modo preciso.' }
 ]
 },
 'grid-size': {
 title: 'Dimensione griglia (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta la distanza in pixel tra le linee della griglia (sia orizzontali che verticali).' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore numerico. Valori piccoli (es. 10) creano una griglia fitta, valori grandi (es. 100) una griglia larga.' },
 { subtitle: 'Consiglio', text: 'Una griglia fitta (es. 20px) è utile per allineamenti di precisione. Una griglia larga (es. 100px) aiuta a dividere il canvas in sezioni (es. regola dei terzi).' }
 ]
 },
 'snap-to-grid': {
 title: 'Snap alla griglia',
 sections: [
 { subtitle: 'Cosa fa', text: '"Aggancia" automaticamente gli oggetti alle linee della griglia più vicine quando vengono spostati o ridimensionati.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella di spunta. Funziona solo se la "Mostra griglia di aiuto" è attiva.' },
 { subtitle: 'Consiglio', text: 'Accelera molto il lavoro di impaginazione, garantendo un allineamento perfetto senza doverlo fare manualmente pixel per pixel.' }
 ]
 },
 'bg-type': {
 title: 'Tipo sfondo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di scegliere il tipo di riempimento per lo sfondo dell\'intero canvas.' },
 { subtitle: 'Come si usa', text: 'Si seleziona dal menu: "Colore Solido" (un unico colore), "Gradiente" (sfumatura tra due colori) o "Immagine" (una foto o texture).' },
 { subtitle: 'Consiglio', text: 'Il colore solido è ottimo per la leggibilità. Il gradiente aggiunge profondità. L\'immagine è d\'impatto, ma bisogna assicurarsi che il testo sopra resti leggibile (spesso sfocando l\'immagine o aggiungendo un\'ombra al testo).' }
 ]
 },
 'bg-color': {
 title: 'Colore sfondo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta un colore di fondo solido e uniforme per il canvas (funziona solo se "Tipo sfondo" è "Colore Solido").' },
 { subtitle: 'Come si usa', text: 'Si clicca sul selettore per scegliere un colore o si incolla un codice esadecimale (es. #FFFFFF per il bianco).' },
 { subtitle: 'Consiglio', text: 'È fondamentale scegliere un colore che abbia un buon contrasto con i testi e le immagini che verranno aggiunti sopra.' }
 ]
 },
 'bg-gradient-color1': {
 title: 'Gradiente - Colore 1',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce il colore di partenza della sfumatura di sfondo (se "Tipo sfondo" è "Gradiente").' },
 { subtitle: 'Come si usa', text: 'Si sceglie il primo colore del gradiente. Sarà combinato con il "Colore 2".' },
 { subtitle: 'Consiglio', text: 'Per sfumature delicate, scegliere due tonalità simili (es. blu chiaro e blu scuro). Per effetti d\'impatto, usare colori complementari.' }
 ]
 },
 'bg-gradient-color2': {
 title: 'Gradiente - Colore 2',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce il colore finale della sfumatura di sfondo (se "Tipo sfondo" è "Gradiente").' },
 { subtitle: 'Come si usa', text: 'Si sceglie il secondo colore. La transizione andrà dal Colore 1 al Colore 2.' },
 { subtitle: 'Consiglio', text: 'Mantenere una certa coerenza cromatica: se il primo colore è caldo (rosso, arancione), il secondo dovrebbe essere anch\'esso caldo per un risultato armonioso.' }
 ]
 },
 'bg-gradient-type': {
 title: 'Tipo di gradiente',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce la direzione o forma della sfumatura di sfondo.' },
 { subtitle: 'Come si usa', text: 'Si sceglie tra "Lineare" (gradiente dritto) o "Radiale" (gradiente circolare che si espande dal centro).' },
 { subtitle: 'Consiglio', text: 'Il gradiente lineare è ottimo per sfondi sobri e moderni. Il gradiente radiale crea un effetto "spotlight" che attira l\'occhio al centro.' }
 ]
 },
 'bg-gradient-angle': {
 title: 'Angolo gradiente (gradi)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ruota la direzione del gradiente lineare (da 0 a 360 gradi).' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider o si inserisce un valore. 0° è orizzontale da sinistra a destra, 90° è verticale dall\'alto in basso, 180° è orizzontale da destra a sinistra, ecc.' },
 { subtitle: 'Consiglio', text: 'Un angolo di 135° (diagonale dall\'alto a sinistra verso il basso a destra) è molto popolare nei design moderni.' }
 ]
 },
 'bg-image-fit': {
 title: 'Adattamento immagine sfondo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Controlla come l\'immagine di sfondo si adatta alle dimensioni del canvas.' },
 { subtitle: 'Come si usa', text: 'Si sceglie tra "Copri" (l\'immagine riempie tutto il canvas, anche se viene tagliata), "Contieni" (l\'immagine è interamente visibile, possono comparire barre vuote), o "Ripeti" (l\'immagine viene ripetuta come una texture).' },
 { subtitle: 'Consiglio', text: '"Copri" è ideale per foto di sfondo. "Contieni" è perfetto per loghi o elementi che non devono essere tagliati. "Ripeti" è ottimo per pattern e texture.' }
 ]
 },
 'new-img-x': {
 title: 'Posizione X nuova immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce la posizione orizzontale (asse X) dove verrà inserita una nuova immagine sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. 0 è il bordo sinistro del canvas. Valori maggiori spostano l\'immagine verso destra.' },
 { subtitle: 'Consiglio', text: 'Per centrare orizzontalmente un\'immagine di larghezza nota, calcolare: (larghezza canvas - larghezza immagine) / 2.' }
 ]
 },
 'new-img-y': {
 title: 'Posizione Y nuova immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce la posizione verticale (asse Y) dove verrà inserita una nuova immagine sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. 0 è il bordo superiore del canvas. Valori maggiori spostano l\'immagine verso il basso.' },
 { subtitle: 'Consiglio', text: 'Per posizionare un\'immagine al centro verticale, usare lo stesso calcolo: (altezza canvas - altezza immagine) / 2.' }
 ]
 },
 'text-input': {
 title: 'Contenuto testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Area dove si digita il testo che verrà aggiunto come livello sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si scrive il testo desiderato. Supporta più righe (premere Invio per andare a capo).' },
 { subtitle: 'Consiglio', text: 'Testi brevi e incisivi funzionano meglio sui social. Per titoli, usare massimo 5-7 parole. Per descrizioni, massimo 2-3 righe.' }
 ]
 },
 'nff': {
 title: 'Famiglia font',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sceglie il carattere tipografico (font) per il nuovo testo.' },
 { subtitle: 'Come si usa', text: 'Si seleziona dal menu a tendina. Sono disponibili 17 font: Arial, Montserrat, Open Sans, Roboto, Lato, Poppins, Raleway, Oswald, Merriweather, Playfair Display, Georgia, Times New Roman, Courier New, Verdana, Trebuchet MS, Impact, Comic Sans MS.' },
 { subtitle: 'Consiglio', text: 'Per progetti moderni: Montserrat, Roboto, Poppins, Raleway. Per massima leggibilità: Arial, Open Sans, Lato. Per eleganza: Georgia, Playfair Display, Merriweather. Per titoli impattanti: Oswald, Impact. Per codice: Courier New.' }
 ]
 },
 'new-font-size': {
 title: 'Dimensione font',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta la grandezza del testo in pixel.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un numero (minimo 8, massimo 200). Valori comuni: 16-24 per testo normale, 32-48 per titoli, 60+ per headline.' },
 { subtitle: 'Consiglio', text: 'Per un post Instagram 1080x1080, usare 40-60px per il titolo principale e 24-32px per il testo secondario.' }
 ]
 },
 'nfw': {
 title: 'Peso font',
 sections: [
 { subtitle: 'Cosa fa', text: 'Controlla lo spessore del carattere (quanto è "grassetto").' },
 { subtitle: 'Come si usa', text: 'Si sceglie un valore da 100 (sottilissimo) a 900 (nerissimo). 400 è normale, 700 è grassetto standard.' },
 { subtitle: 'Consiglio', text: 'Usare 700 o superiore per titoli che devono risaltare. Usare 300-400 per testi lunghi o didascalie.' }
 ]
 },
 'new-text-color': {
 title: 'Colore testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore del testo che verrà aggiunto.' },
 { subtitle: 'Come si usa', text: 'Si clicca sul selettore colore per scegliere la tonalità desiderata.' },
 { subtitle: 'Consiglio', text: 'Il nero (#000000) e il bianco (#FFFFFF) sono sempre efficaci. Per un look moderno, usare grigio scuro (#2d3748) invece del nero puro.' }
 ]
 },
 'new-line-height': {
 title: 'Interlinea',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola lo spazio verticale tra le righe di testo in un livello testo multi-riga.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 1.0 significa nessuno spazio extra, 1.5 aggiunge il 50% di spazio tra le righe, ecc.' },
 { subtitle: 'Consiglio', text: 'Per testi lunghi, usare 1.4-1.6 per migliorare la leggibilità. Per titoli su più righe, 1.1-1.2 crea un aspetto più compatto.' }
 ]
 },
 'new-letter-spacing': {
 title: 'Spaziatura lettere',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aumenta o diminuisce lo spazio orizzontale tra ogni lettera del testo.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. Valori positivi allargano le lettere, valori negativi le stringono. 0 è lo spazio predefinito del font.' },
 { subtitle: 'Consiglio', text: 'Una leggera spaziatura positiva (+1 o +2px) su testi in maiuscolo li rende più leggibili ed eleganti. Evitare valori negativi a meno che non sia un effetto ricercato.' }
 ]
 },
 'x': {
 title: 'Posizione X del livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sposta il livello selezionato orizzontalmente sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si modifica il valore in pixel. 0 è il bordo sinistro. Valori più alti spostano l\'elemento verso destra.' },
 { subtitle: 'Consiglio', text: 'Usare anche le frecce della tastiera per spostamenti precisi quando il livello è selezionato.' }
 ]
 },
 'y': {
 title: 'Posizione Y del livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sposta il livello selezionato verticalmente sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si modifica il valore in pixel. 0 è il bordo superiore. Valori più alti spostano l\'elemento verso il basso.' },
 { subtitle: 'Consiglio', text: 'Combinare con la griglia e lo snap per posizionamenti precisi e allineati.' }
 ]
 },
 'width': {
 title: 'Larghezza livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Modifica la larghezza del livello selezionato in pixel.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un nuovo valore. Per immagini, è meglio usare la "Scala Percentuale" per mantenere le proporzioni.' },
 { subtitle: 'Consiglio', text: 'Modificare larghezza e altezza separatamente può distorcere immagini. Preferire sempre il ridimensionamento proporzionale.' }
 ]
 },
 'height': {
 title: 'Altezza livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Modifica l\'altezza del livello selezionato in pixel.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un nuovo valore. Attenzione a non distorcere immagini modificando solo l\'altezza.' },
 { subtitle: 'Consiglio', text: 'Per ridimensionare proporzionalmente, calcolare il rapporto larghezza/altezza originale e mantenerlo.' }
 ]
 },
 'scale-percent': {
 title: 'Scala percentuale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ridimensiona il livello selezionato in base a una percentuale (es. 50% per dimezzare, 200% per raddoppiare).' },
 { subtitle: 'Come si usa', text: 'Si inserisce una percentuale (es. 150) e si preme "Applica". I pulsanti rapidi (50%, 150%, ecc.) fanno la stessa cosa.' },
 { subtitle: 'Consiglio', text: 'È il modo più rapido per ridimensionare un elemento mantenendo le proporzioni, senza dover calcolare i pixel.' }
 ]
 },
 'rotation': {
 title: 'Rotazione (gradi)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ruota il livello selezionato (da 0 a 360 gradi).' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider o si inserisce un valore. I pulsanti (90°, 180°, ecc.) applicano rotazioni standard.' },
 { subtitle: 'Consiglio', text: 'Una leggera rotazione (es. -5 gradi) può dare un aspetto più informale e dinamico (es. per una foto o un "timbro").' }
 ]
 },
 'opacity': {
 title: 'Opacità (%)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola la trasparenza del livello selezionato.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 100% è completamente opaco (visibile). 0% è completamente trasparente (invisibile).' },
 { subtitle: 'Consiglio', text: 'Ottimo per creare "watermark" (loghi semi-trasparenti, es. 20% opacità) o per sfumare immagini sullo sfondo (es. 80% opacità).' }
 ]
 },
 'corner-radius': {
 title: 'Arrotondamento angoli (rettangolo)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Arrotonda gli angoli di un livello forma "Rettangolo" già esistente.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un rettangolo sul canvas e si usa lo slider per aumentare o diminuire l\'arrotondamento (misurato in pixel).' },
 { subtitle: 'Consiglio', text: 'Permette di trasformare un rettangolo in un "badge" o in un pulsante con angoli smussati.' }
 ]
 },
 'shc': {
 title: 'Colore ombra',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore dell\'ombra (se "Ombra" è attiva).' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore. Di solito si usa il nero o un grigio molto scuro.' },
 { subtitle: 'Consiglio', text: 'Per un\'ombra realistica, usare il nero ma con una bassa opacità (selezionabile dal selettore colore), o usare un grigio scuro come #333333.' }
 ]
 },
 'shadow-blur': {
 title: 'Sfocatura ombra (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola quanto sfocata (morbida) o netta (dura) è l\'ombra.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0px è un\'ombra netta, identica all\'oggetto. Valori alti (10-20px) creano un\'ombra molto morbida e diffusa.' },
 { subtitle: 'Consiglio', text: 'Per un effetto "sollevato" realistico, usare una sfocatura media (es. 8-16px). Per un effetto "testo 3D", usare sfocatura 0 o 1.' }
 ]
 },
 'shadow-x': {
 title: 'Offset X ombra (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sposta l\'ombra orizzontalmente (a destra o sinistra) rispetto all\'oggetto.' },
 { subtitle: 'Come si usa', text: 'Valori positivi spostano l\'ombra a destra. Valori negativi la spostano a sinistra.' },
 { subtitle: 'Consiglio', text: 'Per simulare una luce che arriva dall\'angolo in alto a sinistra, usare un Offset X positivo (es. 4px) e un Offset Y positivo (es. 4px).' }
 ]
 },
 'shadow-y': {
 title: 'Offset Y ombra (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sposta l\'ombra verticalmente (in alto o in basso) rispetto all\'oggetto.' },
 { subtitle: 'Come si usa', text: 'Valori positivi spostano l\'ombra in basso. Valori negativi la spostano in alto.' },
 { subtitle: 'Consiglio', text: 'Un\'ombra con Offset Y positivo (spostata in basso) è l\'effetto più naturale, poiché simula una fonte di luce dall\'alto.' }
 ]
 },
 'blend-mode': {
 title: 'Modalità di fusione',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce come i colori del livello selezionato interagiscono con i colori dei livelli sottostanti.' },
 { subtitle: 'Come si usa', text: 'Si sceglie dal menu. "Normale" è lo standard. "Moltiplica" scurisce (come un pennarello). "Scolora" schiarisce (come una luce). "Sovrapponi" aumenta il contrasto.' },
 { subtitle: 'Consiglio', text: 'È un effetto avanzato. "Moltiplica" è ottimo per applicare texture scure. "Sovrapponi" è utile per fondere colori in modo vivido.' }
 ]
 },
 'crop-left': {
 title: 'Ritaglio - taglia sinistra (px)',
 sections: [
 { subtitle: 'Cosa fa', text: '"Taglia" via una porzione dell\'immagine dal bordo sinistro.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel per definire quanti pixel tagliare. L\'immagine verrà ristretta da sinistra.' },
 { subtitle: 'Consiglio', text: 'Utile per eliminare elementi indesiderati sul lato di una foto o per stringere l\'inquadratura sul soggetto.' }
 ]
 },
 'crop-right': {
 title: 'Ritaglio - taglia destra (px)',
 sections: [
 { subtitle: 'Cosa fa', text: '"Taglia" via una porzione dell\'immagine dal bordo destro.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. L\'immagine verrà ristretta da destra.' },
 { subtitle: 'Consiglio', text: 'Permette di ritagliare (crop) un\'immagine in modo non distruttivo (il ritaglio si può modificare dopo).' }
 ]
 },
 'crop-top': {
 title: 'Ritaglio - taglia alto (px)',
 sections: [
 { subtitle: 'Cosa fa', text: '"Taglia" via una porzione dell\'immagine dal bordo superiore.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. Utile per eliminare cieli vuoti o spazio inutile sopra un soggetto.' },
 { subtitle: 'Consiglio', text: 'Combinando i 4 controlli di ritaglio (alto, basso, sinistra, destra) si può ricomporre l\'inquadratura di una foto.' }
 ]
 },
 'crop-bottom': {
 title: 'Ritaglio - taglia basso (px)',
 sections: [
 { subtitle: 'Cosa fa', text: '"Taglia" via una porzione dell\'immagine dal bordo inferiore.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel per rimuovere la parte inferiore dell\'immagine.' },
 { subtitle: 'Consiglio', text: 'Utile per rifinire composizioni verticali o eliminare parti superflue in basso.' }
 ]
 },
 'filter-brightness': {
 title: 'Luminosità (−100…+100)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Schiarisce o scurisce TUTTA l\'immagine allo stesso modo. +50 = tutto più chiaro, -50 = tutto più scuro.' },
 { subtitle: 'Come si usa', text: 'Muovi lo slider. È veloce e semplice, ma "grossolano" - non recupera dettagli persi.' },
 { subtitle: 'Quando usarlo', text: 'Per aggiustamenti veloci tipo "la foto è un po\' scura, la schiarisco". Se hai OMBRE NERE dove non si vede niente o LUCI BRUCIATE bianche, usa Auto Levels negli Effetti Avanzati.' }
 ]
 },
 'filter-contrast': {
 title: 'Contrasto (−100…+100)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aumenta la DIFFERENZA tra chiaro e scuro. I neri diventano più neri, i bianchi più bianchi. Rende la foto più "vivace".' },
 { subtitle: 'Come si usa', text: 'Prova +10 o +20. È perfetto per foto "piatte" che sembrano spente. NON esagerare o perdi dettagli.' },
 { subtitle: 'Quando usarlo', text: 'Dopo Brightness, se la foto è ancora "spenta". È diverso da Auto Levels: Contrast dà "punch", Auto Levels recupera dettagli persi.' }
 ]
 },
 'filter-saturation': {
 title: 'Saturazione (−100…+100)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aumenta o diminuisce l\'intensità dei colori dell\'immagine.' },
 { subtitle: 'Come si usa', text: 'Valori positivi rendono i colori più vividi. Valori negativi li attenuano. -100 rende l\'immagine in bianco e nero.' },
 { subtitle: 'Consiglio', text: 'Una leggera desaturazione (-10, -20) crea un look vintage. Una saturazione aumentata (+20, +30) dà un aspetto più "Instagram".' }
 ]
 },
 'filter-hue': {
 title: 'Tonalità Hue (-180°…+180°)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ruota tutti i colori dell\'immagine lungo la ruota cromatica.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider da -180 a +180 gradi. Ogni valore sposta i colori: es. il rosso può diventare ciano a +180°, il blu può diventare giallo a -120°, ecc.' },
 { subtitle: 'Consiglio', text: 'È un effetto creativo. Utile per cambiare rapidamente la palette colori di un\'illustrazione o per effetti psichedelici. Prova 90° o -90° per effetti interessanti.' }
 ]
 },
 'filter-blur': {
 title: 'Sfocatura (0…50)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Applica un effetto sfocatura (blur) all\'immagine selezionata.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0 è nessuna sfocatura (immagine nitida). Valori alti (20-50) creano una sfocatura molto pronunciata.' },
 { subtitle: 'Consiglio', text: 'Una leggera sfocatura (3-8) su un\'immagine di sfondo migliora la leggibilità del testo soprastante. Valori alti creano un effetto "fuori fuoco" artistico.' }
 ]
 },
 'filter-grayscale': {
 title: 'Scala di grigi (%)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Converte gradualmente l\'immagine in bianco e nero.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0% è l\'immagine a colori originale. 100% è completamente in bianco e nero.' },
 { subtitle: 'Consiglio', text: 'Il bianco e nero totale (100%) dona eleganza e atemporalità. Un valore parziale (50%) crea un effetto "desaturato" moderno.' }
 ]
 },
 'filter-sepia': {
 title: 'Seppia (%)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Applica un effetto seppia (tonalità marrone-giallastro) all\'immagine, tipico delle foto d\'epoca.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0% è nessun effetto. 100% è il massimo effetto seppia.' },
 { subtitle: 'Consiglio', text: 'Il seppia dà immediatamente un aspetto vintage, retrò, nostalgico. Perfetto per foto che vogliono evocare il passato.' }
 ]
 },
 'filter-invert': {
 title: 'Inverti (%)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Inverte i colori dell\'immagine (come un "negativo fotografico").' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0% è nessuna inversione. 100% inverte completamente i colori (il nero diventa bianco, il bianco diventa nero, ecc.).' },
 { subtitle: 'Consiglio', text: 'È un effetto forte e creativo. Usato al 100% può creare immagini molto artistiche e irreali.' }
 ]
 },
 'shape-fill': {
 title: 'Colore riempimento forma',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore interno (riempimento) di una forma selezionata (rettangolo, cerchio, stella, ecc.).' },
 { subtitle: 'Come si usa', text: 'Si seleziona una forma esistente sul canvas e si sceglie un colore dal selettore.' },
 { subtitle: 'Consiglio', text: 'Per forme che fungono da sfondo per testo, scegliere colori con buon contrasto rispetto al testo stesso.' }
 ]
 },
 'shape-stroke': {
 title: 'Colore bordo forma',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore del contorno esterno di una forma.' },
 { subtitle: 'Come si usa', text: 'Si seleziona una forma e si sceglie un colore. Il bordo apparirà solo se "Spessore bordo" è maggiore di 0.' },
 { subtitle: 'Consiglio', text: 'Un bordo dello stesso colore ma più scuro del riempimento crea profondità. Un bordo bianco o nero può dare un effetto "fumetto".' }
 ]
 },
 'shape-stroke-width': {
 title: 'Spessore bordo forma (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Controlla lo spessore in pixel del contorno della forma.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore numerico. 0 significa nessun bordo. Valori comuni: 2-5px per bordi sottili, 10-20px per bordi marcati.' },
 { subtitle: 'Consiglio', text: 'Bordi spessi (8-15px) sono di tendenza nei design moderni e flat. Bordi sottili (1-3px) sono più eleganti e minimali.' }
 ]
 },
 'vector-step': {
 title: 'Passo cursore vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Determina di quanti pixel si muove il cursore nel disegno vettoriale quando si usano le frecce direzionali.' },
 { subtitle: 'Come si usa', text: 'Si imposta un valore. Valori bassi (1-5px) permettono movimenti precisi. Valori alti (10-20px) accelerano il movimento.' },
 { subtitle: 'Consiglio', text: 'Iniziare con 5px per un buon equilibrio tra precisione e velocità. Ridurre a 1px per dettagli finissimi.' }
 ]
 },
 'vector-fill': {
 title: 'Colore riempimento vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore interno della forma che verrà disegnata in modalità vettoriale.' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore prima di iniziare a disegnare o mentre si sta disegnando.' },
 { subtitle: 'Consiglio', text: 'Per forme decorative, scegliere colori in armonia con la palette generale del progetto.' }
 ]
 },
 'vector-stroke': {
 title: 'Colore bordo vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore del contorno della forma disegnata vettorialmente.' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore. Il bordo sarà visibile solo se "Spessore bordo" è maggiore di 0.' },
 { subtitle: 'Consiglio', text: 'Un bordo contrastante rende la forma più definita e leggibile, specialmente se sovrapposta ad altri elementi.' }
 ]
 },
 'vector-stroke-width': {
 title: 'Spessore bordo vettoriale (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce lo spessore del contorno della forma vettoriale in pixel.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore. 0 per nessun bordo, 1-3 per linee sottili, 5-10 per linee marcate.' },
 { subtitle: 'Consiglio', text: 'Per disegni stilizzati o icone, un bordo di 3-5px è ideale.' }
 ]
 },
 'duplicate-offset-x': {
 title: 'Offset X duplicazione',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce di quanti pixel a destra (valori positivi) o a sinistra (valori negativi) verrà spostato un livello duplicato rispetto all\'originale.' },
 { subtitle: 'Come si usa', text: 'Si imposta un valore prima di premere "Duplica con Offset". Es. 20 sposterà la copia di 20px a destra.' },
 { subtitle: 'Consiglio', text: 'Usare piccoli offset (10-30px) per creare effetti "eco" o ombra. Offset grandi per distribuire copie su aree più ampie.' }
 ]
 },
 'duplicate-offset-y': {
 title: 'Offset Y duplicazione',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce di quanti pixel in basso (valori positivi) o in alto (valori negativi) verrà spostato un livello duplicato.' },
 { subtitle: 'Come si usa', text: 'Si imposta un valore. Es. 20 sposterà la copia di 20px verso il basso.' },
 { subtitle: 'Consiglio', text: 'Combinare con Offset X per diagonali. Es. X=15, Y=15 duplica in diagonale verso destra-basso.' }
 ]
 },
 'text-align': {
 title: 'Allineamento testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Allinea il testo all\'interno del suo riquadro: a sinistra, centrato, o a destra.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un livello testo e si sceglie l\'allineamento desiderato dai pulsanti.' },
 { subtitle: 'Consiglio', text: 'Il centrato è ideale per titoli e citazioni. Il testo a sinistra è più leggibile per paragrafi lunghi. Il testo a destra è usato raramente, ma può creare asimmetrie interessanti.' }
 ]
 },
 'zoom': {
 title: 'Zoom canvas',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ingrandisce o rimpicciolisce la visualizzazione del canvas senza modificare le dimensioni effettive del progetto.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider o i pulsanti +/-. Lo zoom non influisce sull\'esportazione finale.' },
 { subtitle: 'Consiglio', text: 'Zoomare al 200-300% per lavori di precisione (es. allineamenti pixel-perfect). Zoomare al 50-75% per avere una visione d\'insieme.' }
 ]
 },
 'crop-preset': {
 title: 'Preset ritaglio',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di ritagliare l\'immagine selezionata secondo proporzioni predefinite (es. 1:1 quadrato, 16:9 panoramico, ecc.).' },
 { subtitle: 'Come si usa', text: 'Si seleziona un\'immagine, si sceglie il preset desiderato e si clicca "Ritaglia con Preset". L\'immagine verrà ritagliata mantenendo le proporzioni scelte.' },
 { subtitle: 'Consiglio', text: 'Usare 1:1 per post Instagram quadrati. 16:9 è perfetto per miniature YouTube. 9:16 è ideale per Storie e Reels.' }
 ]
 },
 'crop-shape': {
 title: 'Forma ritaglio',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ritaglia l\'immagine in forme specifiche come cerchio, stella, cuore, esagono, ecc.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un\'immagine, si sceglie la forma desiderata dal menu e si applica il ritaglio.' },
 { subtitle: 'Consiglio', text: 'Il cerchio è perfetto per foto profilo. Le stelle e i cuori creano effetti decorativi. L\'esagono è molto usato nei design moderni.' }
 ]
 },
 'new-text-x': {
 title: 'Posizione X nuovo testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce la coordinata orizzontale (asse X) dove apparirà il nuovo testo (0 = bordo sinistro).' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. Definisce il punto di partenza (o il centro, se centrato) del blocco di testo.' },
 { subtitle: 'Consiglio', text: 'Si può lasciare il valore predefinito e poi usare i controlli di allineamento per posizionare il testo più facilmente.' }
 ]
 },
 'new-text-y': {
 title: 'Posizione Y nuovo testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce la coordinata verticale (asse Y) dove apparirà il nuovo testo (0 = bordo superiore).' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel. Utile per posizionare il testo a un\'altezza specifica.' },
 { subtitle: 'Consiglio', text: 'Per i post sui social, è bene lasciare sempre un "margine di sicurezza" (es. 60-100px) dai bordi superiore e inferiore.' }
 ]
 },
 'new-shape-fill': {
 title: 'Riempimento nuova forma',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore interno della forma che si sta per aggiungere (es. il colore di un rettangolo).' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore dal selettore prima di cliccare su uno dei pulsanti delle forme.' },
 { subtitle: 'Consiglio', text: 'Utile per creare "box" colorati dietro ai testi per farli risaltare.' }
 ]
 },
 'new-shape-stroke': {
 title: 'Bordo nuova forma',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore del contorno (bordo) della forma che si sta per aggiungere.' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore. Il bordo sarà visibile solo se lo "Spessore bordo" è maggiore di 0.' },
 { subtitle: 'Consiglio', text: 'Un bordo scuro su un riempimento chiaro crea un effetto "fumetto" o "evidenziato".' }
 ]
 },
 'new-shape-stroke-width': {
 title: 'Spessore bordo nuova forma',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce lo spessore in pixel del bordo della forma che verrà creata.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore numerico. 0 = nessun bordo. 2-5 = bordo sottile. 10+ = bordo spesso.' },
 { subtitle: 'Consiglio', text: 'Per icone e design flat, usare 3-5px. Per effetti più artistici, provare 8-15px.' }
 ]
 },
 'new-corner-radius': {
 title: 'Arrotondamento angoli nuovo rettangolo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta quanto saranno arrotondati gli angoli del rettangolo che si sta per creare.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider prima di aggiungere il rettangolo. 0 = angoli vivi (90°). Valori alti = angoli molto arrotondati.' },
 { subtitle: 'Consiglio', text: 'Un arrotondamento di 10-20px crea "box" moderni per contenere testi. Valori molto alti (50+) creano forme a "pillola".' }
 ]
 },
 'new-line-style': {
 title: 'Stile linea/bordo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta lo stile del bordo della forma (se il bordo è attivo).' },
 { subtitle: 'Come si usa', text: 'Si sceglie "Solida" (linea continua), "Tratteggiata" (linee separate) o "Puntinata" (punti).' },
 { subtitle: 'Consiglio', text: 'Tratteggiata o Puntinata sono ottime per creare cornici decorative o per indicare aree (es. "ritaglia qui").' }
 ]
 },
 'layer-name': {
 title: 'Nome livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Mostra e permette di modificare il nome del livello selezionato.' },
 { subtitle: 'Come si usa', text: 'Si clicca nel campo e si digita un nuovo nome. Il nome aiuta a organizzare i livelli in progetti complessi.' },
 { subtitle: 'Consiglio', text: 'Dare nomi descrittivi ai livelli (es. "Titolo Principale", "Logo", "Sfondo Texture") rende molto più facile trovare e modificare elementi in progetti con molti livelli.' }
 ]
 },
 'search-layer': {
 title: 'Cerca livello',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di cercare un livello specifico digitando parte del suo nome.' },
 { subtitle: 'Come si usa', text: 'Si digita nel campo di ricerca. La lista dei livelli mostrerà solo quelli che contengono il testo cercato.' },
 { subtitle: 'Consiglio', text: 'Molto utile in progetti con 10+ livelli. Cercare "testo" mostrerà tutti i livelli di testo, ad esempio.' }
 ]
 },
 'new-shape-x': {
 title: 'Posizione iniziale X (forma)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce la coordinata orizzontale (asse X) dove apparirà la nuova forma.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel (0 = bordo sinistro).' },
 { subtitle: 'Consiglio', text: 'Come per il testo, si può lasciare il valore predefinito e poi usare gli strumenti di allineamento per centrare la forma.' }
 ]
 },
 'new-shape-y': {
 title: 'Posizione iniziale Y (forma)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce la coordinata verticale (asse Y) dove apparirà la nuova forma.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore in pixel (0 = bordo superiore).' },
 { subtitle: 'Consiglio', text: 'Utile per posizionare forme in modo preciso (es. una linea orizzontale a Y: 540 per dividere a metà un canvas 1080p).' }
 ]
 },
 'text-edit': {
 title: 'Modifica contenuto testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di cambiare il testo di un livello di testo già esistente sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un livello di testo sul canvas. Il suo testo apparirà qui. Si modifica e si preme "Applica Modifiche".' },
 { subtitle: 'Consiglio', text: 'Questo è il modo corretto per correggere un errore di battitura o aggiornare un testo, senza doverlo cancellare e ricreare.' }
 ]
 },
 'ff': {
 title: 'Famiglia font (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia il font del livello di testo attualmente selezionato. Sistema intelligente: se sei online hai accesso a 900+ Google Fonts (marcati con ), se sei offline usa 13 font di sistema garantiti (marcati con ).' },
 { subtitle: 'Come si usa', text: 'Seleziona un testo sul canvas, poi scegli un font dal menu. L\'app rileva automaticamente la tua connessione e ti mostra i font disponibili. Se passi da online a offline (o viceversa), la lista si aggiorna automaticamente.' },
 { subtitle: 'Consiglio', text: 'Google Fonts () offrono più varietà e stili moderni. Font di sistema () caricano istantaneamente e funzionano sempre, anche offline. System UI si adatta automaticamente al tuo sistema operativo per un look nativo.' }
 ]
 },
 'font-size': {
 title: 'Dimensione font (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia la dimensione del livello di testo attualmente selezionato.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un nuovo valore numerico. Il testo sul canvas si ridimensionerà in tempo reale.' },
 { subtitle: 'Consiglio', text: 'Si può usare questo campo o si può ridimensionare il testo trascinando i suoi angoli sul canvas.' }
 ]
 },
 'fw': {
 title: 'Peso font (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia lo spessore (grassetto) del livello di testo attualmente selezionato.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un nuovo peso (es. da "Regular 400" a "Bold 700") dal menu.' },
 { subtitle: 'Consiglio', text: 'Molto utile per dare enfasi a una singola parola (se prima è stata aggiunta come livello separato).' }
 ]
 },
 'letter-spacing': {
 title: 'Spaziatura lettere (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola lo spazio tra le lettere (tracking) per il testo selezionato.' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. Valori positivi "allargano" il testo, valori negativi lo "comprimono".' },
 { subtitle: 'Consiglio', text: 'Una spaziatura positiva sui titoli in maiuscolo (+2, +3px) dona eleganza. Evitare valori negativi che riducono la leggibilità.' }
 ]
 },
 'line-height': {
 title: 'Interlinea (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola lo spazio verticale tra le righe del testo selezionato (se multi-riga).' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 1.0 = nessuno spazio extra, 1.5 = 50% di spazio in più tra le righe.' },
 { subtitle: 'Consiglio', text: 'Per testi lunghi, 1.4-1.6 migliora la leggibilità. Per titoli compatti su più righe, usare 1.1-1.2.' }
 ]
 },
 'text-color': {
 title: 'Colore testo (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia il colore del livello di testo selezionato.' },
 { subtitle: 'Come si usa', text: 'Si clicca sul selettore colore e si sceglie la nuova tonalità.' },
 { subtitle: 'Consiglio', text: 'Verificare sempre che ci sia sufficiente contrasto con lo sfondo. Usare strumenti online di "contrast checker" per l\'accessibilità.' }
 ]
 },
 'maintain-aspect': {
 title: 'Mantieni proporzioni',
 sections: [
 { subtitle: 'Cosa fa', text: 'Quando attivo, mantiene automaticamente il rapporto larghezza/altezza del livello durante il ridimensionamento.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella di spunta. Modificando larghezza o altezza, l\'altra dimensione si adatta automaticamente.' },
 { subtitle: 'Consiglio', text: 'Tenerlo SEMPRE attivo per le foto, altrimenti si deformano. Per forme geometriche, può essere disattivato se si vuole un effetto "schiacciato".' }
 ]
 },
 'use-stroke': {
 title: 'Usa bordo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Attiva o disattiva il bordo/contorno per la forma selezionata.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella per mostrare il bordo. Se disattiva, la forma avrà solo il riempimento.' },
 { subtitle: 'Consiglio', text: 'Un bordo ben scelto può far risaltare le forme su sfondi complessi.' }
 ]
 },
 'sc': {
 title: 'Colore bordo (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia il colore del contorno della forma o testo selezionato (se il bordo è attivo).' },
 { subtitle: 'Come si usa', text: 'Si sceglie un colore dal selettore. Funziona solo se "Usa bordo" è attivato.' },
 { subtitle: 'Consiglio', text: 'Bordi neri o bianchi sono sempre efficaci per far risaltare elementi.' }
 ]
 },
 'stroke-width': {
 title: 'Spessore bordo (livello selezionato)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Regola lo spessore in pixel del bordo del livello selezionato.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore numerico. 0 = nessun bordo. 2-5 = sottile. 10+ = spesso.' },
 { subtitle: 'Consiglio', text: 'Per un effetto "fumetto", usare bordi spessi (5-8px) neri su forme colorate.' }
 ]
 },
 'use-gradient': {
 title: 'Usa gradiente (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Attiva un riempimento a gradiente per la forma selezionata invece di un colore solido.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella, poi si configurano i colori e il tipo di gradiente nei controlli sottostanti.' },
 { subtitle: 'Consiglio', text: 'I gradienti aggiungono profondità e modernità alle forme. Ottimi per badge, pulsanti, sfondi decorativi.' }
 ]
 },
 'gradient-type': {
 title: 'Tipo gradiente (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce se il gradiente del livello selezionato è lineare (dritto) o radiale (circolare).' },
 { subtitle: 'Come si usa', text: 'Si sceglie dal menu. Lineare va da un lato all\'altro. Radiale parte dal centro.' },
 { subtitle: 'Consiglio', text: 'Gradiente radiale su cerchi crea un bell\'effetto "bottone 3D". Lineare è più neutro e versatile.' }
 ]
 },
 'gradient-color1': {
 title: 'Colore 1 gradiente (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce il primo colore del gradiente applicato al livello.' },
 { subtitle: 'Come si usa', text: 'Si sceglie il colore di partenza della sfumatura.' },
 { subtitle: 'Consiglio', text: 'Per gradienti armoniosi, scegliere tonalità vicine sulla ruota cromatica (es. azzurro → blu scuro).' }
 ]
 },
 'gradient-color2': {
 title: 'Colore 2 gradiente (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Definisce il secondo colore del gradiente applicato al livello.' },
 { subtitle: 'Come si usa', text: 'Si sceglie il colore finale della sfumatura.' },
 { subtitle: 'Consiglio', text: 'Per effetti drammatici, usare colori complementari (es. arancione → viola). Per eleganza, usare tonalità simili.' }
 ]
 },
 'gradient-angle': {
 title: 'Angolo gradiente (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ruota la direzione del gradiente lineare del livello (da 0 a 360 gradi).' },
 { subtitle: 'Come si usa', text: 'Si usa lo slider. 0° = orizzontale verso destra. 90° = verticale verso il basso. 180° = orizzontale verso sinistra.' },
 { subtitle: 'Consiglio', text: 'Un angolo di 45° o 135° (diagonale) è molto popolare nel design moderno.' }
 ]
 },
 'layer-color': {
 title: 'Colore livello (forma)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Cambia il colore di riempimento della forma selezionata.' },
 { subtitle: 'Come si usa', text: 'Si seleziona una forma e si sceglie un nuovo colore dal selettore.' },
 { subtitle: 'Consiglio', text: 'Per forme dietro al testo, usare colori che creano buon contrasto con il colore del testo stesso.' }
 ]
 },
 'replace-image': {
 title: 'Sostituisci immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sostituisce l\'immagine del livello selezionato con una nuova, mantenendo posizione, dimensioni e tutti gli effetti applicati.' },
 { subtitle: 'Come si usa', text: 'Si seleziona un livello immagine, si clicca "Sostituisci immagine" e si carica il nuovo file.' },
 { subtitle: 'Consiglio', text: 'Perfetto per template riutilizzabili. Crea il design una volta, poi sostituisci solo le foto per nuove versioni.' }
 ]
 },
 'new-img-width': {
 title: 'Larghezza nuova immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta la larghezza in pixel con cui verrà inserita una nuova immagine.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore prima di caricare l\'immagine.' },
 { subtitle: 'Consiglio', text: 'Mantenere "Mantieni proporzioni" attivo per evitare distorsioni.' }
 ]
 },
 'new-img-height': {
 title: 'Altezza nuova immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta l\'altezza in pixel con cui verrà inserita una nuova immagine.' },
 { subtitle: 'Come si usa', text: 'Si inserisce un valore prima di caricare.' },
 { subtitle: 'Consiglio', text: 'Con "Mantieni proporzioni" attivo, la larghezza si adatta automaticamente.' }
 ]
 },
 'new-img-lock-ratio': {
 title: 'Blocca proporzioni nuova immagine',
 sections: [
 { subtitle: 'Cosa fa', text: 'Mantiene il rapporto larghezza/altezza originale dell\'immagine che verrà caricata.' },
 { subtitle: 'Come si usa', text: 'Si attiva la casella prima di caricare l\'immagine.' },
 { subtitle: 'Consiglio', text: 'Sempre consigliato per evitare immagini distorte.' }
 ]
 },
 'bg-image-upload': {
 title: 'Carica immagine sfondo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di caricare un\'immagine da usare come sfondo del canvas.' },
 { subtitle: 'Come si usa', text: 'Si clicca "Scegli file", si seleziona un\'immagine dal computer e si applica.' },
 { subtitle: 'Consiglio', text: 'Per sfondi con testo sopra, considerare di sfumare leggermente l\'immagine (filtro blur 5-10) per migliorare la leggibilità.' }
 ]
 },
 'image-upload': {
 title: 'Carica immagine (livello)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di caricare una nuova immagine da aggiungere come livello sul canvas.' },
 { subtitle: 'Come si usa', text: 'Si clicca "Scegli file", si seleziona l\'immagine e questa verrà aggiunta al canvas.' },
 { subtitle: 'Consiglio', text: 'Formati supportati: JPG, PNG, GIF, WebP. Per trasparenza, usare PNG.' }
 ]
 },
 'btn-toggle-vector': {
 title: 'Attiva/Disattiva Disegno Vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Attiva la modalità di disegno vettoriale che permette di creare poligoni personalizzati posizionando punti connessi da linee rette. Puoi creare forme con angoli netti (triangoli, quadrati) o forme curve mettendo tanti punti vicini (cerchi, cuori, nuvole). Perfetto per forme geometriche, frecce custom, badge, icone, decorazioni uniche.' },
 { subtitle: 'Come si usa', text: 'Clicca il pulsante o premi Ctrl+P per attivare. Usa le FRECCE ↑↓←→ per muovere il cursore sullo schermo. Premi INVIO per posizionare un punto. Ogni punto si collega al precedente con una linea retta. Servono minimo 3 punti. Premi C per chiudere la forma e creare il livello. Premi ESC per annullare. Regola prima "Passo cursore": 5px per movimenti precisi, 20px per movimenti veloci.' },
 { subtitle: 'Consiglio', text: 'Per forme con angoli (triangoli, stelle): usa pochi punti distanziati. Per forme curve (cerchi, cuori): usa tanti punti vicini (12-20 punti per un cerchio liscio). Attiva griglia e snap per allineamenti perfetti. Puoi sempre ruotare, scalare e colorare la forma dopo averla creata. Pianifica quanti punti ti servono prima di iniziare.' }
 ]
 },
 'vector-step': {
 title: 'Passo cursore vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Determina di quanti pixel si muove il cursore nel disegno vettoriale quando si usano le frecce direzionali. Controlla la velocità e precisione del movimento.' },
 { subtitle: 'Come si usa', text: 'Imposta un valore prima di attivare il disegno. Valori bassi (1-5px) = movimenti lenti e precisi per dettagli. Valori medi (10-15px) = equilibrio tra velocità e precisione. Valori alti (20-30px) = movimenti veloci per forme grandi.' },
 { subtitle: 'Consiglio', text: 'Inizia con 5px per un buon equilibrio. Riduci a 1-2px per posizionare punti molto vicini quando vuoi creare curve lisce. Aumenta a 20px per attraversare rapidamente il canvas su forme grandi. Puoi cambiarlo durante il disegno senza chiudere la modalità.' }
 ]
 },
 'vector-fill': {
 title: 'Colore riempimento vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore interno della forma poligonale che verrà disegnata in modalità vettoriale.' },
 { subtitle: 'Come si usa', text: 'Scegli un colore prima di iniziare a disegnare o mentre stai posizionando i punti. Il colore si applicherà quando chiudi la forma con C.' },
 { subtitle: 'Consiglio', text: 'Scegli colori in armonia con la palette del progetto. Puoi sempre cambiare il colore dopo aver creato la forma selezionandola e usando i controlli del livello. Per forme trasparenti, imposta l\'opacità dopo la creazione.' }
 ]
 },
 'vector-stroke': {
 title: 'Colore bordo vettoriale',
 sections: [
 { subtitle: 'Cosa fa', text: 'Imposta il colore del contorno (linea perimetrale) della forma disegnata vettorialmente.' },
 { subtitle: 'Come si usa', text: 'Scegli un colore. Il bordo sarà visibile solo se "Spessore bordo vettoriale" è maggiore di 0px.' },
 { subtitle: 'Consiglio', text: 'Un bordo contrastante rende la forma più definita e leggibile, specialmente se sovrapposta ad altri elementi. Bordo nero su forma colorata = effetto fumetto. Bordo bianco = fa risaltare su sfondi scuri.' }
 ]
 },
 'vector-stroke-width': {
 title: 'Spessore bordo vettoriale (px)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Stabilisce lo spessore in pixel del contorno della forma vettoriale. Controlla quanto è marcata la linea esterna.' },
 { subtitle: 'Come si usa', text: 'Inserisci un valore. 0px = nessun bordo (solo riempimento). 1-3px = linee sottili ed eleganti. 5-10px = linee marcate per effetto grafico. 15+ px = bordi molto spessi per stile bold.' },
 { subtitle: 'Consiglio', text: 'Per icone e design flat moderni, usa 3-5px. Per forme decorative senza bordo, imposta 0px. Per effetto "disegnato a mano", usa 2-3px con colore leggermente diverso dal riempimento.' }
 ]
 },
 'vector-focus-area': {
 title: 'Guida Completa Disegno Vettoriale',
 sections: [
 { subtitle: 'Come Funziona', text: 'Il disegno vettoriale crea POLIGONI connettendo punti con linee rette. Mettendo tanti punti vicini ottieni forme che sembrano curve! 3 punti = triangolo con angoli. 16-20 punti = cerchio liscio. Più punti = curve più morbide. Non usa curve Bezier matematiche ma il risultato visivo è identico.' },
 { subtitle: 'Procedura Completa', text: '1) Configura PRIMA: imposta passo cursore (5px=preciso, 20px=veloce), colori riempimento e bordo. 2) ATTIVA: Clicca "Attiva Disegno Vettoriale" o Ctrl+P. 3) MUOVI CURSORE: Frecce direzionali ↑↓←→. 4) POSIZIONA PUNTI: Premi INVIO. Ogni punto si collega al precedente. 5) CHIUDI FORMA: Premi C quando hai almeno 3 punti. 6) ANNULLA: Premi ESC in qualsiasi momento.' },
 { subtitle: 'Esempi Pratici', text: 'TRIANGOLO: 3 punti agli angoli, premi C. QUADRATO: 4 punti, usa griglia per allineamento perfetto. ESAGONO: 6 punti equidistanti. CERCHIO: 16-20 punti equidistanti in forma circolare, serve pazienza ma il risultato è perfetto. CUORE: 20-24 punti, inizia dalle curve superiori. STELLA: 10 punti alternando punte esterne e interne.' },
 { subtitle: 'Configurazioni Ottimali', text: 'Per ANGOLI (triangoli, stelle): Passo 20px, 3-8 punti, tempo 30 secondi. Per CURVE LEGGERE (badge): Passo 10px, 10-15 punti, tempo 1-2 minuti. Per CURVE LISCE (cerchi, cuori): Passo 5px, 18-25 punti, tempo 3-5 minuti. Attiva griglia e snap per forme geometriche perfette.' },
 { subtitle: 'Trucchi Professionali', text: 'Usa la GRIGLIA per allineamenti perfetti. Per SIMMETRIA conta i passi (es: 4 su poi 4 giù). Per CERCHI PERFETTI mantieni sempre stesso numero di passi tra punti. Pianifica PRIMA quanti punti servono. Non è perfetto? Ruota, scala o duplica dopo per correggere. Per curve più lisce: metti punti EQUIDISTANTI.' },
 { subtitle: 'Cosa Puoi Fare', text: 'Creare qualsiasi forma visivamente: triangoli, quadrati, stelle, cerchi perfetti, cuori, nuvole, frecce custom, badge, icone, decorazioni uniche, forme astratte. Combinare angoli e curve nella stessa forma. Dopo la creazione: ruotare, scalare, cambiare colori, aggiungere ombra, duplicare, sovrapporre.' },
 { subtitle: 'Limitazioni', text: 'Non puoi modificare posizione punti dopo chiusura. Non usa curve Bezier matematiche (ma visivamente identico). Non puoi importare SVG o usare strumento penna Bezier. Richiede pazienza per forme complesse con molti punti. Soluzione: crea la forma base, poi aggiusta con rotazione e scala.' },
 { subtitle: 'Regola Fondamentale', text: 'PIÙ PUNTI VICINI = CURVE PIÙ LISCE. 3-6 punti = forme con angoli netti. 8-12 punti = curve leggere e arrotondate. 15-20 punti = cerchi lisci e forme organiche. 25+ punti = curve molto complesse e morbide. Inizia con forme semplici per fare pratica, poi passa a quelle complesse.' }
 ]
 },
 'btn-add-text': {
 title: 'Aggiungi Testo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge un nuovo livello di testo al canvas con le impostazioni configurate (font, dimensione, colore, ecc.).' },
 { subtitle: 'Come si usa', text: 'Scrivi il testo nell\'area "Contenuto", configura font e stile, poi clicca questo pulsante per aggiungerlo al canvas.' },
 { subtitle: 'Consiglio', text: 'Configura tutto prima di cliccare. Dopo aver aggiunto il testo, puoi modificarlo selezionandolo e usando "Modifica contenuto testo".' }
 ]
 },
 'btn-add-rect': {
 title: 'Aggiungi Rettangolo',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge un rettangolo al canvas con le dimensioni e colori configurati.' },
 { subtitle: 'Come si usa', text: 'Configura colore riempimento, bordo e arrotondamento angoli, poi clicca per aggiungere.' },
 { subtitle: 'Consiglio', text: 'Ottimo per creare sfondi per testo, pulsanti, badge. Usa l\'arrotondamento angoli per un look moderno.' }
 ]
 },
 'btn-add-circle': {
 title: 'Aggiungi Cerchio',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge un cerchio perfetto al canvas.' },
 { subtitle: 'Come si usa', text: 'Configura colore e bordo, poi clicca. Il cerchio verrà creato con larghezza e altezza uguali.' },
 { subtitle: 'Consiglio', text: 'Perfetto per badge circolari, pulsanti rotondi, elementi decorativi. Per un ovale, aggiungi un cerchio e poi cambia larghezza o altezza.' }
 ]
 },
 'btn-add-star': {
 title: 'Aggiungi Stella (5 punte)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge una stella a 5 punte al canvas.' },
 { subtitle: 'Come si usa', text: 'Clicca per aggiungere. Puoi poi ridimensionarla, ruotarla e cambiarle colore.' },
 { subtitle: 'Consiglio', text: 'Ottima per valutazioni, decorazioni, badge premium. Combina più stelle per creare sistemi di rating.' }
 ]
 },
 'btn-add-heart': {
 title: 'Aggiungi Cuore',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge una forma a cuore al canvas.' },
 { subtitle: 'Come si usa', text: 'Clicca per aggiungere. Personalizza colore e dimensioni dopo l\'inserimento.' },
 { subtitle: 'Consiglio', text: 'Perfetto per contenuti romantici, San Valentino, "Mi piace", elementi decorativi emozionali.' }
 ]
 },
 'btn-add-arrow': {
 title: 'Aggiungi Freccia',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aggiunge una freccia direzionale al canvas.' },
 { subtitle: 'Come si usa', text: 'Clicca per aggiungere. Ruotala per puntare in diverse direzioni (0°, 90°, 180°, 270°).' },
 { subtitle: 'Consiglio', text: 'Utile per indicare direzioni, creare flow chart, attirare attenzione su elementi specifici.' }
 ]
 },
 'btn-crop': {
 title: 'Attiva Ritaglio',
 sections: [
 { subtitle: 'Cosa fa', text: 'Attiva la modalità ritaglio per selezionare l\'area dell\'immagine da mantenere.' },
 { subtitle: 'Come si usa', text: 'Seleziona un\'immagine, clicca il pulsante, trascina per definire l\'area, conferma o annulla.' },
 { subtitle: 'Consiglio', text: 'Usa per rimuovere parti indesiderate, migliorare la composizione, focalizzare sul soggetto.' }
 ]
 },
 'btn-eyedropper': {
 title: 'Contagocce Colore',
 sections: [
 { subtitle: 'Cosa fa', text: 'Permette di prelevare un colore da un\'immagine sul canvas cliccando su di essa.' },
 { subtitle: 'Come si usa', text: 'Clicca il contagocce, poi clicca su un punto qualsiasi di un\'immagine per copiarne il colore.' },
 { subtitle: 'Consiglio', text: 'Perfetto per mantenere coerenza cromatica. Preleva colori dalle foto per usarli in testi e forme.' }
 ]
 },
 'btn-analyze': {
 title: 'Analizza Accessibilità',
 sections: [
 { subtitle: 'Cosa fa', text: 'Analizza il progetto per verificare contrasto colori, leggibilità testo, e fornisce suggerimenti di accessibilità.' },
 { subtitle: 'Come si usa', text: 'Clicca per avviare l\'analisi. Riceverai un report con eventuali problemi e consigli.' },
 { subtitle: 'Consiglio', text: 'Usalo prima di pubblicare per assicurarti che il design sia leggibile per tutti, incluse persone con disabilità visive.' }
 ]
 },
 'btn-export-png': {
 title: 'Esporta come PNG',
 sections: [
 { subtitle: 'Cosa fa', text: 'Scarica il progetto come immagine PNG (supporta trasparenza).' },
 { subtitle: 'Come si usa', text: 'Clicca per scaricare. Il file si chiamerà "design.png".' },
 { subtitle: 'Consiglio', text: 'Usa PNG per immagini con trasparenza, loghi, grafiche con testo. Qualità massima ma file più pesanti.' }
 ]
 },
 'btn-export-jpg': {
 title: 'Esporta come JPG',
 sections: [
 { subtitle: 'Cosa fa', text: 'Scarica il progetto come immagine JPG (non supporta trasparenza).' },
 { subtitle: 'Come si usa', text: 'Clicca per scaricare. Il file si chiamerà "design.jpg".' },
 { subtitle: 'Consiglio', text: 'Usa JPG per foto, immagini complesse, quando il file deve essere leggero. Non supporta trasparenza.' }
 ]
 },
 'btn-undo': {
 title: 'Annulla (Ctrl+Z)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Annulla l\'ultima azione eseguita.' },
 { subtitle: 'Come si usa', text: 'Clicca o premi Ctrl+Z. Puoi annullare fino a 50 azioni precedenti.' },
 { subtitle: 'Consiglio', text: 'Non aver paura di sperimentare! Puoi sempre tornare indietro con Annulla.' }
 ]
 },
 'btn-redo': {
 title: 'Ripeti (Ctrl+Y)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Ripristina l\'ultima azione annullata.' },
 { subtitle: 'Come si usa', text: 'Clicca o premi Ctrl+Y dopo aver annullato un\'azione.' },
 { subtitle: 'Consiglio', text: 'Utile se hai annullato per errore o vuoi confrontare due versioni avanti-indietro.' }
 ]
 },
 'btn-delete': {
 title: 'Elimina Livello (Delete)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Elimina definitivamente il livello attualmente selezionato.' },
 { subtitle: 'Come si usa', text: 'Seleziona un livello e clicca o premi Delete. Puoi recuperarlo con Annulla (Ctrl+Z).' },
 { subtitle: 'Consiglio', text: 'Fai attenzione: elimina permanentemente! Ma ricorda che Annulla è sempre disponibile.' }
 ]
 },
 'btn-fullscreen': {
 title: 'Anteprima Schermo Intero (Alt+A)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Mostra il canvas a schermo intero per vedere il risultato finale senza interfaccia.' },
 { subtitle: 'Come si usa', text: 'Clicca o premi Alt+A per attivare. Premi Esc per uscire.' },
 { subtitle: 'Consiglio', text: 'Ottimo per verificare l\'effetto finale, fare screenshot, presentare il lavoro a clienti.' }
 ]
 },
 'btn-sound-map': {
 title: 'Mappa Sonora (Ctrl+M)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Attiva la mappa sonora che descrive vocalmente il contenuto del canvas diviso in 9 celle.' },
 { subtitle: 'Come si usa', text: 'Clicca o premi Ctrl+M. Usa le frecce per navigare tra le celle e ascoltarne il contenuto.' },
 { subtitle: 'Consiglio', text: 'Strumento di accessibilità per utenti non vedenti o ipovedenti. Fornisce una descrizione audio del layout.' }
 ]
 },
 'btn-keyboard-guide': {
 title: 'Guida Tasti Rapidi (F1)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Mostra l\'elenco completo di tutti i tasti rapidi disponibili nell\'editor.' },
 { subtitle: 'Come si usa', text: 'Clicca o premi F1. La guida si aprirà in una finestra modale.' },
 { subtitle: 'Consiglio', text: 'Memorizza i tasti rapidi più usati (Ctrl+Z, Ctrl+C, Ctrl+V) per lavorare molto più velocemente.' }
 ]
 },
 // ═══════════════════════════════════════════════════════════════════════
 // EFFETTI GPU - Spiegazioni F2
 // ═══════════════════════════════════════════════════════════════════════
 'btn-apply-curves': {
 title: 'Curves Pro GPU',
 sections: [
 { subtitle: 'Cosa fa', text: 'Modifica la curva tonale dell\'immagine usando la GPU per elaborazione veloce. Permette di controllare luminosità e contrasto in modo professionale attraverso preset predefiniti.' },
 { subtitle: 'Preset disponibili', text: 'Lineare (nessun effetto), S-Curve (aumenta contrasto nei mezzitoni, ideale per ritratti), Fade (riduce contrasto per look vintage/analogico), High Contrast (effetto drammatico con neri profondi e bianchi brillanti).' },
 { subtitle: 'Come si usa', text: 'Seleziona un preset dal menu a tendina e clicca "Applica Curves Pro". L\'effetto viene applicato istantaneamente grazie all\'accelerazione GPU.' },
 { subtitle: 'Quando usarlo', text: 'Per correzioni tonali generali, creare look cinematici, migliorare ritratti con S-Curve, dare look vintage con Fade, o creare drammaticità con High Contrast.' },
 { subtitle: 'Consiglio Pro', text: 'La S-Curve è la curva più usata dai professionisti: schiarisce le luci, scurisce le ombre, aumenta il contrasto nel mezzo. Perfetta per quasi ogni foto.' }
 ]
 },
 'btn-apply-color-balance': {
 title: 'Color Balance Pro GPU',
 sections: [
 { subtitle: 'Cosa fa', text: 'Applica split toning professionale, colorando separatamente ombre e luci. Tecnica cinematografica usata in film e fotografia professionale.' },
 { subtitle: 'Controlli', text: 'Ombre: valori negativi = toni caldi (arancione), positivi = toni freddi (blu). Luci: valori negativi = toni caldi (giallo), positivi = toni freddi (cyan).' },
 { subtitle: 'Come si usa', text: 'Regola gli slider per ombre e luci, poi clicca "Applica Color Balance". L\'elaborazione GPU garantisce applicazione istantanea anche su immagini grandi.' },
 { subtitle: 'Effetti popolari', text: 'Teal & Orange (film action): ombre blu (-30), luci arancioni (-25). Matrix Look: ombre verdi (+20), luci cyan (+30). Sunset Warm: ombre arancioni (-40), luci gialle (-20).' },
 { subtitle: 'Consiglio Pro', text: 'Il look Teal & Orange (ombre blu + luci arancioni) è lo standard di Hollywood perché crea contrasto cromatico che fa risaltare i toni pelle.' }
 ]
 },
 'btn-apply-gpu-blur': {
 title: 'Blur Pro GPU (Gaussian)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Applica sfocatura gaussiana ultra-veloce elaborata dalla GPU. Molto più veloce e morbida del blur CPU tradizionale, con qualità professionale.' },
 { subtitle: 'Raggio', text: 'Da 0 (nessuna sfocatura) a 50 pixel. Valori bassi (5-10) = sfocatura leggera. Valori medi (15-25) = sfocatura media per privacy. Valori alti (30-50) = sfocatura estrema per sfondi.' },
 { subtitle: 'Come si usa', text: 'Regola lo slider del raggio e clicca "Applica Blur Pro". L\'elaborazione GPU permette blur pesanti senza rallentamenti.' },
 { subtitle: 'Quando usarlo', text: 'Per nascondere volti/targhe (privacy), creare sfondi sfocati (bokeh artificiale), softening generale, ridurre dettagli in zone secondarie.' },
 { subtitle: 'Consiglio Pro', text: 'Per effetto bokeh realistico: applica blur forte (30-40px) allo sfondo, lascia il soggetto a fuoco. Per privacy, usa almeno 25px su volti.' }
 ]
 },
 'btn-apply-bloom': {
 title: 'Bloom Pro GPU (Glow Realistico)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Crea effetto glow realistico sulle parti luminose dell\'immagine. Le zone più chiare "brillano" espandendosi, come nelle foto HDR o nei videogiochi.' },
 { subtitle: 'Soglia Luminosità', text: 'Da 0 a 100. Valori bassi (20-50) = anche zone mediamente luminose brillano. Valori alti (70-90) = solo le zone più luminose brillano (più realistico).' },
 { subtitle: 'Intensità', text: 'Da 0 a 200. Valori bassi (20-50) = glow sottile. Valori medi (60-100) = glow evidente. Valori alti (120-200) = glow estremo/artistico.' },
 { subtitle: 'Come si usa', text: 'Regola soglia e intensità, poi clicca "Applica Bloom Pro". L\'effetto GPU è in tempo reale anche su immagini ad alta risoluzione.' },
 { subtitle: 'Quando usarlo', text: 'Per foto di luci notturne (lampioni, insegne), rendering 3D, look fantasy/magico, simulare sovraesposizione artistica, foto di concerti/eventi.' },
 { subtitle: 'Consiglio Pro', text: 'Soglia alta (80) + intensità media (70) = bloom realistico. Soglia bassa (30) + intensità alta (150) = effetto dream/ethereal artistico.' }
 ]
 },
 'btn-apply-vibrance': {
 title: 'Vibrance GPU',
 sections: [
 { subtitle: 'Cosa fa', text: 'Aumenta saturazione in modo intelligente, migliorando solo i colori spenti senza sovrasaturare quelli già vividi. Protegge automaticamente i toni pelle.' },
 { subtitle: 'Differenza con Saturazione', text: 'Saturazione aumenta TUTTI i colori uniformemente (può sovrasaturare). Vibrance aumenta SOLO i colori poco saturi, lasciando intatti i colori già vividi e i toni pelle.' },
 { subtitle: 'Valori', text: 'Da -100 (desaturazione) a +100 (massima vibrance). -50 a 0 = desaturazione parziale/totale. 0 a +50 = aumento naturale. +50 a +100 = aumento marcato ma protetto.' },
 { subtitle: 'Come si usa', text: 'Regola lo slider e clicca "Applica Vibrance". L\'elaborazione GPU garantisce risultati istantanei.' },
 { subtitle: 'Quando usarlo', text: 'Per paesaggi (rende cieli e vegetazione più vividi), ritratti (migliora colori senza alterare pelle), foto con colori spenti da ravvivare, alternative sicure alla saturazione.' },
 { subtitle: 'Consiglio Pro', text: 'Per ritratti usa sempre Vibrance invece di Saturazione: +30/+40 ravviva i colori senza fare diventare arancioni i volti. Per paesaggi puoi spingere fino a +60/+70.' }
 ]
 },
 'btn-apply-white-balance': {
 title: 'White Balance Pro GPU',
 sections: [
 { subtitle: 'Cosa fa', text: 'Corregge o modifica il bilanciamento del bianco (temperatura colore) dell\'immagine. Essenziale per foto scattate con illuminazione artificiale o condizioni di luce non ottimali.' },
 { subtitle: 'Temperatura', text: 'Da -100 (più freddo/blu) a +100 (più caldo/arancione). Valori negativi tolgono dominanti calde (luci incandescenti). Valori positivi tolgono dominanti fredde (ombra, nuvoloso).' },
 { subtitle: 'Tinta', text: 'Da -100 (più magenta) a +100 (più verde). Serve per correzioni fini, specialmente sotto luci fluorescenti che tendono al verde.' },
 { subtitle: 'Come si usa', text: 'Regola temperatura e tinta, poi clicca "Applica White Balance". L\'elaborazione GPU permette preview in tempo reale.' },
 { subtitle: 'Correzioni comuni', text: 'Foto troppo gialla/arancione (interni): temperatura -30/-50. Foto troppo blu (ombra): temperatura +30/+50. Foto verdognola (neon): tinta -20/-40. Foto troppo magenta: tinta +20/+40.' },
 { subtitle: 'Consiglio Pro', text: 'Per correggere foto da interni con luce calda: temperatura -40, tinta -10. Per foto all\'ombra troppo blu: temperatura +35, tinta 0. Usa un foglio bianco come riferimento.' }
 ]
 },
 'btn-apply-highlights-shadows': {
 title: 'Highlights & Shadows GPU',
 sections: [
 { subtitle: 'Cosa fa', text: 'Controlla separatamente luminosità di ombre e luci. Permette di recuperare dettagli in zone troppo scure o bruciate, essenziale per foto ad alto contrasto.' },
 { subtitle: 'Ombre', text: 'Da -100 a +100. Valori positivi schiariscono le ombre (recupera dettagli scuri). Valori negativi scuriscono ulteriormente (aumenta drammaticità).' },
 { subtitle: 'Luci', text: 'Da -100 a +100. Valori negativi scuriscono le luci (recupera dettagli bruciati). Valori positivi schiariscono ulteriormente (look high-key).' },
 { subtitle: 'Come si usa', text: 'Regola ombre e luci indipendentemente, poi clicca "Applica Highlights & Shadows". L\'elaborazione GPU gestisce calcoli complessi istantaneamente.' },
 { subtitle: 'Situazioni tipiche', text: 'Controluce: ombre +60, luci -20 (recupera soggetto scuro). Foto bruciata: ombre 0, luci -70 (recupera cielo/dettagli chiari). Silhouette: ombre -40, luci +30 (aumenta contrasto).' },
 { subtitle: 'Consiglio Pro', text: 'Per foto HDR naturali: ombre +40, luci -40. Per drammaticità cinematica: ombre -30, luci -20. Mai esagerare o l\'immagine sembrerà "flat" e innaturale.' }
 ]
 },
 'btn-apply-motionblur': {
 title: 'Motion Blur GPU (NUOVO v43)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Applica sfocatura direzionale che simula movimento rapido. Crea senso di velocità e dinamismo, come se l\'oggetto si stesse muovendo nella direzione specificata.' },
 { subtitle: 'Distanza', text: 'Da 1 a 100 pixel. Valori bassi (5-20) = movimento leggero. Valori medi (25-50) = movimento evidente. Valori alti (60-100) = movimento estremo/velocissimo.' },
 { subtitle: 'Angolo', text: 'Da 0 a 360 gradi. 0° = orizzontale verso destra →. 90° = verticale verso il basso ↓. 180° = orizzontale verso sinistra ←. 270° = verticale verso l\'alto ↑.' },
 { subtitle: 'Come si usa', text: 'Imposta distanza e angolo del movimento, poi clicca "Applica Motion Blur". L\'elaborazione GPU rende veloce anche su blur molto lunghi.' },
 { subtitle: 'Quando usarlo', text: 'Per simulare velocità (auto, treni, sport), creare dinamismo in composizioni statiche, effetti artistici di movimento, transizioni video-style.' },
 { subtitle: 'Consiglio Pro', text: 'Per effetto auto in corsa: distanza 60-80px, angolo 0° o 180° (orizzontale). Per caduta: angolo 90°, distanza 40-60px. Per zoom/explosion: combina con angoli radiali.' }
 ]
 },
 'btn-apply-tiltshift': {
 title: 'Tilt-Shift GPU (Effetto Miniatura - NUOVO v43)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Crea l\'illusione di un modellino in miniatura applicando sfocatura graduale dall\'alto e dal basso. La fascia centrale resta a fuoco, simulando la ridotta profondità di campo della fotografia macro.' },
 { subtitle: 'Intensità Blur', text: 'Da 1 a 30. Valori bassi (5-10) = sfocatura leggera. Valori medi (12-20) = effetto evidente. Valori alti (22-30) = sfocatura estrema (più effetto miniatura).' },
 { subtitle: 'Dimensione Focus', text: 'Da 10% a 80%. Valori bassi (10-30%) = fascia centrale stretta (più effetto giocattolo). Valori medi (35-50%) = fascia media. Valori alti (55-80%) = fascia ampia (effetto sottile).' },
 { subtitle: 'Come si usa', text: 'Regola intensità sfocatura e dimensione della fascia a fuoco, poi clicca "Applica Tilt-Shift". L\'elaborazione GPU gestisce i gradienti complessi in tempo reale.' },
 { subtitle: 'Quando usarlo', text: 'Perfetto per paesaggi urbani dall\'alto (grattacieli, strade), viste aeree, creare effetto diorama/miniatura, simulare fotografia tilt-shift professionale.' },
 { subtitle: 'Consiglio Pro', text: 'Per massimo effetto miniatura: blur alto (25), focus piccolo (30%), foto scattata dall\'alto. Funziona meglio con scene complesse e dettagliate. Aumenta saturazione (+20 vibrance) dopo per look giocattolo.' }
 ]
 },
 'btn-apply-gaussianblur': {
 title: 'Gaussian Blur Pro Multi-Qualità GPU (NUOVO v43)',
 sections: [
 { subtitle: 'Cosa fa', text: 'Sfocatura gaussiana avanzata con controllo di qualità. Offre tre livelli di elaborazione: veloce, standard, alta qualità. Più professionale e controllabile del Blur Pro base.' },
 { subtitle: 'Raggio', text: 'Da 1 a 100 pixel. Valori bassi (1-15) = softening leggero. Valori medi (20-40) = sfocatura evidente. Valori alti (50-100) = sfocatura estrema per sfondi.' },
 { subtitle: 'Qualità', text: 'Veloce (3 passaggi) = elaborazione rapida, qualità base. Standard (5 passaggi) = bilanciamento qualità/velocità. Alta (9 passaggi) = qualità massima, più lento ma risultato perfetto.' },
 { subtitle: 'Come si usa', text: 'Scegli raggio e qualità desiderata, poi clicca "Applica Gaussian Blur". L\'elaborazione GPU ottimizza i calcoli anche per qualità alta.' },
 { subtitle: 'Quando usarlo', text: 'Quando serve controllo preciso della qualità di sfocatura, per blur molto forti senza artefatti (usa alta qualità), per effetti DOF (depth of field) professionali, per privacy con qualità controllata.' },
 { subtitle: 'Consiglio Pro', text: 'Per sfocature estreme (60+px) usa sempre qualità Alta per evitare artefatti. Per preview/test usa Veloce. Per risultato finale usa Alta. Standard è ottimo compromesso per uso generale (blur 15-40px).' }
 ]
 }
 };
 
 // Funzione per mostrare l'aiuto F2
 // Variabile per salvare l'elemento che aveva focus prima del modale F2
 let previousFocusedElement = null;
 
 function showF2Help(elementId) {
 // Salva l'elemento che ha il focus ora (quello che ha premuto F2)
 previousFocusedElement = document.activeElement;
 
 const helpData = helpDatabase[elementId];
 if (!helpData) {
 f2HelpBody.innerHTML = '<p style="color: #64748b; font-size: 16px; line-height: 1.8;">Nessun aiuto disponibile per questo elemento.</p>';
 } else {
 // Crea un testo continuo senza etichette, solo il contenuto
 let text = '';
 helpData.sections.forEach((section, index) => {
 text += section.text; // Solo il testo, senza "Cosa fa:", "Come si usa:", ecc.
 if (index < helpData.sections.length - 1) {
 text += ' '; // Spazio singolo tra le sezioni per testo più fluido
 }
 });
 
 // Mostra come testo scrollabile
 f2HelpBody.innerHTML = `
 <div style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; font-size: 16px; line-height: 1.8; color: #1e293b; white-space: pre-wrap; word-wrap: break-word; padding: 16px; background: #f8fafc; border-radius: 8px; max-height: 60vh; overflow-y: auto; border: 1px solid #e2e8f0;" tabindex="0" role="textbox" aria-readonly="true" aria-multiline="true">${text}</div>
 `;
 }
 
 document.getElementById('f2-help-title').textContent = helpData ? helpData.title : 'Aiuto Elemento';
 f2HelpModal.classList.add('active');
 
 // Focus sul contenuto per permettere scrolling con frecce
 setTimeout(() => {
 const textbox = f2HelpBody.querySelector('[role="textbox"]');
 if (textbox) {
 textbox.focus();
 }
 }, 100);
 
 announceGemini('Aiuto elemento visualizzato. Usa le frecce per scorrere, Escape per chiudere.', 'polite');
 }
 
 // Funzione per chiudere l'aiuto F2
 function closeF2Help() {
 f2HelpModal.classList.remove('active');
 announceGemini('Aiuto chiuso', 'polite');
 
 // Ripristina il focus sull'elemento che aveva prima di aprire il modale
 setTimeout(() => {
 if (previousFocusedElement && typeof previousFocusedElement.focus === 'function') {
 try {
 previousFocusedElement.focus();
 } catch (e) {
 // Se l'elemento non esiste più, non fare nulla
 console.log('Impossibile ripristinare il focus:', e);
 }
 }
 }, 50);
 }
 
 // Gestione tasto Escape per chiudere F2
 f2HelpModal.addEventListener('keydown', (e) => {
 if (e.key === 'Escape') {
 e.preventDefault();
 closeF2Help();
 }
 });
 
 // Click fuori dal modale per chiudere
 f2HelpModal.addEventListener('click', (e) => {
 if (e.target === f2HelpModal) {
 closeF2Help();
 }
 });

 // ---- Tasti Rapidi Globali ----
 document.addEventListener('keydown', e => {
 // +A per anteprima schermo intero
 if (e.key === '+' || e.key === '=') {
 setTimeout(() => {
 const waitForA = (evt) => {
 if (evt.key.toLowerCase() === 'a') {
 document.body.classList.toggle('preview-mode');
 const isPreview = document.body.classList.contains('preview-mode');
 announceGemini(isPreview ? 'Modalità anteprima attivata. Premi più A per uscire' : 'Tornato all\'editor', 'assertive');
 }
 document.removeEventListener('keydown', waitForA);
 };
 document.addEventListener('keydown', waitForA);
 setTimeout(() => document.removeEventListener('keydown', waitForA), 1000);
 }, 50);
 }
 

 
 // *** GESTIONE Alt+A per Fullscreen ***
 // Supporta sia 'a' che 'A', e anche il keyCode per compatibilità
 if (e.altKey && (e.key.toLowerCase() === 'a' || e.keyCode === 65 || e.code === 'KeyA')) {
 e.preventDefault();
 e.stopPropagation();
 document.getElementById('btn-fullscreen').click();
 return;
 }
 
 // Gestione F1
 if (e.key === 'F1') {
 e.preventDefault();
 showKeyboardGuide();
 return;
 }
 
 // Gestione F2 per aiuto contestuale
 if (e.key === 'F2') {
 e.preventDefault();
 const focusedElement = document.activeElement;
 if (focusedElement && focusedElement.id && helpDatabase[focusedElement.id]) {
 showF2Help(focusedElement.id);
 } else {
 // Messaggio più chiaro e informativo
 const elementName = focusedElement.textContent || focusedElement.value || focusedElement.id || 'questo elemento';
 announceGemini(`Aiuto F2 non disponibile per "${elementName}". L'aiuto F2 è disponibile per controlli principali (campi, slider, select) e pulsanti di azione importanti. Prova su: Template, Larghezza, Font, Passo cursore, Attiva Disegno Vettoriale, Esporta PNG, etc.`, 'polite');
 }
 return;
 }
 
 // Gestione Escape (chiude modali, contagocce, disegno vettoriale)
 // --- BLOCCO MODIFICATO ---
 if (e.key === 'Escape') {
 e.stopImmediatePropagation();
 // PRIORITÀ 1: Chiudi l'anteprima a schermo intero
 if(fullscreenContainer.style.display === 'flex') {
 // Se siamo in fullscreen nativo del browser, esci prima da quello
 if (document.fullscreenElement || document.webkitFullscreenElement || 
 document.mozFullScreenElement || document.msFullscreenElement) {
 if (document.exitFullscreen) {
 document.exitFullscreen();
 } else if (document.webkitExitFullscreen) {
 document.webkitExitFullscreen();
 } else if (document.mozCancelFullScreen) {
 document.mozCancelFullScreen();
 } else if (document.msExitFullscreen) {
 document.msExitFullscreen();
 }
 } else {
 // Altrimenti chiudi solo l'overlay
 fullscreenContainer.style.display = 'none';
 if (elementToFocusAfterFullscreen) {
 elementToFocusAfterFullscreen.focus();
 elementToFocusAfterFullscreen = null;
 }
 }
 return; // Esce dopo aver chiuso l'anteprima
 }
 
 // PRIORITÀ 2: Chiudi modale F2 se aperto
 if (f2HelpModal.classList.contains('active')) {
 closeF2Help();
 return;
 }
 
 // Resto della logica...
 if (state.eyedropperActive) {
 deactivateEyedropper();
 announceGemini('Contagocce disattivato', 'polite');
 } else if (state.vectorDrawMode) {
 toggleVectorMode(); // Ora ha la conferma integrata
 } else if (state.cropMode) {
 cancelCrop();
 }
 closeModal(modalGuide);
 closeModal(modalAnalysis);
 closeModal(modalAltText);
 return;
 }
 // --- FINE BLOCCO MODIFICATO ---

 // Gestione Mappa Sonora
 if (state.isGridModeActive && e.key.startsWith('Arrow')) {
 e.preventDefault();
 if (e.key === 'ArrowUp' && state.gridCell.y > 0) state.gridCell.y--; 
 else if (e.key === 'ArrowDown' && state.gridCell.y < 2) state.gridCell.y++;
 else if (e.key === 'ArrowLeft' && state.gridCell.x > 0) state.gridCell.x--; 
 else if (e.key === 'ArrowRight' && state.gridCell.x < 2) state.gridCell.x++;
 describeGridCell(state.gridCell.x, state.gridCell.y);
 return;
 }
 
 // *** NAVIGAZIONE CANVAS CON FRECCE ***
 // Attiva solo se il canvas ha il focus o se siamo in modalità esplorazione
 const canvasHasFocus = document.activeElement === canvas || document.activeElement === document.body;
 if (canvasHasFocus && e.key.startsWith('Arrow') && !state.vectorDrawMode && !state.isGridModeActive) {
 e.preventDefault();
 e.stopImmediatePropagation();
 
 // Determina lo step in base ai modificatori
 let step = 1; // Default: 1 pixel
 if (e.shiftKey) {
 step = 25; // Shift+Freccia = 25px
 } else if (e.ctrlKey || e.metaKey) {
 step = 50; // Ctrl/Cmd+Freccia = 50px
 }
 
 // Inizializza cursore esplorazione se non esiste
 if (!state.explorationCursor) {
 state.explorationCursor = { x: Math.floor(canvas.width / 2), y: Math.floor(canvas.height / 2) };
 state.lastLayerUnderCursor = null; // Traccia ultimo elemento incontrato
 }
 
 // Salva vecchia posizione
 const oldX = state.explorationCursor.x;
 const oldY = state.explorationCursor.y;
 
 // Muovi cursore
 if (e.key === 'ArrowUp') state.explorationCursor.y = Math.max(0, state.explorationCursor.y - step);
 if (e.key === 'ArrowDown') state.explorationCursor.y = Math.min(canvas.height, state.explorationCursor.y + step);
 if (e.key === 'ArrowLeft') state.explorationCursor.x = Math.max(0, state.explorationCursor.x - step);
 if (e.key === 'ArrowRight') state.explorationCursor.x = Math.min(canvas.width, state.explorationCursor.x + step);
 
 // Trova elemento sotto il cursore
 const x = state.explorationCursor.x;
 const y = state.explorationCursor.y;
 
 let layerUnderCursor = null;
 for (let i = state.layers.length - 1; i >= 0; i--) {
 const layer = state.layers[i];
 if (x >= layer.x && x <= layer.x + layer.width &&
 y >= layer.y && y <= layer.y + layer.height) {
 layerUnderCursor = layer;
 break;
 }
 }
 
 // Annuncia SOLO se è cambiato l'elemento sotto il cursore
 const layerChanged = (layerUnderCursor !== state.lastLayerUnderCursor);
 
 if (layerChanged) {
 let message = `X ${x}, Y ${y}. `;
 
 if (layerUnderCursor) {
 const typeStr = layerUnderCursor.type === 'text' ? 'Testo' :
 layerUnderCursor.type === 'image' ? 'Immagine' :
 layerUnderCursor.type === 'shape' ? 'Forma' :
 layerUnderCursor.type === 'vector' ? 'Disegno' : 'Elemento';
 message += `${typeStr}: ${layerUnderCursor.name}`;
 } else {
 message += 'Spazio vuoto';
 }
 
 announceGemini(message, 'polite');
 state.lastLayerUnderCursor = layerUnderCursor;
 }
 
 return;
 }
 
 // Controlla se si sta scrivendo in un campo (per evitare che le scorciatoie interferiscano)
 const inInput = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
 
 
 // --- Funzioni di supporto per aggiunta da esplorazione canvas (tasto A) ---
 function ensureExplorationCursor() {
 if (!state.explorationCursor) {
 state.explorationCursor = { x: Math.floor(canvas.width / 2), y: Math.floor(canvas.height / 2) };
 }
 }
 function exploreAddTextAtCursor() {
 ensureExplorationCursor();
 const txt = prompt('Inserisci il testo da aggiungere:', 'Nuovo Testo');
 if (txt === null) {
 // RIMOSSO (ridondante): announceGemini('Creazione testo annullata', 'polite');
 return;
 }
 if (txt.trim() === '') {
 announceGemini('Testo vuoto, operazione annullata', 'polite');
 return;
 }
 const fontFamily = document.getElementById('nff').value;
 const fontSize = parseInt(document.getElementById('new-font-size').value);
 const fontWeight = document.getElementById('nfw').value;
 const colorPresetVal = textColorPreset.value;
 const color = (colorPresetVal === 'custom') ? textColorHex.value : getColorHex(colorPresetVal);
 const lineHeight = parseFloat(document.getElementById('new-line-height').value);
 const letterSpacing = parseFloat(document.getElementById('new-letter-spacing').value);
 let textAlign = 'left';
 if (document.getElementById('new-btn-align-center').classList.contains('active')) textAlign = 'center';
 else if (document.getElementById('new-btn-align-right').classList.contains('active')) textAlign = 'right';
 const lines = txt.split('\n').length;
 addLayer({
 type: 'text', name: txt, text: txt,
 x: state.explorationCursor.x, y: state.explorationCursor.y,
 fontFamily: fontFamily, fontSize: fontSize, fontWeight: fontWeight,
 color: color, rotation: 0, opacity: 100,
 textAlign: textAlign, letterSpacing: letterSpacing, lineHeight: lineHeight
 });
 const lineText = lines === 1 ? '1 riga' : `${lines} righe`;
 // RIMOSSO (ridondante): announceGemini(`Testo "${txt}" aggiunto a X ${state.explorationCursor.x}, Y ${state.explorationCursor.y}. Occupa ${lineText}`, 'assertive');
 }
 function exploreAddImageAtCursor() {
 ensureExplorationCursor();
 announceGemini(`Carica immagine per posizione X ${state.explorationCursor.x}, Y ${state.explorationCursor.y}. Premi Escape per annullare`, 'assertive');
 const tempInput = document.createElement('input');
 tempInput.type = 'file';
 tempInput.accept = 'image/*';
 tempInput.style.display = 'none';
 document.body.appendChild(tempInput);
 tempInput.addEventListener('change', function(ev) {
 const file = ev.target.files[0];
 if (!file) {
 announceGemini('Nessuna immagine selezionata', 'polite');
 document.body.removeChild(tempInput);
 return;
 }
 const reader = new FileReader();
 reader.onload = res => {
 const img = new Image();
 img.onload = () => {
 const widthStr = prompt(`Larghezza immagine (default ${img.width}px):`, img.width);
 if (widthStr === null) {
 announceGemini('Creazione immagine annullata', 'polite');
 document.body.removeChild(tempInput);
 return;
 }
 const width = parseInt(widthStr) || img.width;
 const heightStr = prompt(`Altezza immagine (default ${img.height}px):`, img.height);
 if (heightStr === null) {
 announceGemini('Creazione immagine annullata', 'polite');
 document.body.removeChild(tempInput);
 return;
 }
 const height = parseInt(heightStr) || img.height;
 addLayer({
 type: 'image', name: file.name.split('.')[0],
 x: state.explorationCursor.x, y: state.explorationCursor.y,
 width: width, height: height,
 rotation: 0, opacity: 100,
 imageElement: img,
 filters: { brightness: 0, contrast: 0, saturation: 0, hue: 0, sepia: 0, blur: 0, preset: 'none' }
 });
 announceGemini(`Immagine "${file.name}" aggiunta a X ${state.explorationCursor.x}, Y ${state.explorationCursor.y}. Dimensioni: ${width} per ${height}`, 'assertive');
 document.body.removeChild(tempInput);
 };
 img.src = res.target.result;
 };
 reader.readAsDataURL(file);
 });
 tempInput.click();
 }
 function exploreAddShapeAtCursor() {
 ensureExplorationCursor();
 const shapeType = prompt(
 'Che forma vuoi aggiungere?\n' +
 '1 = Rettangolo\n' +
 '2 = Cerchio\n' +
 '3 = Triangolo\n' +
 '4 = Stella (5 punte)\n' +
 '5 = Stella (8 punte)\n' +
 '6 = Cuore\n' +
 '7 = Fumetto\n' +
 '8 = Linea\n' +
 '9 = Esagono\n' +
 '0 = Freccia',
 '1'
 );
 if (shapeType === null) {
 announceGemini('Creazione forma annullata', 'polite');
 return;
 }
 const shapes = {
 '1': { shape: 'rect', name: 'Rettangolo', color: '#3b82f6' },
 '2': { shape: 'circle', name: 'Cerchio', color: '#10b981' },
 '3': { shape: 'triangle', name: 'Triangolo', color: '#f59e0b' },
 '4': { shape: 'star', name: 'Stella 5', color: '#eab308' },
 '5': { shape: 'star8', name: 'Stella 8', color: '#f59e0b' },
 '6': { shape: 'heart', name: 'Cuore', color: '#ef4444' },
 '7': { shape: 'speech', name: 'Fumetto', color: '#06b6d4' },
 '8': { shape: 'line', name: 'Linea', color: '#0f172a' },
 '9': { shape: 'hexagon', name: 'Esagono', color: '#8b5cf6' },
 '0': { shape: 'arrow', name: 'Freccia', color: '#ec4899' }
 };
 const selectedShape = shapes[shapeType];
 if (!selectedShape) {
 // RIMOSSO (ridondante): announceGemini('Forma non valida, operazione annullata', 'polite');
 return;
 }
 const widthStr = prompt('Larghezza forma (px):', '200');
 if (widthStr === null) {
 announceGemini('Creazione forma annullata', 'polite');
 return;
 }
 const width = parseInt(widthStr) || 200;
 const heightStr = prompt('Altezza forma (px):', '150');
 if (heightStr === null) {
 announceGemini('Creazione forma annullata', 'polite');
 return;
 }
 const height = parseInt(heightStr) || 150;
 addLayer({
 type: 'shape', shape: selectedShape.shape, name: selectedShape.name,
 x: state.explorationCursor.x, y: state.explorationCursor.y,
 width: width, height: height,
 color: selectedShape.color, rotation: 0, opacity: 100
 });
 announceGemini(`${selectedShape.name} aggiunto a X ${state.explorationCursor.x}, Y ${state.explorationCursor.y}. Dimensioni: ${width} per ${height}`, 'assertive');
 }
 function exploreStartVectorAtCursor() {
 ensureExplorationCursor();
 state.vectorDrawMode = true;
 state.vectorPoints = [];
 state.vectorCursor = { x: state.explorationCursor.x, y: state.explorationCursor.y };
 canvas.style.cursor = 'crosshair';
 scheduleRender();
 announceGemini(`Modalità disegno attivata a X ${state.vectorCursor.x}, Y ${state.vectorCursor.y}. Usa frecce per muovere, Invio per posizionare punto, C per chiudere forma, Escape per annullare`, 'assertive');
 }

// *** NUOVA FUNZIONE: CREAZIONE RAPIDA ELEMENTI DURANTE ESPLORAZIONE ***
 // NON attiva durante Mappa Sonora, disegno vettoriale, o mentre scrivi
 // DISABILITATO se state.exploreMode è attivo (usa il sistema di esplorazione principale)
 if (canvasHasFocus && !state.vectorDrawMode && !state.isGridModeActive && !inInput && !state.exploreMode) {
 const key = e.key.toLowerCase();
 if (key === 'a') {
 e.preventDefault();
 e.stopImmediatePropagation();
 openExploreAddModal();
 return;
 }
 }
// Evita scorciatoie se si sta scrivendo (già controllato sopra ma serve anche qui)
 if (inInput) return;

 // ============================================
 // GESTIONE DISEGNO VETTORIALE (PRIORITÀ ALTA)
 // ============================================
 if (state.vectorDrawMode) {
 // Ctrl+Z nel vettoriale: rimuove ultimo punto
 if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
 e.preventDefault();
 e.stopPropagation();
 if (state.vectorPoints.length > 0) {
 const removed = state.vectorPoints.pop();
 // RIMOSSO (ridondante): announceGemini(`Ultimo punto rimosso. ${state.vectorPoints.length} punt${state.vectorPoints.length === 1 ? 'o' : 'i'} rimanent${state.vectorPoints.length === 1 ? 'e' : 'i'}.`, 'assertive');
 updateVectorUI();
 scheduleRender();
 } else {
 announceGemini('Nessun punto da rimuovere', 'polite');
 }
 return;
 }
 
 // Enter: aggiungi punto
 if (e.key === 'Enter') {
 e.preventDefault();
 addVectorPoint();
 return;
 }
 
 // C: chiudi forma
 if (e.key.toLowerCase() === 'c') {
 e.preventDefault();
 closeVectorShape(true);
 return;
 }
 
 // O: tracciato aperto
 if (e.key.toLowerCase() === 'o') {
 e.preventDefault();
 closeVectorShape(false);
 return;
 }
 
 // I: info posizione e punti
 if (e.key.toLowerCase() === 'i') {
 e.preventDefault();
 const numPoints = state.vectorPoints.length;
 const typeName = state.vectorDrawType === 'smooth' ? 'Pennarello Smooth' : 'Polilinea';
 announceGemini(`${typeName} attivo. Posizione cursore: X ${Math.round(state.vectorCursor.x)}, Y ${Math.round(state.vectorCursor.y)}. ${numPoints} punt${numPoints === 1 ? 'o' : 'i'} posizionat${numPoints === 1 ? 'o' : 'i'}.`, 'assertive');
 return;
 }
 
 // Frecce: muovi cursore vettoriale
 if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
 e.preventDefault();
 
 // Calcola il passo con moltiplicatori
 let multiplier = 1;
 if (e.shiftKey) multiplier = 4; // Veloce
 else if (e.ctrlKey) multiplier = 0.2; // Preciso
 
 const step = state.vectorStep * multiplier;
 const oldX = state.vectorCursor.x;
 const oldY = state.vectorCursor.y;
 
 // Calcola nuova posizione
 let newX = state.vectorCursor.x;
 let newY = state.vectorCursor.y;
 
 if (e.key === 'ArrowUp') newY -= step;
 if (e.key === 'ArrowDown') newY += step;
 if (e.key === 'ArrowLeft') newX -= step;
 if (e.key === 'ArrowRight') newX += step;
 
 // Bounds checking robusto
 const margin = 0.5;
 newX = Math.max(margin, Math.min(canvas.width - margin, newX));
 newY = Math.max(margin, Math.min(canvas.height - margin, newY));
 
 const moved = (newX !== oldX || newY !== oldY);
 
 state.vectorCursor.x = newX;
 state.vectorCursor.y = newY;
 
 scheduleRender();
 
 // Annuncia con debounce
 if (moved) {
 announceDebounced(`X: ${Math.round(newX)}, Y: ${Math.round(newY)}`, 'polite', 300);
 } else {
 announceGemini('Bordo canvas raggiunto', 'polite');
 }
 return;
 }
 
 // Escape: esci da modalità vettoriale
 if (e.key === 'Escape') {
 e.preventDefault();
 toggleVectorMode();
 return;
 }
 }

 // ============================================
 // SCORCIATOIE GLOBALI (PRIORITÀ NORMALE)
 // ============================================
 if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'p') { e.preventDefault(); toggleVectorMode(); }
 else if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); e.shiftKey ? redo() : undo(); }
 else if ((e.ctrlKey || e.metaKey) && e.key === 'y') { e.preventDefault(); redo(); }
 else if ((e.ctrlKey || e.metaKey) && e.key === 'c') { e.preventDefault(); copyLayer(); }
 else if ((e.ctrlKey || e.metaKey) && e.key === 'v') { e.preventDefault(); pasteLayer(); }
 else if ((e.ctrlKey || e.metaKey) && e.key === 'd') { e.preventDefault(); duplicateLayer(); }
 else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'm') { e.preventDefault(); toggleGridMode(); }
 else if (e.key === 'Delete') { e.preventDefault(); deleteLayer(); }
 else if (e.key === '+' || e.key === '=') { e.preventDefault(); setZoom(state.zoom + 0.1); }
 else if (e.key === '-') { e.preventDefault(); setZoom(state.zoom - 0.1); }
 else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
 if (!state.vectorDrawMode) {
 e.preventDefault();
 const layer = getSelectedLayer();
 if (layer && !layer.locked) {
 const step = e.shiftKey ? 10 : 1;
 if (e.key === 'ArrowUp') layer.y = snapToGrid(layer.y - step);
 if (e.key === 'ArrowDown') layer.y = snapToGrid(layer.y + step);
 if (e.key === 'ArrowLeft') layer.x = snapToGrid(layer.x - step);
 if (e.key === 'ArrowRight') layer.x = snapToGrid(layer.x + step);
 scheduleRender();
 updateUI(); // Aggiorna input X/Y
 }
 }
 }
 });

 document.addEventListener('keyup', e => {
 const inInput = ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName);
 if (inInput) return;
 
 if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !state.vectorDrawMode) {
 const layer = getSelectedLayer();
 if (layer) {
 saveState('Livello spostato');
 // Annuncio disabilitato - causava troppi annunci indesiderati
 // announceGemini(`X: ${Math.round(layer.x)}, Y: ${Math.round(layer.y)}`, 'polite');
 }
 }
 });
 }

 // ---- INIT ----
 function init() {
 // Carica palette salvata
 const savedPalette = localStorage.getItem('colorPalette_v21');
 if (savedPalette) {
 state.colorPalette = JSON.parse(savedPalette);
 }
 updateColorPalette();
 
 setupListeners();
 updateVectorUI(); // Inizializza UI disegno vettoriale
 saveState('Iniziale'); // Salva lo stato di partenza
 scheduleRender();
 updateUI();
 
 // ACCESSIBILITÀ: Nascondi completamente controlli sfondo inattivi
 // Di default è attivo "Colore Solido", quindi nascondi gradiente e immagine
 const gradientControls = document.getElementById('bg-gradient-controls');
 const imageControls = document.getElementById('bg-image-controls');
 
 gradientControls.setAttribute('aria-hidden', 'true');
 gradientControls.setAttribute('inert', '');
 gradientControls.querySelectorAll('input, select, button, textarea').forEach(el => {
 el.setAttribute('tabindex', '-1');
 el.setAttribute('disabled', 'disabled');
 });
 
 imageControls.setAttribute('aria-hidden', 'true');
 imageControls.setAttribute('inert', '');
 imageControls.querySelectorAll('input, select, button, textarea').forEach(el => {
 el.setAttribute('tabindex', '-1');
 el.setAttribute('disabled', 'disabled');
 });
 
 // Applica il template di default al canvas
 document.getElementById('btn-apply-canvas').click();
 
 announce(' Editor Grafico v30.1 ACCESSIBILE pronto! Premi F1 per la guida, F2 per aiuto contestuale. ');
 
 // ═══════════════════════════════════════════════════════════════
 // SISTEMA AIUTO CONTESTUALE (F2) - Inizializzato dopo setup
 // ═══════════════════════════════════════════════════════════════
 
 const helpDatabase = {
 'tpl': { name: 'Dimensioni Template', description: 'Qui scegli la grandezza del tuo progetto. Post Instagram è quadrato 1080x1080. Story Instagram è verticale 1080x1920. YouTube è orizzontale 1280x720.', tip: 'Scegli in base a dove pubblicherai: Instagram, Facebook, YouTube, ecc.' },
 'canvas-w': { name: 'Larghezza Canvas', description: 'Quanto è largo il tuo progetto in pixel. Più grande = migliore qualità ma file più pesante.', tip: 'Per social: 1000-1500px va bene. Per stampare: minimo 2000px.' },
 'canvas-h': { name: 'Altezza Canvas', description: 'Quanto è alto il tuo progetto in pixel.', tip: 'Mantieni le proporzioni giuste: quadrato per post Instagram, verticale per Stories.' },
 
 // GRIGLIA E SNAP
 'show-grid': { name: 'Mostra Griglia', description: 'Mostra delle linee guida sul canvas per aiutarti ad allineare testo e immagini.', tip: 'La griglia non si vede nell\'immagine finale, è solo un aiuto visivo.' },
 'grid-size': { name: 'Dimensione Griglia', description: 'Quanto sono distanti le linee della griglia. 10 pixel = linee vicine, 100 pixel = linee lontane.', tip: 'Griglia fitta (10-20px) per allineamenti precisi. Griglia larga (50-100px) per meno confusione.' },
 'snap-to-grid': { name: 'Snap alla Griglia', description: 'Se attivo, quando sposti un elemento si "attacca" automaticamente alle linee della griglia come una calamita.', tip: 'Utile per avere tutto perfettamente allineato. Disattiva se vuoi posizionare liberamente.' },
 
 // SFONDO
 'bg-type': { name: 'Tipo Sfondo', description: 'Colore Solido: un solo colore uniforme su tutto lo sfondo. Gradiente: due colori che sfumano uno nell\'altro. Immagine: una foto o texture di sfondo.', tip: 'Colore solido è semplice e pulito. Gradiente è moderno. Immagine crea atmosfera ma può rendere difficile leggere il testo.' },
 'bg-color-preset': { name: 'Colore Sfondo', description: 'Scegli un colore predefinito per lo sfondo del progetto, oppure seleziona "Personalizzato" per inserire un colore specifico tramite codice HEX o valori RGB.', tip: 'I colori predefiniti sono i più usati. Per colori esatti (esempio: colori aziendali) usa "Personalizzato" e inserisci il codice HEX che ti danno.' },
 'bg-color-hex': { name: 'Codice HEX Colore', description: 'Il codice esadecimale del colore. Esempio: #FF0000 per rosso, #00FF00 per verde, #0000FF per blu.', tip: 'I codici HEX si copiano da tool online o dai brand book aziendali. Assicurati che inizi con # seguito da 6 caratteri (0-9, A-F).' },
 'bg-color-r': { name: 'Valore Rosso (R)', description: 'Quanto rosso c\'è nel colore, da 0 a 255. 0 = niente rosso, 255 = massimo rosso.', tip: 'RGB è come mescolare la luce: Rosso 255, Verde 0, Blu 0 = Rosso puro. Tutti a 255 = Bianco. Tutti a 0 = Nero.' },
 'bg-color-g': { name: 'Valore Verde (G)', description: 'Quanto verde c\'è nel colore, da 0 a 255. 0 = niente verde, 255 = massimo verde.', tip: 'Verde alto con rosso alto fa giallo. Verde alto con blu alto fa ciano (azzurro chiaro).' },
 'bg-color-b': { name: 'Valore Blu (B)', description: 'Quanto blu c\'è nel colore, da 0 a 255. 0 = niente blu, 255 = massimo blu.', tip: 'Blu alto con rosso alto fa magenta (viola-rosa). Quando modifichi RGB, il codice HEX si aggiorna automaticamente.' },
 'gradient-type': { name: 'Tipo Gradiente', description: 'Lineare: il gradiente va dritto da un lato all\'altro. Radiale: il gradiente parte dal centro e si espande verso i bordi come un cerchio.', tip: 'Lineare è più comune e professionale. Radiale crea effetti particolari come riflettori o vignette.' },
 'gradient-color1': { name: 'Primo Colore Gradiente', description: 'Il colore da cui parte il gradiente dello sfondo.', tip: 'Combinazioni belle: blu e viola per tecnologia, arancione e rosa per tramonto, verde e blu per natura.' },
 'gradient-color2': { name: 'Secondo Colore Gradiente', description: 'Il colore dove finisce il gradiente dello sfondo.', tip: 'Per un effetto delicato usa due tonalità dello stesso colore, esempio: azzurro chiaro e azzurro scuro.' },
 'gradient-angle': { name: 'Angolo Gradiente', description: 'La direzione del gradiente. 0 gradi va verso destra, 90 gradi va verso il basso, 180 gradi va verso sinistra, 270 gradi va verso l\'alto.', tip: 'Diagonali come 45 o 135 gradi rendono il design più dinamico e interessante.' },
 'bg-image-upload': { name: 'Carica Immagine Sfondo', description: 'Carica una foto o texture da usare come sfondo del progetto. Puoi caricare JPG, PNG o WebP.', tip: 'Usa immagini sfocate o con colori tenui così il testo sopra rimane leggibile.' },
 
 // TESTO
 'new-text': { name: 'Contenuto Testo', description: 'Qui scrivi il testo che vuoi far apparire sul progetto.', tip: 'Sui social i testi brevi funzionano meglio. Massimo 2 o 3 righe altrimenti diventa difficile da leggere.' },
 'new-font-family': { name: 'Font', description: 'Il tipo di carattere del testo. Sono disponibili 17 font divisi per categorie. Sans-serif moderni: Arial, Montserrat, Open Sans, Roboto, Lato, Poppins, Raleway, Oswald. Serif eleganti: Georgia, Times New Roman, Merriweather, Playfair Display. Speciali: Courier New (codice), Verdana, Trebuchet MS, Impact (titoli), Comic Sans MS.', tip: 'Per social: Montserrat, Poppins, Oswald. Per leggibilità massima: Arial, Open Sans, Roboto. Per eleganza: Playfair Display, Merriweather, Georgia. Per titoli impattanti: Impact, Oswald.' },
 'new-font-size': { name: 'Dimensione Font', description: 'Quanto è grande il testo in pixel. Più è grande più si vede da lontano.', tip: 'Su telefono usa minimo 20-24 pixel altrimenti non si legge. Per titoli grandi: 60-100 pixel. Per sottotitoli: 32-48 pixel.' },
 'new-font-weight': { name: 'Peso Font', description: 'Quanto è grassetto il testo. 400 è normale, 700 è grassetto, 900 è extra-grassetto.', tip: 'Usa grassetto (700) per titoli e normale (400) per il resto del testo.' },
 'text-color-preset': { name: 'Colore Testo', description: 'Scegli un colore predefinito per il testo, oppure seleziona "Personalizzato" per inserire un colore specifico tramite codice HEX o valori RGB.', tip: 'Nero su bianco o bianco su nero sono le combinazioni più leggibili. Per testi importanti usa sempre colori che contrastano bene con lo sfondo.' },
 'text-color-hex': { name: 'Codice HEX Colore Testo', description: 'Il codice esadecimale del colore del testo. Esempio: #000000 per nero, #FFFFFF per bianco, #FF0000 per rosso.', tip: 'Se hai i colori del brand aziendale, usa questi codici per mantenere l\'identità visiva.' },
 'text-color-r': { name: 'Valore Rosso Testo (R)', description: 'Quanto rosso c\'è nel colore del testo, da 0 a 255.', tip: 'Modifica questo valore insieme a Verde e Blu per creare il colore esatto che desideri.' },
 'text-color-g': { name: 'Valore Verde Testo (G)', description: 'Quanto verde c\'è nel colore del testo, da 0 a 255.', tip: 'I valori RGB si sincronizzano automaticamente con il codice HEX.' },
 'text-color-b': { name: 'Valore Blu Testo (B)', description: 'Quanto blu c\'è nel colore del testo, da 0 a 255.', tip: 'Puoi copiare valori RGB da tool come Adobe Color o Coolors.' },
 'letter-spacing': { name: 'Spaziatura Lettere', description: 'Lo spazio tra una lettera e l\'altra. Numeri positivi allargano le lettere, numeri negativi le stringono.', tip: 'Per titoli eleganti aumenta di 1 o 2 pixel. Non esagerare senno diventa difficile da leggere.' },
 'line-height': { name: 'Altezza Riga', description: 'Lo spazio tra una riga di testo e la successiva. 1.0 significa righe attaccate, 2.0 significa doppio spazio.', tip: 'Per testo normale usa 1.5. Per titoli 1.2 va bene. Più spazio rende il testo più leggibile.' },
 
 // IMMAGINI
 'image-upload': { name: 'Carica Immagine', description: 'Aggiungi una foto o immagine al progetto. Puoi caricare JPG, PNG, WebP o GIF.', tip: 'Per qualità buona usa immagini di almeno 1000 pixel. File troppo grandi (oltre 5MB) potrebbero rallentare.' },
 'new-image-w': { name: 'Larghezza Iniziale Immagine', description: 'Quanto sarà larga l\'immagine quando la aggiungi, in pixel.', tip: 'Puoi sempre cambiarla dopo nei controlli Trasformazioni.' },
 'new-image-h': { name: 'Altezza Iniziale Immagine', description: 'Quanto sarà alta l\'immagine quando la aggiungi, in pixel.', tip: 'Se attivi Mantieni Proporzioni, l\'altezza si aggiusta automaticamente per non deformare l\'immagine.' },
 'new-image-x': { name: 'Posizione X Iniziale Immagine', description: 'Dove apparirà l\'immagine da sinistra a destra. 0 significa tutto a sinistra.', tip: 'Per centrare: larghezza progetto meno larghezza immagine, dividi per 2. Esempio: 1080 meno 500 = 580, diviso 2 = 290.' },
 'new-image-y': { name: 'Posizione Y Iniziale Immagine', description: 'Dove apparirà l\'immagine dall\'alto verso il basso. 0 significa in cima.', tip: 'Puoi sempre spostarla dopo trascinandola col mouse o nei controlli Trasformazioni.' },
 
 // FORME
 'new-rect': { name: 'Nuovo Rettangolo', description: 'Crea un rettangolo o quadrato. Utile per fare riquadri colorati, pulsanti, cornici.', tip: 'Angoli arrotondati = moderno. Angoli retti = professionale e pulito.' },
 'new-circle': { name: 'Nuovo Cerchio', description: 'Crea un cerchio perfetto. Ottimo per fare badge, bollini, avatar.', tip: 'I cerchi attirano l\'occhio. Usali per evidenziare cose importanti.' },
 'new-triangle': { name: 'Nuovo Triangolo', description: 'Crea un triangolo. Perfetto per frecce, simboli play, decorazioni.', tip: 'I triangoli indicano una direzione. Puntali verso quello che vuoi far notare.' },
 'new-star': { name: 'Nuova Stella', description: 'Crea una stella a 5 punte. Ottima per recensioni (tipo 5 stelle su 5), badge premio.', tip: 'Stelle gialle = recensioni classiche. Altri colori = più creatività.' },
 'new-shape-color': { name: 'Colore Forma', description: 'Il colore della forma che stai creando.', tip: 'Scegli un colore che si veda bene sullo sfondo. Puoi cambiarlo dopo.' },
 'new-corner-radius': { name: 'Arrotondamento Angoli', description: 'Quanto sono tondi gli angoli del rettangolo. 0 = angoli appuntiti, numeri alti = angoli rotondi.', tip: '0 = spigoloso, 8-16 = moderno, 30 e oltre = molto rotondo, 999 = cerchio.' },
 
 // LIVELLO SELEZIONATO
 'layer-color': { name: 'Colore Livello', description: 'Il colore dell\'elemento selezionato. Per testo: colore lettere. Per forme: colore interno.', tip: 'Usa colori che si vedono: scuro su chiaro o chiaro su scuro.' },
 'use-gradient': { name: 'Usa Gradiente', description: 'Invece di un colore solo, usa due colori che sfumano uno nell\'altro.', tip: 'I gradienti sono più moderni. Prova blu che sfuma in viola o arancione in rosa.' },
 'gradient-type-layer': { name: 'Tipo Gradiente Livello', description: 'Lineare: va dritto. Radiale: parte dal centro e si allarga.', tip: 'Radiale su cerchi fa un bell\'effetto 3D. Lineare va bene per tutto.' },
 'stroke-color': { name: 'Colore Bordo', description: 'Il colore del contorno attorno all\'elemento.', tip: 'Bordo nero spesso = stile fumetto. Bordo sottile = elegante.' },
 'stroke-width': { name: 'Spessore Bordo', description: 'Quanto è grosso il bordo. 1-2 pixel = sottile, 5-10 pixel = spesso.', tip: '2 pixel per essere discreto, 6 pixel per stile fumetto. Oltre 10 copre i dettagli.' },
 'use-stroke': { name: 'Usa Bordo', description: 'Attiva o disattiva il contorno attorno all\'elemento.', tip: 'Utile quando l\'elemento e lo sfondo hanno colori simili.' },
 
 // TRASFORMAZIONI AVANZATE
 'pos-x': { name: 'Posizione X (Orizzontale)', description: 'Dove si trova l\'elemento da sinistra a destra in pixel. 0 = tutto a sinistra.', tip: 'Frecce tastiera = piccoli spostamenti. Shift più freccia = spostamenti veloci.' },
 'pos-y': { name: 'Posizione Y (Verticale)', description: 'Dove si trova l\'elemento dall\'alto in basso in pixel. 0 = in cima.', tip: 'Per centrare: altezza progetto meno altezza elemento, dividi per 2.' },
 'width': { name: 'Larghezza Elemento', description: 'Quanto è largo l\'elemento in pixel.', tip: 'Attiva Mantieni Proporzioni per non deformare immagini quando le ridimensioni.' },
 'height': { name: 'Altezza Elemento', description: 'Quanto è alto l\'elemento in pixel.', tip: 'Con Mantieni Proporzioni attivo, se cambi l\'altezza la larghezza si aggiusta da sola.' },
 'maintain-aspect': { name: 'Mantieni Proporzioni', description: 'Se attivo, quando cambi larghezza l\'altezza si adatta automaticamente e viceversa. Così l\'immagine non si deforma.', tip: 'Tienilo SEMPRE attivo per le foto, senno si stirano. Per forme puoi disattivarlo se vuoi stirarle apposta.' },
 'corner-radius': { name: 'Arrotondamento Angoli (Rettangoli)', description: 'Quanto sono rotondi gli angoli del rettangolo. Funziona solo sui rettangoli.', tip: '0 = angoli retti. 8-16 = moderno. 30-50 = molto rotondo. Numeri altissimi = cerchio.' },
 
 // EFFETTI & OMBRA
 'shadow-enabled': { name: 'Attiva Ombra', description: 'Aggiunge un\'ombra sotto l\'elemento per farlo sembrare sollevato dallo sfondo.', tip: 'Le ombre rendono tutto più professionale e aiutano a leggere meglio su sfondi complicati.' },
 'shadow-color': { name: 'Colore Ombra', description: 'Il colore dell\'ombra. Di solito è nero o grigio scuro.', tip: 'Nero leggermente trasparente è l\'ombra più realistica. Per effetti strani usa colori vivaci.' },
 'shadow-blur': { name: 'Sfocatura Ombra', description: 'Quanto è sfocata l\'ombra. 0 = bordi netti, 50 = molto sfumata.', tip: '10 pixel = ombra vicina. 30 pixel = ombra lontana. Più sfocata = elemento più sollevato.' },
 'shadow-x': { name: 'Spostamento Ombra X', description: 'Di quanto l\'ombra è spostata a destra o sinistra. Numeri positivi = destra, negativi = sinistra.', tip: 'Più 5 = luce da sinistra (più comune). Meno 5 = luce da destra. Valori piccoli sono più realistici.' },
 'shadow-y': { name: 'Spostamento Ombra Y', description: 'Di quanto l\'ombra è spostata in basso o in alto. Numeri positivi = basso, negativi = alto.', tip: 'Più 5 = luce dall\'alto (sembra naturale). Meno 5 = luce dal basso (effetto strano). Ombre verso il basso sembrano più normali.' },
 'blend-mode': { name: 'Modalità Fusione', description: 'Come questo elemento si mescola con quelli sotto. Normale: nessun effetto. Multiply: scurisce. Screen: schiarisce. Overlay: più contrasto.', tip: 'Normale va bene quasi sempre. Gli altri fanno effetti particolari, provali per divertirti.' },
 
 // ALLINEAMENTO E DISTRIBUZIONE
 'btn-align-left-rel': { name: 'Allinea Sinistra (Relativo)', description: 'Allinea il bordo sinistro di tutti gli elementi selezionati al bordo sinistro del primo elemento. Serve: 2+ elementi selezionati (Ctrl+Click).', tip: 'Ottimo per allineare una colonna di elementi a sinistra. Seleziona prima l\'elemento di riferimento, poi gli altri.' },
 'btn-align-center-h-rel': { name: 'Allinea Centro Orizzontale (Relativo)', description: 'Allinea i centri orizzontali di tutti gli elementi selezionati al centro del primo elemento. Serve: 2+ elementi selezionati.', tip: 'Perfetto per centrare verticalmente una pila di elementi come testi o pulsanti.' },
 'btn-align-right-rel': { name: 'Allinea Destra (Relativo)', description: 'Allinea il bordo destro di tutti gli elementi selezionati al bordo destro del primo elemento. Serve: 2+ elementi selezionati.', tip: 'Usa per allineare una colonna di testi a destra, come nelle ricevute o nei menu.' },
 'btn-align-top-rel': { name: 'Allinea Alto (Relativo)', description: 'Allinea il bordo superiore di tutti gli elementi selezionati al bordo superiore del primo elemento. Serve: 2+ elementi selezionati.', tip: 'Ottimo per allineare una riga orizzontale di elementi in alto.' },
 'btn-align-center-v-rel': { name: 'Allinea Centro Verticale (Relativo)', description: 'Allinea i centri verticali di tutti gli elementi selezionati al centro del primo elemento. Serve: 2+ elementi selezionati.', tip: 'Perfetto per allineare elementi in una fila orizzontale alla stessa altezza, come loghi o icone.' },
 'btn-align-bottom-rel': { name: 'Allinea Basso (Relativo)', description: 'Allinea il bordo inferiore di tutti gli elementi selezionati al bordo inferiore del primo elemento. Serve: 2+ elementi selezionati.', tip: 'Usa per allineare una riga di elementi in basso, come footer o pulsanti.' },
 'btn-distribute-h': { name: 'Distribuzione Orizzontale', description: 'Distribuisce uniformemente 3+ elementi selezionati in orizzontale, creando spazi uguali tra loro. Mantiene primo e ultimo fissi.', tip: 'Perfetto per menu, gallerie, o serie di pulsanti. Gli spazi tra gli elementi saranno tutti uguali.' },
 'btn-distribute-v': { name: 'Distribuzione Verticale', description: 'Distribuisce uniformemente 3+ elementi selezionati in verticale, creando spazi uguali tra loro. Mantiene primo e ultimo fissi.', tip: 'Ottimo per liste, colonne di testo, o sequenze verticali. Gli spazi saranno perfettamente uniformi.' },
 
 // MASCHERA DI RITAGLIO
 'mask-shape': { name: 'Forma Maschera', description: 'Ritaglia l\'immagine con una forma geometrica. Solo per immagini. Cerchio = foto profilo. Stella = badge. Cuore = romantico. Esagono = moderno.', tip: 'Le maschere NON cancellano l\'immagine, la ritagliano solo visivamente. Puoi rimuoverle e l\'immagine torna normale.' },
 'btn-apply-mask': { name: 'Applica Maschera', description: 'Applica la forma maschera selezionata all\'immagine. L\'immagine verrà ritagliata con quella forma.', tip: 'Puoi sempre cambiare maschera o rimuoverla senza perdere l\'immagine originale. Prova diverse forme!' },
 'btn-remove-mask': { name: 'Rimuovi Maschera', description: 'Rimuove la maschera dall\'immagine, riportandola al rettangolo completo originale.', tip: 'L\'immagine originale non viene mai danneggiata, solo mostrata o nascosta dalla maschera.' },
 
 // ESPORTAZIONE
 'export-format': { name: 'Formato Esportazione', description: 'In che formato salvare il progetto. PNG: massima qualità e sfondo trasparente, file grande. JPG: file leggero, NO trasparenza. WebP: moderno, buon compromesso.', tip: 'PNG per loghi con trasparenza. JPG per foto da caricare veloci. WebP è nuovo e ottimo per tutto.' },
 'export-quality': { name: 'Qualità Esportazione', description: 'Quanto comprimere il file. 100 = qualità massima ma file grosso. 70 = buon compromesso.', tip: '95-100 per stampare. 80-85 per Instagram e Facebook. 70 per mandare su WhatsApp o email.' },
 
 // GRIGLIA E SNAP
 'show-grid': { name: 'Mostra Griglia di Aiuto', description: 'Mostra una griglia di linee guida sul canvas per aiutarti ad allineare gli elementi.', tip: 'Attiva questa opzione quando vuoi allineare più elementi. La griglia è solo visiva, non apparirà nell\'immagine finale.' },
 'snap-to-grid': { name: 'Snap alla Griglia', description: 'Gli elementi si attaccano automaticamente alle linee della griglia come una calamita quando li sposti.', tip: 'Funziona solo se la griglia è visibile. Utile per allineamenti perfetti. Disattiva se vuoi libertà totale.' },
 'btn-center-text-position': { name: 'Centra Testo nel Canvas', description: 'Imposta automaticamente la posizione X e Y al centro del template corrente (es. 540x540 per Instagram Post 1080x1080, 540x960 per Story 1080x1920) e imposta l\'allineamento su Centro. Questo garantisce che il testo appaia visivamente centrato.', tip: 'Il centro viene calcolato automaticamente in base alle dimensioni del template che hai scelto. Funziona con tutti i template disponibili!' },
 
 // TRASFORMAZIONI BASE
 'opacity': { name: 'Opacità', description: 'Quanto è trasparente l\'elemento. 100 percento = si vede tutto. 0 percento = invisibile.', tip: '80 percento = leggermente trasparente. 50 percento = metà trasparente. 70-90 percento per sovrapposizioni belle.' },
 'rotation': { name: 'Rotazione', description: 'Ruota l\'elemento in gradi. 0 gradi = dritto. 90 gradi = girato di un quarto. 180 gradi = sottosopra. 360 gradi = giro completo.', tip: '45 gradi = dinamico. 90 e 270 gradi = verticale. Rotazioni precise come 0, 45, 90, 180 sono più belle.' },
 
 // GESTIONE LIVELLI
 'layer-list': { name: 'Lista Livelli', description: 'Mostra tutti gli elementi nel progetto. Quelli in alto nella lista appaiono sopra gli altri.', tip: 'Clicca su un livello per selezionarlo. Usa le frecce per cambiare l\'ordine.' },
 'btn-move-up': { name: 'Sposta Livello Su', description: 'Porta l\'elemento selezionato più in alto così appare sopra gli altri.', tip: 'Tasti rapidi: Ctrl più freccia su. Utile per portare qualcosa in primo piano.' },
 'btn-move-down': { name: 'Sposta Livello Giù', description: 'Manda l\'elemento selezionato più in basso così va dietro agli altri.', tip: 'Tasti rapidi: Ctrl più freccia giù. Usa questo per mandare cose sullo sfondo.' },
 'btn-duplicate-layer': { name: 'Duplica Livello', description: 'Crea una copia uguale dell\'elemento selezionato.', tip: 'Tasti rapidi: Ctrl più D. Perfetto per creare pattern o elementi ripetuti.' },
 'btn-delete-layer': { name: 'Elimina Livello', description: 'Cancella l\'elemento selezionato dal progetto. Puoi annullare con Ctrl più Z.', tip: 'Tasti rapidi: Canc. Attenzione: dopo aver salvato non puoi più recuperarlo.' },
 'btn-lock-layer': { name: 'Blocca Livello', description: 'Un elemento bloccato non può essere spostato o modificato per sbaglio.', tip: 'Blocca lo sfondo e cose importanti così non le sposti mentre lavori.' },
 
 // ALLINEAMENTO TESTO
 'btn-align-left': { name: 'Allinea Sinistra', description: 'Allinea il testo a sinistra. Ogni riga inizia dal bordo sinistro.', tip: 'È l\'allineamento più usato e più facile da leggere per testi lunghi.' },
 'btn-align-center': { name: 'Allinea Centro', description: 'Centra il testo. Ogni riga è al centro.', tip: 'Perfetto per titoli e citazioni. Non usarlo per testi lunghi perché diventa difficile da leggere.' },
 'btn-align-right': { name: 'Allinea Destra', description: 'Allinea il testo a destra. Ogni riga finisce sul bordo destro.', tip: 'Si usa poco. Va bene per firme, date, o effetti particolari.' },
 'btn-center-in-canvas': { 
 name: 'Centra nel Canvas', 
 description: 'Posiziona automaticamente il testo al centro esatto del canvas, sia orizzontalmente che verticalmente. Il sistema calcola la larghezza reale del blocco testo (tenendo conto di font, dimensioni, spaziatura lettere e righe) e lo centra perfettamente.', 
 tip: 'Usa questo quando vuoi che il testo sia proprio al centro visivo dell\'immagine. È diverso da "Allinea Centro" che controlla solo come le righe si dispongono tra loro. Shortcut: Ctrl+Shift+C' 
 },
 
 // STILE TESTO
 'btn-italic': { name: 'Corsivo', description: 'Rende il testo inclinato. Utile per citazioni o enfasi.', tip: 'Il corsivo è più difficile da leggere, usalo poco.' },
 'btn-underline': { name: 'Sottolineato', description: 'Aggiunge una linea sotto il testo. Spesso usato per link.', tip: 'Sui social il sottolineato può confondere perché sembra un link. Usa con attenzione.' },
 'btn-line-through': { name: 'Barrato', description: 'Disegna una linea attraverso il testo. Perfetto per sconti.', tip: 'Ottimo per prezzi: scrivi il vecchio prezzo barrato e il nuovo prezzo normale.' },
 
 // IMMAGINI
 'btn-flip-h': { name: 'Specchia Orizzontale', description: 'Ribalta l\'immagine da sinistra a destra come uno specchio.', tip: 'Utile per creare simmetrie o correggere foto girate al contrario.' },
 'btn-flip-v': { name: 'Specchia Verticale', description: 'Ribalta l\'immagine dall\'alto al basso, sottosopra.', tip: 'Si usa meno dello specchio orizzontale, ma crea effetti creativi interessanti.' },
 'replace-image': { name: 'Sostituisci Immagine', description: 'Cambia la foto mantenendo posizione, dimensione e tutti gli effetti.', tip: 'Utile per provare foto diverse senza dover rifare tutto il lavoro.' },
 
 // FILTRI IMMAGINE
 'filter-brightness': { 
 name: 'Luminosità', 
 description: 'Schiarisce o scurisce tutta l\'immagine allo stesso modo. È veloce ma "grossolano" - non fa miracoli. +50 = tutto più chiaro, -50 = tutto più scuro.', 
 tip: ' Usalo per: "La foto è un po\' scura/chiara, aggiusto velocemente". NON usarlo se: Hai ombre completamente nere o luci completamente bianche dove hai perso i dettagli. In quel caso, vai in Effetti Avanzati e usa Auto Levels che recupera i dettagli.' 
 },
 'filter-contrast': { 
 name: 'Contrasto', 
 description: 'Aumenta la differenza tra chiaro e scuro. I neri diventano più neri, i bianchi più bianchi. Rende la foto più "vivace" e meno "piatta".', 
 tip: ' Usalo per: Foto che sembrano "spente" o "sbiadite". Prova +10 o +20. Differenza con Auto Levels: Contrast dà "impatto visivo". Auto Levels "recupera dettagli persi nelle ombre/luci". Sono due cose diverse!' 
 }
 };
 
 function showHelp(controlId) {
 const help = helpDatabase[controlId];
 if (!help) return;
 
 const modal = document.getElementById('help-modal');
 if (!modal) return;
 
 const title = document.getElementById('help-title');
 const content = document.getElementById('help-content');
 
 title.textContent = ' ' + help.name;
 
 let html = '<p style="margin: 0 0 12px 0;"><strong>Descrizione:</strong></p>';
 html += '<p style="margin: 0 0 16px 0; color: var(--text-secondary);">' + help.description + '</p>';
 
 if (help.tip) {
 html += '<p style="margin: 0 0 8px 0;"><strong> Suggerimento:</strong></p>';
 html += '<p style="margin: 0; padding: 12px; background: rgba(66, 153, 225, 0.1); border-left: 3px solid var(--primary-color); border-radius: 6px;">' + help.tip + '</p>';
 }
 
 content.innerHTML = html;
 modal.style.display = 'flex';
 
 // Annuncia per NVDA
 setTimeout(() => {
 announceGemini('Modale aiuto aperto: ' + help.name + '. Premi Escape per chiudere.', 'assertive');
 }, 100);
 }
 
 function hideHelp() {
 const modal = document.getElementById('help-modal');
 if (modal) {
 modal.style.display = 'none';
 // Riporta il focus sull'elemento che aveva aperto la modale
 if (elementBeforeModal && elementBeforeModal.focus) {
 setTimeout(() => {
 elementBeforeModal.focus();
 announceGemini('Aiuto chiuso. Focus ripristinato', 'polite');
 elementBeforeModal = null; // Reset
 }, 50);
 }
 }
 }
 
 // Setup help modal event listeners
 const helpCloseBtn = document.getElementById('help-close-btn');
 const helpModal = document.getElementById('help-modal');
 
 if (helpCloseBtn) helpCloseBtn.addEventListener('click', hideHelp);
 if (helpModal) {
 helpModal.addEventListener('click', (e) => {
 if (e.target.id === 'help-modal') hideHelp();
 });
 }
 
 // F2 key handler
 let lastFocusedElement = null;
 let elementBeforeModal = null; // Salva l'elemento prima di aprire il modale
 
 document.addEventListener('focusin', (e) => {
 // Non aggiornare se siamo dentro il modale di aiuto
 const helpModal = document.getElementById('help-modal');
 if (!helpModal || helpModal.style.display !== 'flex') {
 lastFocusedElement = e.target;
 }
 });
 
 document.addEventListener('keydown', (e) => {
 // F2 per aiuto - NON interferisce con altri tasti
 if (e.key === 'F2') {
 e.preventDefault();
 const focused = lastFocusedElement || document.activeElement;
 if (focused && focused.id && helpDatabase[focused.id]) {
 elementBeforeModal = focused; // Salva PRIMA di aprire
 showHelp(focused.id);
 } else {
 announceGemini('️ Seleziona un controllo e premi F2', 'polite');
 }
 return; // Exit early per non interferire
 }
 // Escape per chiudere aiuto
 if (e.key === 'Escape') {
 const modal = document.getElementById('help-modal');
 if (modal && modal.style.display === 'flex') {
 e.stopPropagation(); // Previeni altri handler
 hideHelp();
 }
 }
 });
 }

 init();
 })();
 
 // ═══════════════════════════════════════════════════════════════
 // LISTENER GLOBALE DISEGNO VETTORIALE (CAPTURE MODE)
 // Deve essere FUORI dalla closure per avere accesso a window.state
 // ═══════════════════════════════════════════════════════════════
 document.addEventListener('keydown', function(e) {
 console.log(' [VECTOR GLOBAL] Tasto premuto:', e.key, 'vectorDrawMode:', window.state?.vectorDrawMode);
 
 // Solo se la modalità vettoriale è attiva
 if (!window.state || !window.state.vectorDrawMode) {
 return;
 }
 
 console.log(' [VECTOR GLOBAL] Modalità vettoriale attiva!');
 
 // SKIP se siamo in un campo di input
 const activeEl = document.activeElement;
 if (activeEl && (activeEl.tagName === 'INPUT' || 
 activeEl.tagName === 'TEXTAREA' ||
 activeEl.tagName === 'SELECT')) {
 console.log('️ [VECTOR GLOBAL] Skip - siamo in un campo input');
 return;
 }
 
 if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
 e.preventDefault();
 e.stopPropagation();
 e.stopImmediatePropagation(); // Blocca anche altri listener sulla stessa fase
 
 console.log('⌨️ [GLOBALE CAPTURE] Freccia catturata:', e.key);
 
 const step = window.state.vectorStep || 5;
 const oldX = window.state.vectorCursor.x;
 const oldY = window.state.vectorCursor.y;
 
 if (e.key === 'ArrowUp') window.state.vectorCursor.y = Math.max(0, window.state.vectorCursor.y - step);
 if (e.key === 'ArrowDown') window.state.vectorCursor.y = Math.min(window.canvas?.height || 1080, window.state.vectorCursor.y + step);
 if (e.key === 'ArrowLeft') window.state.vectorCursor.x = Math.max(0, window.state.vectorCursor.x - step);
 if (e.key === 'ArrowRight') window.state.vectorCursor.x = Math.min(window.canvas?.width || 1080, window.state.vectorCursor.x + step);
 
 console.log(`️ [GLOBALE] Cursore: (${oldX}, ${oldY}) → (${window.state.vectorCursor.x}, ${window.state.vectorCursor.y})`);
 
 if (window.scheduleRender) window.scheduleRender();
 if (window.announceGemini) window.announceGemini(`Cursore a X: ${Math.round(window.state.vectorCursor.x)}, Y: ${Math.round(window.state.vectorCursor.y)}`, 'polite');
 
 } else if (e.key === 'Enter') {
 e.preventDefault();
 e.stopPropagation();
 e.stopImmediatePropagation();
 console.log('↵ [GLOBALE] Enter premuto - aggiungo punto');
 if (window.addVectorPoint) window.addVectorPoint();
 
 } else if (e.key.toLowerCase() === 'c') {
 e.preventDefault();
 e.stopPropagation();
 e.stopImmediatePropagation();
 console.log(' [GLOBALE] C premuto - chiudo forma');
 if (window.closeVectorShape) window.closeVectorShape();
 }
 }, true); // CAPTURE MODE - esegue PRIMA di tutto!
 
 console.log(' Listener globale vettoriale registrato con capture mode');
 </script>
 
 <!-- MODALE AIUTO F2 -->
 <div id="help-modal" role="dialog" aria-modal="true" aria-labelledby="help-title" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 10000; justify-content: center; align-items: center;">
 <div role="document" style="background: var(--bg-main); border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto; box-shadow: 0 8px 32px rgba(0,0,0,0.3);">
 <div style="padding: 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center;">
 <h2 id="help-title" style="margin: 0; color: var(--text-primary); font-size: 18px;">Aiuto</h2>
 <button id="help-close-btn" style="background: none; border: none; font-size: 24px; cursor: pointer; color: var(--text-secondary); padding: 0; width: 32px; height: 32px;">×</button>
 </div>
 <div style="padding: 24px;"><div id="help-content" role="region" aria-live="polite" style="color: var(--text-primary); line-height: 1.6;">
 <h3>Soft LUT / Color Lookup</h3>
 <p><strong>Cos'è:</strong> Applica una "Look-Up Table" per rimappare i colori dell'immagine secondo curve tonali predefinite, simile ai preset di color grading cinematografici.</p>
 <p><strong>Come funziona:</strong> Ogni preset modifica i canali RGB secondo curve specifiche:<br>
 - <strong>Cinematic:</strong> Aumenta leggermente rossi, neutro verdi, riduce blu per look film<br>
 - <strong>Warm:</strong> Aumenta rossi e riduce blu per atmosfera calda<br>
 - <strong>Cool:</strong> Riduce rossi e aumenta blu per atmosfera fredda<br>
 - <strong>Vintage:</strong> Aggiunge toni caldi e desatura per look retrò</p>
 <p><strong>Parametri:</strong><br>
 - <strong>Preset:</strong> Scelta del tipo di LUT (warm/cool/vintage/cinematic)<br>
 - <strong>Intensity (0-100):</strong> Forza dell'effetto, 0=originale, 100=effetto completo</p>
 <p><strong>Quando usarlo:</strong> Per dare un look professionale e coerente alle immagini, creare mood specifici, simulare pellicole cinematografiche.</p>
 <p><strong>Consiglio:</strong> Parti da intensity 50 e regola, combina con altri effetti colore per risultati unici.</p>
 
 <h3>Posterize</h3>
 <p><strong>Cos'è:</strong> Riduce il numero di livelli di colore per canale, creando un effetto poster/cartoon con fasce di colore nette e ben definite.</p>
 <p><strong>Come funziona:</strong> Invece di avere 256 livelli per canale (16 milioni colori totali), riduce a N livelli (es. 8 livelli = 512 colori totali). I pixel vengono "quantizzati" ai livelli più vicini, creando transizioni nette invece che sfumate.</p>
 <p><strong>Parametri:</strong><br>
 - <strong>Livelli (2-32):</strong> Numero di livelli per canale RGB<br>
 · 2-4: Effetto grafico estremo, pochi colori<br>
 · 6-8: Look poster/cartoon bilanciato<br>
 · 12-16: Leggera semplificazione colori<br>
 · 24-32: Effetto sottile, quasi impercettibile</p>
 <p><strong>Quando usarlo:</strong> Per creare grafiche poster, effetti cartoon/fumetto, arte pop, semplificare immagini complesse, look grafico/minimale.</p>
 <p><strong>Consiglio:</strong> 8 livelli è un ottimo punto di partenza. Combina con contrasto alto e saturazione per look più forte.</p>
 
 <h3>Invert Colors</h3>
 <p><strong>Cos'è:</strong> Inverte i valori di colore dell'immagine, creando un negativo fotografico. Può essere applicato a tutti i canali o selettivamente.</p>
 <p><strong>Come funziona:</strong> Per ogni pixel, calcola il complemento: nuovo_valore = 255 - vecchio_valore. Questo trasforma il bianco in nero, il rosso in cyan, ecc. L'inversione selettiva permette effetti creativi specifici.</p>
 <p><strong>Parametri:</strong><br>
 - <strong>Inverti Rosso/Verde/Blu:</strong> Checkbox per scegliere quali canali invertire<br>
 - <strong>Preset:</strong><br>
 · Full (RGB): Negativo completo, classico effetto pellicola<br>
 · Cyan (GB): Inverte solo verde+blu, mantiene rossi originali<br>
 · Magenta (RB): Inverte rosso+blu, mantiene verdi<br>
 · Yellow (RG): Inverte rosso+verde, mantiene blu</p>
 <p><strong>Quando usarlo:</strong> Per creare negativi fotografici, effetti artistici surreali, correzioni colore creative, highlight/shadow swap, effetti psichedelici.</p>
 <p><strong>Consiglio:</strong> L'inversione selettiva (un solo canale o due) crea effetti più interessanti del negativo full. Sperimenta con combinazioni inaspettate!</p>
 
 <h3>Dehaze / Defog</h3>
 <p><strong>Cos'è:</strong> Rimuove foschia, nebbia e caligine da foto atmosferiche ripristinando contrasto, profondità e saturazione persi. Algoritmo avanzato che analizza e corregge la perdita di contrasto tipica delle immagini con foschia atmosferica.</p>
 <p><strong>Come funziona:</strong> Identifica le aree affette da foschia analizzando la perdita di contrasto locale, poi aumenta selettivamente il contrasto nelle zone nebbiose senza sovraesporre le luci. Recupera anche la saturazione colore persa nell'atmosfera diffusa.</p>
 <p><strong>Parametri:</strong><br>
 - <strong>Intensità Rimozione (0-100):</strong> Quanto rimuovere la foschia<br>
 · 0-30: Pulizia leggera, atmosfera ancora presente<br>
 · 31-60: Rimozione moderata, bilanciata (uso generale)<br>
 · 61-85: Forte, cielo e distanze molto più nitidi<br>
 · 86-100: Massima, elimina quasi tutta la foschia<br>
 - <strong>Recupero Saturazione (0-100):</strong> Quanto ripristinare i colori persi<br>
 · 0-20: Conservativo, look naturale<br>
 · 21-40: Bilanciato, colori ripristinati senza esagerare<br>
 · 41-70: Vivace, colori pop (stile Instagram)<br>
 · 71-100: Estremo, ipersaturazione artistica</p>
 <p><strong>Quando usarlo:</strong> Foto di paesaggi nebbiosi/con foschia, montagne con caligine, foto marittime, viste urbane con smog, foto scattate in condizioni atmosferiche non ottimali, recupero foto "flat" senza contrasto.</p>
 <p><strong>Consiglio:</strong> Parti con Intensity 50 e Saturation 30, poi regola. Combina con Clarity (+40) per risultati spettacolari su paesaggi. Non esagerare su ritratti (enfatizza troppo texture pelle).</p>
 <p><strong>Preset Consigliati:</strong><br>
 - Paesaggio Leggero: Int 40, Sat 25<br>
 - Paesaggio Drammatico: Int 70, Sat 45<br>
 - Montagna/Mare: Int 65, Sat 35<br>
 - Urban Smog: Int 55, Sat 20</p>
 
 <h3>Bloom Soft</h3>
 <p><strong>Cos'è:</strong> Versione morbida e delicata del Bloom base. Crea bagliori diffusi ed eterei sulle aree luminose dell'immagine, perfetto per ritratti sognanti, atmosfere magiche e fotografia fashion/beauty senza essere troppo aggressivo.</p>
 <p><strong>Come funziona:</strong> Identifica i pixel sopra una certa luminosità (threshold), poi diffonde la loro luce con sfocatura gaussiana multi-pass per creare alone morbido e naturale. A differenza del Bloom standard che è intenso, Bloom Soft usa radius più ampio e intensity più bassa per effetto delicato.</p>
 <p><strong>Parametri:</strong><br>
 - <strong>Soglia Luminosità (0-100):</strong> Quanto luminose devono essere le aree per brillare<br>
 · 0-40: Include anche mezzitoni (bloom diffuso ovunque)<br>
 · 41-70: Solo aree abbastanza luminose (bilanciato)<br>
 · 71-90: Solo highlights forti (selettivo)<br>
 · 91-100: Solo luci specular/riflessi (minimalista)<br>
 - <strong>Intensità Bagliore (1-50):</strong> Quanto è forte l'effetto glow<br>
 · 1-10: Subtle, appena percettibile (natural beauty)<br>
 · 11-20: Moderato, sognante ma credibile<br>
 · 21-35: Forte, effetto fairy tale evidente<br>
 · 36-50: Estremo, ethereal/fantasy<br>
 - <strong>Raggio Diffusione (2-20px):</strong> Quanto si espande il bagliore<br>
 · 2-5: Glow stretto, halo sottile<br>
 · 6-10: Medio, bloom morbido classico<br>
 · 11-15: Ampio, atmosfera avvolgente<br>
 · 16-20: Molto ampio, effetto dream/soft focus</p>
 <p><strong>Quando usarlo:</strong> Ritratti beauty/fashion (skin glow), fotografia matrimonio/romantica, atmosfere magiche/fatate, scene notturne con luci (lanterne, candele), fotografia product luxury, effetto golden hour potenziato.</p>
 <p><strong>Consiglio:</strong> Per ritratti naturali: Threshold 75, Intensity 12, Radius 8. Per effetto sogno intenso: Threshold 65, Intensity 25, Radius 12. Evita su foto già molto luminose (washout).</p>
 <p><strong>Differenza Bloom vs Bloom Soft:</strong><br>
 - <strong>Bloom base:</strong> Aggressivo, contrasto alto, luci che "esplodono" (stile videogiochi/HDR)<br>
 - <strong>Bloom Soft:</strong> Delicato, diffuso, naturale, luci che "respirano" (stile fotografia fine art)<br>
 Bloom Soft ha threshold di default più alto (70 vs 50) e radius più ampio (8 vs 3) per look più sottile.</p>
 <p><strong>Preset Rapidi:</strong><br>
 - Ritratto Beauty: Thr 75, Int 12, Rad 8<br>
 - Wedding Dreamy: Thr 70, Int 18, Rad 10<br>
 - Fantasy Ethereal: Thr 65, Int 28, Rad 14<br>
 - Product Luxury: Thr 80, Int 10, Rad 6<br>
 - Golden Hour Boost: Thr 60, Int 15, Rad 9</p>
</div></div>
 <div style="padding: 16px 24px; border-top: 1px solid var(--border-color); text-align: center; color: var(--text-secondary); font-size: 13px;">
 Premi Escape per chiudere
 </div>
 </div>
 </div>
 

<!-- Live regions NVDA (invisibili, preservano layout esistente) -->


<script>
(function(){
 const qs=(s,r=document)=>r.querySelector(s);
 const speak=(m,{assertive=false}={})=>{
 const node = assertive ? qs('#sr-assert') : qs('#sr-polite');
 if(!node) return;
 node.textContent='';
 setTimeout(()=>{ node.textContent=m; }, 30);
 };

 // Alt+A preview toggle (image-only)
 function togglePreview(){
 document.body.classList.toggle('preview');
 }

 const pBtn = qs('#previewBtn, #btn-preview, #preview_button');
 if(pBtn){ pBtn.addEventListener('click', togglePreview); }

 // Annunci dopo "Aggiungi Testo"
 const addBtn = qs('#btn-add-text, #addText, button[data-action="add-text"]');
 const canvas = qs('#canvas');
 const Editor = window.editor || window.Editor || window.APP?.editor || null;
 if(addBtn){
 addBtn.addEventListener('click', ()=>{
 setTimeout(()=>{
 try{
 if(canvas && canvas.focus) canvas.focus();
 const i = Editor && Editor.selected != null ? Editor.selected : null;
 if(i != null){
 const L = Editor.layers[i];
 const lines = ((L.text||'').match(/\n/g)||[]).length + 1;
 speak(`Testo aggiunto. ${lines} righe. Posizione ${Math.round(L.x)}, ${Math.round(L.y)}.`);
 } else {
 speak('Testo aggiunto.');
 }
 }catch(err){
 console.warn('Announce text add failed:', err);
 }
 }, 80);
 });
 }

 // Annunci dopo allineamento
 ['#btn-align-left','#btn-align-right','#btn-align-hcenter','#btn-align-top','#btn-align-bottom','#btn-align-vcenter',
 '#alLeft','#alRight','#alHc','#alTop','#alBottom','#alVc'].forEach(sel=>{
 const b = qs(sel);
 if(!b) return;
 b.addEventListener('click', ()=>{
 setTimeout(()=>{
 try{
 if(canvas && canvas.focus) canvas.focus();
 const i = Editor && Editor.selected != null ? Editor.selected : null;
 if(i == null) return;
 const L = Editor.layers[i];
 speak(`Allineato. Posizione ${Math.round(L.x)}, ${Math.round(L.y)}.`);
 }catch(err){
 console.warn('Announce alignment failed:', err);
 }
 }, 50);
 });
 });

 // Annunci dopo "Applica" proprietà
 const applyBtn = qs('#btn-apply-props, #applyProps, button[data-action="apply-props"]');
 if(applyBtn){
 applyBtn.addEventListener('click', ()=>{
 setTimeout(()=>{
 try{
 if(canvas && canvas.focus) canvas.focus();
 const i = Editor && Editor.selected != null ? Editor.selected : null;
 if(i == null) return;
 const L = Editor.layers[i];
 speak(`Proprietà applicate. Posizione ${Math.round(L.x)}, ${Math.round(L.y)}. Dimensioni ${Math.round(L.w)} per ${Math.round(L.h)}.`);
 }catch(err){
 console.warn('Announce apply props failed:', err);
 }
 }, 60);
 });
 }

 // Esplorazione canvas: Ctrl+E per attivare, frecce=1px, Shift=10px, Ctrl=50px
 state.exploreMode=false; // Resa globale per coordinamento con altri patch
 let cur={x:100,y:100};
 function announceUnder(){
 try{
 const liveRegion = document.getElementById('sr-polite') || document.getElementById('sr-assert');
 if(!liveRegion) return;
 
 const hit = (Editor && typeof Editor.hit==='function') ? Editor.hit(cur.x, cur.y) : null;
 let message = '';
 
 if(hit!=null){
 const L = Editor.layers[hit];
 const lines = L && L.text ? (((L.text.match(/\n/g))||[]).length+1) : null;
 message = `Cursore ${Math.round(cur.x)}, ${Math.round(cur.y)}. Elemento: ${L.name || L.type}${lines?`, ${lines} righe`:''}.`;
 } else {
 message = `Cursore ${Math.round(cur.x)}, ${Math.round(cur.y)}. Vuoto.`;
 }
 
 liveRegion.textContent = '';
 setTimeout(() => { liveRegion.textContent = message; }, 50);
 }catch(err){
 console.warn('Announce explore position failed:', err);
 }
 }
 function toggleExplore(){
 state.exploreMode=!state.exploreMode;
 
 // Dai focus al canvas o al body quando attivi l'esplorazione
 if(state.exploreMode) {
 const canvas = document.getElementById('canvas');
 if(canvas && canvas.tabIndex >= 0) {
 canvas.focus();
 } else {
 // Se il canvas non è focusabile, dai focus al body
 document.body.focus();
 document.body.setAttribute('tabindex', '-1');
 }
 }
 
 // Usa direttamente le live regions (speak() potrebbe non essere ancora definita)
 const liveRegion = document.getElementById('sr-assert') || document.getElementById('sr-polite');
 if(liveRegion) {
 liveRegion.textContent = '';
 setTimeout(() => {
 liveRegion.textContent = state.exploreMode ? 
 'Esplorazione canvas attivata. Frecce per muoverti, T per testo, F per forme, I per immagine, Ctrl più E per disattivare.' : 
 'Esplorazione canvas disattivata.';
 }, 50);
 }
 if(state.exploreMode) {
 // Attendi un attimo prima di annunciare la posizione iniziale
 setTimeout(announceUnder, 300);
 }
 }
 document.addEventListener('keydown', (e)=>{
 // Ctrl+E per esplorazione (con capture: true per eseguire PRIMA di altri listener)
 if((e.ctrlKey || e.metaKey) && (e.key==='e'||e.key==='E')){ 
 e.preventDefault(); 
 toggleExplore();
 return; // IMPORTANTE: non continuare con la logica delle frecce!
 }
 
 if(!state.exploreMode) return;
 
 // PRIORITÀ: Se la modalità vettoriale è attiva, NON intercettare le frecce!
 if (window.state && window.state.vectorDrawMode) {
 console.log(' Modalità vettoriale attiva - esplorazione non cattura le frecce');
 return; // Lascia che il listener vettoriale gestisca le frecce
 }
 
 // CONTROLLA SUBITO: se siamo in un campo form, NON intercettare NESSUN tasto!
 const target = e.target;
 if (target && target.nodeType === 1) {
 const tag = target.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") {
 // Sei in un campo form - lascia che l'utente scriva normalmente
 return;
 }
 }
 
 // HOTKEY T = Aggiungi testo
 if(e.key.toLowerCase() === 't' && !e.ctrlKey && !e.altKey && !e.metaKey) {
 e.preventDefault();
 // Trova il textarea per il testo (ID corretto: text-input)
 const textarea = document.getElementById('text-input');
 if(textarea) {
 // Imposta le coordinate
 const xInput = document.getElementById('pos-x'); // Per testi che modificano posizione
 const yInput = document.getElementById('pos-y');
 if(xInput) xInput.value = cur.x;
 if(yInput) yInput.value = cur.y;
 
 // Dai focus al textarea per permettere la scrittura
 textarea.focus();
 textarea.select();
 
 const liveRegion = document.getElementById('sr-assert');
 if(liveRegion) {
 liveRegion.textContent = '';
 setTimeout(() => {
 liveRegion.textContent = `Modalità inserimento testo. Scrivi il testo e premi il pulsante Aggiungi testo. Posizione: X ${cur.x}, Y ${cur.y}.`;
 }, 50);
 }
 // Scorri alla sezione testo
 const textSection = document.querySelector('#text-section');
 if(textSection) {
 textSection.scrollIntoView({behavior: 'smooth', block: 'nearest'});
 }
 }
 return;
 }
 
 // HOTKEY F = Menu forme
 if(e.key.toLowerCase() === 'f' && !e.ctrlKey && !e.altKey && !e.metaKey) {
 e.preventDefault();
 // Imposta le coordinate per la forma
 const xInput = document.getElementById('new-shape-x');
 const yInput = document.getElementById('new-shape-y');
 if(xInput) xInput.value = cur.x;
 if(yInput) yInput.value = cur.y;
 
 // Trova il primo pulsante forma (rettangolo)
 const rectButton = document.getElementById('btn-add-rect');
 if(rectButton) {
 rectButton.focus();
 const liveRegion = document.getElementById('sr-assert');
 if(liveRegion) {
 liveRegion.textContent = '';
 setTimeout(() => {
 liveRegion.textContent = `Pulsanti forme. Usa Tab per navigare tra rettangolo, cerchio e triangolo. Posizione: X ${cur.x}, Y ${cur.y}.`;
 }, 50);
 }
 // Scorri alla sezione forme
 const shapesSection = document.querySelector('#shapes-section');
 if(shapesSection) {
 shapesSection.scrollIntoView({behavior: 'smooth', block: 'nearest'});
 }
 } else {
 const liveRegion = document.getElementById('sr-polite');
 if(liveRegion) {
 liveRegion.textContent = '';
 setTimeout(() => {
 liveRegion.textContent = 'Sezione forme non disponibile. Usa i controlli nella barra laterale.';
 }, 50);
 }
 }
 return;
 }
 
 // HOTKEY I = Aggiungi immagine
 if(e.key.toLowerCase() === 'i' && !e.ctrlKey && !e.altKey && !e.metaKey) {
 e.preventDefault();
 // Imposta le coordinate per l'immagine
 const xInput = document.getElementById('new-img-x');
 const yInput = document.getElementById('new-img-y');
 if(xInput) xInput.value = cur.x;
 if(yInput) yInput.value = cur.y;
 
 // Trova il pulsante per caricare l'immagine
 const imgButton = document.getElementById('upload-img');
 if(imgButton) {
 const liveRegion = document.getElementById('sr-assert');
 if(liveRegion) {
 liveRegion.textContent = '';
 setTimeout(() => {
 liveRegion.textContent = `Carica immagine. Usa il pulsante nella sezione Immagine per caricare un file. Posizione: X ${cur.x}, Y ${cur.y}.`;
 }, 50);
 }
 // Scorri alla sezione immagine
 const imgSection = document.querySelector('#image-section');
 if(imgSection) {
 imgSection.scrollIntoView({behavior: 'smooth', block: 'nearest'});
 }
 }
 return;
 }
 
 // SOLO ORA blocca le frecce (dopo aver verificato che non siamo su form field)
 if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) {
 e.preventDefault();
 const step = e.ctrlKey?50:(e.shiftKey?10:1);
 if(e.key==='ArrowLeft') cur.x = Math.max(0, cur.x - step);
 if(e.key==='ArrowRight') cur.x = Math.min((canvas?.width||2000)-1, cur.x + step);
 if(e.key==='ArrowUp') cur.y = Math.max(0, cur.y - step);
 if(e.key==='ArrowDown') cur.y = Math.min((canvas?.height||2000)-1, cur.y + step);
 announceUnder();
 }
 }, true); // CAPTURE MODE per eseguire prima di altri listener!

 // Riduci verbosità dei select (eccetto font)
 document.querySelectorAll('select').forEach(sel=>{
 if(sel.id !== 'font'){ sel.removeAttribute('aria-label'); }
 });

 // Rimuovi pulsante "Impostazioni avanzate sfondo" se il pannello non esiste
 const advBtn = qs('#btn-adv-background, button[data-panel="bg-advanced"]');
 const advPanel = qs('#bg-advanced, #background-advanced, .bg-advanced');
 if(advBtn && !advPanel){ advBtn.parentNode && advBtn.parentNode.removeChild(advBtn); }

 // Chiudi per default i pannelli "avanzati"
 document.querySelectorAll('details.advanced, details[data-advanced="true"]').forEach(d=>{ d.removeAttribute('open'); });

})();
</script>


<script>
// --- Shim per controlli colore livello (previene ReferenceError se variabili non inizializzate nello scope) ---
(function(){
 function ensure(id){
 var el = document.getElementById(id);
 return el;
 }
 function styleObj(){
 return { display: 'none' };
 }
 if(typeof window.layerColorPreset === 'undefined' || window.layerColorPreset === null){
 window.layerColorPreset = ensure('lc') || { value:'custom', addEventListener:function(){}, style:styleObj() };
 }
 if(typeof window.layerColorHex === 'undefined' || window.layerColorHex === null){
 window.layerColorHex = ensure('layer-color-hex') || { value:'#000000' };
 }
 if(typeof window.layerColorCustomSection === 'undefined' || window.layerColorCustomSection === null){
 window.layerColorCustomSection = ensure('layer-color-custom-section') || { style:styleObj() };
 }
 if(typeof window.layerColorPreview === 'undefined' || window.layerColorPreview === null){
 window.layerColorPreview = ensure('layer-color-preview') || { style:styleObj() };
 }
})();
</script>


<script>
// === Metriche testo selezionato ===
(function(){
 function speakWrap(msg){ 
 try{
 const node = document.getElementById('sr-polite') || document.getElementById('sr-assert');
 if(node){ node.textContent=''; setTimeout(()=>{ node.textContent=msg; }, 30); }
 }catch(err){
 console.warn('speakWrap failed:', err);
 }
 }
 function getEditor(){
 return window.editor || window.Editor || (window.APP && window.APP.editor) || null;
 }
 window.readSelectedTextMetrics = function(){
 try{
 const Editor = getEditor();
 const i = Editor && Editor.selected != null ? Editor.selected : null;
 if(i == null){ speakWrap('Nessun livello selezionato'); return; }
 const L = Editor.layers[i];
 if(!L || L.type !== 'text'){ speakWrap('Il livello selezionato non è testo'); return; }
 const lines = ((L.text||'').match(/\n/g)||[]).length + 1;
 const lh = (L.lineHeight || 1.25);
 const heightPx = Math.round((L.fontSize||0) * lh * lines);
 const widthPx = Math.round(L.width || L.w || 0);
 const boxH = Math.round(L.height || L.h || heightPx);
 speakWrap(`Testo: ${lines} righe. Box ${widthPx} per ${boxH} pixel. Altezza stimata ${heightPx} pixel.`);
 }catch(err){console.warn("Silent catch:",err);}
 };

 // Scorciatoia: Alt+L per leggere le metriche del testo
 document.addEventListener('keydown', (e)=>{
 if(e.altKey && (e.key==='l' || e.key==='L')){ e.preventDefault(); window.readSelectedTextMetrics(); }
 });
})();
</script>


<script>
// === Patch ACCESSIBILITÀ – Annunci estesi NVDA (fixed5) ===
(function(){
 function srSpeak(msg, assertive){
 try{
 const node = document.getElementById(assertive? 'sr-assert' : 'sr-polite') || document.getElementById('sr-polite') || document.getElementById('sr-assert');
 if(!node) return;
 node.textContent='';
 setTimeout(()=>{ node.textContent=msg; }, 20);
 }catch(err){
 console.warn('srSpeak failed:', err);
 }
 }
 function getEditor(){
 return window.editor || window.Editor || (window.APP && window.APP.editor) || null;
 }
 function linesCount(text){ return ((text||'').match(/\n/g)||[]).length + 1; }
 function describeLayer(L){
 if(!L) return 'nessun livello';
 let base = (L.name || L.type || 'livello');
 let extra = ` ${Math.round(L.width||L.w||0)}×${Math.round(L.height||L.h||0)} px, pos ${Math.round(L.x||0)}, ${Math.round(L.y||0)}`;
 if(L.type==='text'){
 const n = linesCount(L.text);
 return `${base}, testo, ${n} righe,${extra}`;
 }
 if(L.type==='image') return `${base}, immagine,${extra}`;
 if(L.type==='shape') return `${base}, forma,${extra}`;
 if(L.type==='path') return `${base}, tracciato,${extra}`;
 return `${base},${extra}`;
 }

 // --- Annuncio quando selezioni un livello (patcha Editor.select se presente) ---
 function patchSelect(){
 const E = getEditor();
 if(!E || typeof E.select !== 'function' || E.__a11y_patched_select) return;
 const orig = E.select.bind(E);
 E.select = function(i){
 const r = orig(i);
 try{
 const L = (E.selected!=null)? E.layers[E.selected] : null;
 if(L){ srSpeak('Selezionato ' + describeLayer(L)); }
 }catch(err){console.warn("Silent catch:",err);}
 return r;
 };
 E.__a11y_patched_select = true;
 }

 // --- Annuncio durante trascinamento con il mouse (soglia 10px e throttle) ---
 (function(){
 const canvas = document.getElementById('canvas');
 if(!canvas) return;
 let down=false, lastAnn = {x:null,y:null,t:0};
 canvas.addEventListener('mousedown', ()=>{ down=true; lastAnn={x:null,y:null,t:0}; }, true);
 window.addEventListener('mouseup', ()=>{ down=false; }, true);
 canvas.addEventListener('mousemove', ()=>{
 if(!down) return;
 const E=getEditor(); if(!E || E.selected==null) return;
 const L=E.layers[E.selected]; if(!L) return;
 const now=Date.now();
 const dx = (lastAnn.x==null)? 999 : Math.abs(L.x - lastAnn.x);
 const dy = (lastAnn.y==null)? 999 : Math.abs(L.y - lastAnn.y);
 if((dx>=10 || dy>=10) && now - lastAnn.t >= 250){
 srSpeak(`Posizione ${Math.round(L.x)}, ${Math.round(L.y)}`);
 lastAnn = {x:L.x, y:L.y, t:now};
 }
 }, true);
 })();

 // --- Annunci per cambi "sfondo": qualunque controllo con id/name che contenga bg/background/sfondo ---
 (function(){
 function labelFor(el){
 try{
 const id = el.getAttribute('id');
 if(id){
 const lab = document.querySelector(`label[for="${id}"]`);
 if(lab) return lab.textContent.trim();
 }
 return el.getAttribute('aria-label') || el.name || el.id || 'impostazione';
 }catch(_){ return 'impostazione'; }
 }
 function onChangeSpeak(e){
 const el = e.target;
 if(!el) return;
 const id = (el.id||''); const name=(el.name||''); const lab = labelFor(el);
 if(/(bg|background|sfondo)/i.test(lab) || /(bg|background|sfondo)/i.test(id) || /(bg|background|sfondo)/i.test(name)){
 let val = (el.value || '').toString().trim();
 if(el.type==='color' && val){ srSpeak(`${lab} impostato a ${val}`); return; }
 if(val) srSpeak(`${lab}: ${val}`);
 else srSpeak(`${lab} aggiornato`);
 }
 }
 document.addEventListener('change', onChangeSpeak, true);
 document.addEventListener('input', (e)=>{
 if(e.target && e.target.type==='color') onChangeSpeak(e);
 }, true);
 })();

 // --- Annunci per controlli stile di livello: font, peso, colore, opacità, bordo/riempimento/spessore ---
 (function(){
 const rx = /(font|tipo di carattere|peso|weight|colore|color|opacity|opacità|stroke|bordo|fill|riempimento|spessore|thickness|line-height)/i;
 function onChangeStyle(e){
 const el=e.target; if(!el) return;
 const id=(el.id||''); const name=(el.name||''); 
 const labEl = (id? document.querySelector(`label[for="${id}"]`): null);
 const lab=(labEl && labEl.textContent) || el.getAttribute('aria-label') || id || name;
 if(rx.test(lab) || rx.test(id) || rx.test(name)){
 let v = (el.value||'').toString().trim();
 if(el.type==='color' && v) srSpeak(`${lab} ${v}`);
 else if(v) srSpeak(`${lab} ${v}`);
 else srSpeak(`${lab} aggiornato`);
 }
 }
 document.addEventListener('change', onChangeStyle, true);
 })();

 // --- Penna / Tracciato: annuncia numero punti all'uscita del drag ---
 (function(){
 let beforeLen=0;
 function len(){ try{ const E=getEditor(); return (E&&E.layers)? E.layers.length : 0; }catch(_){ return 0; } }
 beforeLen = len();
 window.addEventListener('mousedown', ()=>{ beforeLen = len(); }, true);
 window.addEventListener('mouseup', ()=>{
 try{
 const E=getEditor(); if(!E||!E.layers) return;
 const after = E.layers.length;
 if(after >= beforeLen+1){
 const L = E.layers[after-1];
 if(L && L.type==='path'){
 const n = (L.points && L.points.length) ? L.points.length : 0;
 srSpeak(`Tracciato creato con ${n} punti`);
 }
 }
 }catch(err){console.warn("Silent catch:",err);}
 }, true);
 })();

 // Ritenta la patch di select finché Editor non esiste
 let tries=0;
 const t = setInterval(()=>{
 tries++;
 try{ patchSelect(); }catch(err){console.warn("Silent catch:",err);}
 const E=getEditor();
 if((E && E.__a11y_patched_select) || tries>40){ clearInterval(t); }
 }, 150);
})();
</script>

<script>
// === Guard-rails di stabilità (fixed6) ===
(function(){
 function srSpeak(msg){
 try{
 const n = document.getElementById('sr-assert') || document.getElementById('sr-polite');
 if(!n) return;
 n.textContent='';
 setTimeout(()=>{ n.textContent = `[Errore] ${msg}`; }, 10);
 }catch(err){console.warn("Silent catch:",err);}
 }
 // Global error + unhandledrejection
 window.addEventListener('error', function(e){
 try{
 console.error('[Guard]', e.message, e.error);
 srSpeak(e.message || 'Errore sconosciuto');
 }catch(err){console.warn("Silent catch:",err);}
 }, true);
 window.addEventListener('unhandledrejection', function(e){
 try{
 console.error('[Guard][Promise]', e.reason);
 srSpeak((e && e.reason && (e.reason.message || e.reason)) || 'Errore asincrono');
 }catch(err){console.warn("Silent catch:",err);}
 }, true);

 // Wrapper sicuro per callback addEventListener (opt-in)
 window.safeOn = function(target, type, handler, opts){
 const safe = function(ev){
 try{ handler.call(this, ev); }
 catch(err){
 console.error('[Guard][Listener]', type, err);
 srSpeak(err && err.message ? err.message : 'Errore handler');
 }
 };
 (target || window).addEventListener(type, safe, opts || false);
 return safe;
 };
})();
</script>

<script>
// === Verbosità Select: normalizza opzioni colore sfondo ===
(function(){
 function simplifyBgPresetSelect(sel){
 if(!sel) return;
 // Skip il select principale che ha già il testo corretto
 if(sel.id === 'bg-color') return;
 
 // Remove aria-label to avoid label repetition; rely on <label for="...">
 sel.removeAttribute('aria-label');
 var mapNames = {
 'transparent': 'Trasparente',
 '#000000': 'Nero',
 '#ff0000': 'Rosso',
 '#00ff00': 'Verde',
 '#0000ff': 'Blu'
 };
 for (var i=0;i<sel.options.length;i++){
 var opt = sel.options[i];
 var raw = (opt.textContent || '').trim();
 var val = (opt.value || '').trim();
 // Detect "bg-color-preset ..." prefix in text, strip it
 raw = raw.replace(/^bg[-_ ]?color[-_ ]?preset\s*/i,'').trim();
 // If text still contains a hex, prefer the friendly name
 var label = mapNames[raw.toLowerCase()] || mapNames[val.toLowerCase()] || raw;
 // If label looks like a hex, try to map it; otherwise keep label clean
 if(/^#?[0-9a-f]{6}$/i.test(label)){
 var hex = label.startsWith('#') ? label.toLowerCase() : ('#'+label).toLowerCase();
 label = mapNames[hex] || hex;
 }
 // If value is empty but text contains hex keywords like transparent/rosso etc., set value to known hex/transparent
 var v = val || raw.toLowerCase();
 if(v in mapNames){ /* keep */ }
 else if (v==='trasparente') { val='transparent'; }
 // Set final
 opt.textContent = label;
 // Keep the value as-is; if it's a name, that's OK (your code maps names to hex)
 }
 }

 function initBgPresets(){
 // target any select whose id/name/label mentions bg/background/sfondo + color/preset
 var selects = Array.from(document.querySelectorAll('select')).filter(function(s){
 // Skip bg-color principale
 if(s.id === 'bg-color') return false;
 
 var id=(s.id||''); var name=(s.name||'');
 var lbl = '';
 if(id){ var el = document.querySelector('label[for="'+id+'"]'); if(el) lbl = el.textContent || ''; }
 var key = (id+' '+name+' '+lbl).toLowerCase();
 return /(bg|background|sfondo)/.test(key) && /(colore|color|preset)/.test(key);
 });
 selects.forEach(simplifyBgPresetSelect);

 // Add small color swatch (aria-hidden) next to each such select for sighted users
 selects.forEach(function(sel){
 if(sel.nextElementSibling && sel.nextElementSibling.classList && sel.nextElementSibling.classList.contains('swatch')) return;
 var span = document.createElement('span');
 span.className = 'swatch';
 span.setAttribute('aria-hidden','true');
 span.style.display='inline-block';
 span.style.width='12px'; span.style.height='12px'; span.style.marginLeft='6px';
 span.style.border='1px solid rgba(255,255,255,.35)';
 function setSwatch(){
 var v = (sel.value||'').toLowerCase();
 if(v==='transparent' || v==='trasparente'){ span.style.background='transparent'; span.style.backgroundImage='linear-gradient(45deg,#999 25%, transparent 25%, transparent 50%, #999 50%, #999 75%, transparent 75%, transparent)'; span.style.backgroundSize='8px 8px'; }
 else { span.style.background = v; span.style.backgroundImage=''; }
 }
 sel.addEventListener('change', setSwatch);
 setSwatch();
 sel.parentNode.insertBefore(span, sel.nextSibling);
 });
 }
 if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', initBgPresets);
 else initBgPresets();
})();
</script>

<script>
// === Pulizia generale caselle combinate (select) per ridurre verbosità NVDA ===
(function(){
 function getLabel(el){
 try{
 const id = el.getAttribute('id');
 if(id){
 const lab = document.querySelector('label[for="'+id+'"]');
 if(lab) return (lab.textContent||'').trim();
 }
 return (el.getAttribute('aria-label')||'').trim();
 }catch(_){ return ''; }
 }
 function cleanOptionText(txt, label){
 let t = (txt||'').trim();
 // rimuovi "label: ..." all'inizio
 if(label && t.toLowerCase().startsWith(label.toLowerCase())){
 t = t.slice(label.length).trim().replace(/^[:\-\s]+/,'').trim();
 }
 // rimuovi prefissi tecnici
 t = t.replace(/^bg[-_ ]?color[-_ ]?preset\s*/i,'')
 .replace(/^layer[-_ ]?/i,'')
 .replace(/\b(preset|value)\b[:\s-]*/ig,'')
 .trim();
 // se rimane un hex visibile, toglilo dal testo visualizzato (lo teniamo in value)
 if(/^#?[0-9a-f]{6}$/i.test(t)){
 // lascia il testo invariato solo se non c'è alternativa leggibile; in genere qui torniamo stringa vuota
 t = t.toUpperCase(); // ma meglio tentare mapping sotto
 }
 // mapping di colori comuni
 const map = {
 'transparent':'Trasparente',
 '#000000':'Nero','#000':'Nero',
 '#ffffff':'Bianco','#fff':'Bianco',
 '#ff0000':'Rosso','#00ff00':'Verde','#0000ff':'Blu',
 '#ffff00':'Giallo','#ff00ff':'Magenta','#00ffff':'Ciano'
 };
 const key = t.toLowerCase();
 if(map[key]) t = map[key];
 // rimuovi doppie spaziature
 t = t.replace(/\s+/g,' ').trim();
 // fallback se resta vuoto
 if(!t) t = 'Seleziona';
 return t;
 }

 function processSelect(sel){
 if(!sel) return;
 const id = sel.id||'';
 const name = sel.name||'';
 const label = getLabel(sel);
 const key = (id+' '+name+' '+label).toLowerCase();
 // Non toccare i font
 if(/\bfont\b/.test(key)) { sel.removeAttribute('aria-label'); return; }
 // Rimuovi aria-label per evitare ripetizioni del nome
 sel.removeAttribute('aria-label');
 // Pulisci le opzioni
 for(let i=0;i<sel.options.length;i++){
 const opt = sel.options[i];
 const original = opt.textContent || '';
 let cleaned = cleanOptionText(original, label);
 // se l'opzione è proprio la ripetizione del label (es. "Colore sfondo"), salta
 if(cleaned.toLowerCase() === (label||'').toLowerCase()) continue;
 opt.textContent = cleaned;
 }
 }

 function initSelectCleanup(){
 const selects = Array.from(document.querySelectorAll('select'));
 selects.forEach(processSelect);
 }
 if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', initSelectCleanup);
 else initSelectCleanup();
})();
</script>









<script>
// === Normalizzazione globale Select (combobox) – anti-verbosità & anti-inglese ===
(function(){
 function getLabelFor(el){
 try{
 const id = el.getAttribute('id');
 if(id){
 const lab = document.querySelector('label[for="'+id+'"]');
 if(lab) return (lab.textContent||'').trim();
 }
 return (el.getAttribute('aria-label')||'').trim();
 }catch(_){ return ''; }
 }
 function itMap(val){
 const s = (val||'').toString().trim().toLowerCase();
 const dict = {
 'transparent':'Trasparente','trasparente':'Trasparente',
 'color':'Colore solido','solid':'Colore solido',
 'gradient':'Gradiente','gradiente':'Gradiente',
 'image':'Immagine','foto':'Immagine','img':'Immagine',
 'left':'Sinistra','right':'Destra','center':'Centro','middle':'Centro','top':'Alto','bottom':'Basso',
 'bold':'Grassetto','normal':'Normale','italic':'Corsivo',
 'none':'Nessuno','auto':'Automatico'
 };
 return dict[s] || null;
 }
 function simplifyText(txt, label){
 let t = (txt||'').trim();
 // rimuovi "Label: ..." all'inizio
 if(label && t.toLowerCase().startsWith(label.toLowerCase())){
 t = t.slice(label.length).trim().replace(/^[:\-\s]+/,'').trim();
 }
 // rimuovi prefissi tecnici e parole chiave rumorose
 t = t.replace(/^bg[-_ ]?type[:\s-]*/i,'')
 .replace(/^bg[-_ ]?color[-_ ]?preset[:\s-]*/i,'')
 .replace(/^layer[-_ ]?/i,'')
 .replace(/\b(preset|value|type|id)\b[:\s-]*/ig,'')
 .replace(/\s+/g,' ').trim();
 // se è puro hex, cerco di mappare o lascio invariato nel value (qui solo testo pulito)
 if(/^#?[0-9a-f]{6}$/i.test(t)) return t.toUpperCase();
 return t;
 }
 function cleanSelect(sel){
 const id=(sel.id||''); const name=(sel.name||'');
 const label = getLabelFor(sel);
 const key = (id+' '+name+' '+label).toLowerCase();
 // Escludi font family (elenco caratteri)
 if(/\bfont\b/.test(key) && /family|famiglia/.test(key)) return;
 sel.setAttribute('lang','it');
 // Evita doppie letture
 sel.removeAttribute('aria-label');
 sel.removeAttribute('aria-describedby');
 sel.removeAttribute('title');
 // Pulisci ogni opzione
 for(let i=0;i<sel.options.length;i++){
 const opt = sel.options[i];
 const rawText = (opt.textContent||opt.label||'').trim();
 const rawVal = (opt.value||'').trim();
 let labelText = simplifyText(rawText, label);
 // mappa valori canonici in italiano, se possibile
 const prettyFromVal = itMap(rawVal);
 const prettyFromText = itMap(rawText);
 if(prettyFromVal) labelText = prettyFromVal;
 else if(prettyFromText) labelText = prettyFromText;
 // Forza testo/label puliti (ma NON altero value, per non rompere logica)
 while(opt.firstChild) opt.removeChild(opt.firstChild);
 opt.appendChild(document.createTextNode(labelText || 'Seleziona'));
 try{ opt.label = labelText; }catch(err){console.warn("Silent catch:",err);}
 try{ opt.text = labelText; }catch(err){console.warn("Silent catch:",err);}
 opt.setAttribute('lang','it');
 opt.removeAttribute('aria-label');
 opt.removeAttribute('aria-describedby');
 opt.removeAttribute('title');
 }
 }
 function run(){
 const selects = Array.from(document.querySelectorAll('select'));
 selects.forEach(cleanSelect);
 }
 run();
 if(document.readyState==='loading') document.addEventListener('DOMContentLoaded', run);
 // retry per UI dinamiche
 setTimeout(run, 200);
 setTimeout(run, 800);
 setTimeout(run, 1600);
})();
</script>

<script>
/**
 * Patch v30-fix16
 * - Annunci disattivati finché non c'è interazione utente (evita spam all'avvio)
 * - Annuncio unico e debounced su change effettivo
 * - De-duplica e normalizza etichette IT su tutte le <select>
 * - Definisce updateLayerColorPreview() (no-op sicuro) per prevenire ReferenceError
 */
(function () {
 // --------- Guard per funzione mancante ---------
 if (typeof window.updateLayerColorPreview !== "function") {
 window.updateLayerColorPreview = function () {
 // opzionale: se esiste un'anteprima colore, potremmo aggiornarla qui
 // lasciamo no-op per evitare errori senza alterare logiche esistenti
 };
 }

 // --------- Live region ---------
 let polite = document.getElementById("sr-polite");
 if (!polite) {
 polite = document.createElement("div");
 polite.id = "sr-polite";
 polite.className = "sr-only";
 polite.setAttribute("role", "status");
 polite.setAttribute("aria-live", "polite");
 polite.setAttribute("aria-atomic", "true");
 document.body.prepend(polite);
 }

 // Annunci solo dopo interazione reale dell'utente
 let userInteracted = false;
 const flagInteract = () => { userInteracted = true; };
 window.addEventListener("pointerdown", flagInteract, { once: true, capture: true });
 window.addEventListener("keydown", flagInteract, { once: true, capture: true });
 window.addEventListener("focusin", flagInteract, { once: true, capture: true });

 const itMap = new Map(Object.entries({
 "solid": "Colore Solido",
 "color": "Colore Solido",
 "colore solido": "Colore Solido",
 "gradient": "Gradiente",
 "gradiente": "Gradiente",
 "image": "Immagine",
 "immagine": "Immagine",
 "cover": "Copri tutto (taglia se necessario)",
 "contain": "Contenuto (mostra tutto)",
 "stretch": "Allunga",
 "tile": "Ripeti (pattern)",
 "linear": "Lineare",
 "radial": "Radiale",
 "left": "Sinistra",
 "center": "Centro",
 "right": "Destra",
 "solid line": "Solida",
 "dashed": "Tratteggiata",
 "dotted": "Puntinata",
 }));

 function norm(text) {
 const key = String(text || "").trim().toLowerCase();
 return itMap.get(key) || text;
 }

 function titleCase(s) {
 return String(s || "").replace(/\S+/g, w => w[0].toUpperCase() + w.slice(1).toLowerCase());
 }

 function ensureAriaLabel(select) {
 // Lista di select che NON devono avere aria-label (usano label nativi per NVDA)
 const silentIds = [
 "tpl", "bg-type", "c", "tc", "lc", "vfc", "vsc", "sc", "shc",
 "nff", "ff", "nfw", "fw",
 "blend-mode", "filter-preset", "sharpen-preset", "noise-type",
 "denoise-preset", "gradmap-preset", "curves-preset", "clarity-preset",
 "mask-shape", "bg-gradient-type", "bg-image-fit",
 "gradient-type",
 "crop-preset", "mask-shape-2", "new-shape-fill", "new-shape-stroke",
 "new-line-style"
 ];
 
 // Se questa select è nella lista silenziosa, non aggiungere aria-label
 if (silentIds.includes(select.id)) return;
 
 if (select.getAttribute("aria-label")) return;
 let labelText = "";
 const id = select.id;
 if (id) {
 const lab = document.querySelector(`label[for="${id}"]`);
 if (lab && lab.textContent.trim()) labelText = lab.textContent.trim();
 }
 if (!labelText) {
 const group = select.closest(".control-group");
 if (group) {
 const h = group.querySelector(".control-group-title");
 if (h && h.textContent.trim()) labelText = h.textContent.trim();
 }
 }
 if (!labelText && select.id === "bg-type") labelText = "Tipo sfondo";
 if (!labelText) labelText = "Selezione";
 select.setAttribute("aria-label", labelText);
 }

 function dedupeAndNormalize(select) {
 const seen = new Set();
 const opts = Array.from(select.options);
 for (const opt of opts) {
 const t = norm(opt.textContent);
 if (t !== opt.textContent) opt.textContent = t;
 const key = (opt.value ?? "") + "||" + (opt.textContent || "").trim().toLowerCase();
 if (seen.has(key)) {
 opt.remove();
 } else {
 seen.add(key);
 }
 }
 }

 const timers = new WeakMap();
 let lastMsg = "";

 function announceSelect(select) {
 if (!userInteracted) return; // silenzioso finché l'utente non interagisce
 const label = select.getAttribute("aria-label") || "Selezione";
 const opt = select.options[select.selectedIndex];
 const txt = opt ? (opt.text || opt.textContent || "") : "";
 if (!txt || txt === "null" || txt === "undefined") return;
 const msg = `${titleCase(label)} impostato su ${txt}`;
 if (msg === lastMsg) return;
 lastMsg = msg;
 polite.textContent = "";
 clearTimeout(timers.get(select));
 const t = setTimeout(() => { polite.textContent = msg; }, 120);
 timers.set(select, t);
 }

 function wireSelect(select) {
 // Skip completo per select colori e font - nessun processing
 const skipIds = ['c', 'tc', 'lc', 'vfc', 'vsc', 'sc', 'shc', 'nff', 'ff', 'nfw', 'fw', 'bg-type'];
 if (skipIds.includes(select.id)) return;
 
 ensureAriaLabel(select);
 dedupeAndNormalize(select);
 // imposta prevText iniziale per evitare announce al primo 'change' programmatico
 const current = select.options[select.selectedIndex]?.text || "";
 select.dataset.prevText = current;

 const onChange = () => {
 const now = select.options[select.selectedIndex]?.text || "";
 const prev = select.dataset.prevText || "";
 if (now !== prev) {
 select.dataset.prevText = now;
 // DISABLED: announce(select); // Causes duplicate announcements with NVDA
 }
 };
 // rimuovi handler precedente se presente
 if (select.__fix16_onChange) select.removeEventListener("change", select.__fix16_onChange);
 select.addEventListener("change", onChange);
 select.__fix16_onChange = onChange;
 }

 function patchAll() {
 document.querySelectorAll("select").forEach(wireSelect);
 }

 if (document.readyState === "loading") {
 document.addEventListener("DOMContentLoaded", patchAll);
 } else {
 patchAll();
 }

 const obs = new MutationObserver(() => patchAll());
 obs.observe(document.body, { childList: true, subtree: true });
})();
</script>


<script>
/**
 * Patch v30-fix17 (Ctrl+Frecce = 50px, Shift+Frecce = 10px)
 * - Vector: quando il riquadro vettoriale è a fuoco, nudge con step moltiplicato
 * - Posizione controlli (nuovi elementi): aggiorna X/Y visibili per Testo/Forme/Immagini
 */
(function(){
 function isVisible(el){
 if (!el) return false;
 // Controlla l'elemento stesso
 const s = window.getComputedStyle(el);
 if (s.display === "none" || s.visibility === "hidden") return false;
 
 // Controlla i parent fino al body
 let parent = el.parentElement;
 while (parent && parent !== document.body) {
 const ps = window.getComputedStyle(parent);
 if (ps.display === "none" || ps.visibility === "hidden") return false;
 parent = parent.parentElement;
 }
 
 return true;
 }

 function getVectorFocus(){
 const focus = document.getElementById("vector-focus-area");
 return focus && (document.activeElement === focus || focus.contains(document.activeElement)) ? focus : null;
 }

 function getVectorStep(base=1, e){
 // Slider ufficiale se presente
 const slider = document.getElementById("vector-step");
 let step = base;
 if (slider && isVisible(slider)) {
 const v = parseInt(slider.value, 10);
 if (!isNaN(v)) step = v;
 }
 if (e && e.ctrlKey) step *= 10; // Ctrl = x10 (es. 5 -> 50)
 else if (e && e.shiftKey) step *= 2; // Shift = x2 (es. 5 -> 10)
 return step;
 }

 // vectorNudge verrà definito correttamente più avanti nel codice
 // (rimosso placeholder che causava conflitti)

 function nudgeVector(e, key){
 const focus = getVectorFocus();
 if (!focus) return false;
 const step = getVectorStep(1, e);
 let dx = 0, dy = 0;
 if (key === "ArrowLeft") dx = -step;
 if (key === "ArrowRight") dx = step;
 if (key === "ArrowUp") dy = -step;
 if (key === "ArrowDown") dy = step;
 if (dx === 0 && dy === 0) return false;
 e.preventDefault();
 window.vectorNudge(dx, dy);
 // Annuncio opzionale
 const polite = document.getElementById("sr-polite");
 if (polite) polite.textContent = `Cursore vettoriale spostato di ${dx || 0} in X, ${dy || 0} in Y`;
 return true;
 }

 function findXYInputs(){
 const pairs = [
 ["new-text-x", "new-text-y"],
 ["new-shape-x", "new-shape-y"],
 ["new-img-x", "new-img-y"],
 ["new-text-X", "new-text-Y"],
 ["pos-x", "pos-y"],
 ];
 for (const [idx, idy] of pairs){
 const x = document.getElementById(idx);
 const y = document.getElementById(idy);
 if (x && y && isVisible(x) && isVisible(y)) return {x,y};
 }
 // Fallback heuristico: cerca in un gruppo con titolo "Posizione"
 const groups = Array.from(document.querySelectorAll(".control-group"));
 for (const g of groups){
 const h = g.querySelector(".control-group-title");
 if (h && /posizione/i.test(h.textContent || "") && isVisible(g)){
 const inputs = g.querySelectorAll('input[type="number"]');
 if (inputs.length >= 2) return { x: inputs[0], y: inputs[1] };
 }
 }
 return null;
 }

 function getStepForXY(e){
 if (e && e.ctrlKey) return 50;
 if (e && e.shiftKey) return 10;
 return 1;
 }

 function nudgeXY(e, key){
 // Se il lock è attivo, non permettere modifiche a X/Y
 if (document.body.dataset.xyLock === "1") return false;
 
 const pair = findXYInputs();
 if (!pair) return false;
 const {x, y} = pair;
 
 // IMPORTANTE: Modifica X/Y SOLO se uno di questi input ha effettivamente il focus
 const activeEl = document.activeElement;
 if (activeEl !== x && activeEl !== y) return false;
 
 const step = getStepForXY(e);
 let handled = false;
 if (key === "ArrowLeft"){
 x.value = (parseInt(x.value || "0", 10) - step);
 handled = true;
 }
 if (key === "ArrowRight"){
 x.value = (parseInt(x.value || "0", 10) + step);
 handled = true;
 }
 if (key === "ArrowUp"){
 y.value = (parseInt(y.value || "0", 10) - step);
 handled = true;
 }
 if (key === "ArrowDown"){
 y.value = (parseInt(y.value || "0", 10) + step);
 handled = true;
 }
 if (handled){
 e.preventDefault();
 // Trigger change/input per aggiornare il canvas se l'app ascolta
 x.dispatchEvent(new Event("input", { bubbles: true }));
 x.dispatchEvent(new Event("change", { bubbles: true }));
 y.dispatchEvent(new Event("input", { bubbles: true }));
 y.dispatchEvent(new Event("change", { bubbles: true }));
 
 // Annuncia SOLO se non è un aggiornamento programmatico
 if (!window._updatingProgrammatically) {
 const polite = document.getElementById("sr-polite");
 if (polite) polite.textContent = `Posizione aggiornata: X ${x.value}, Y ${y.value}`;
 }
 }
 return handled;
 }

 // Listener nudgeVector - DISABILITATO per evitare conflitti con le select
 // Se vuoi usare il nudge vettoriale, dovrai attivarlo manualmente nel codice
 /*
 window.addEventListener("keydown", function(e){
 const k = e.key;
 if (k !== "ArrowLeft" && k !== "ArrowRight" && k !== "ArrowUp" && k !== "ArrowDown") return;
 
 // NON intercettare MAI se l'evento proviene da un campo form
 const target = e.target;
 if (target && target.nodeType === 1) {
 const tag = target.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return;
 const role = (target.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return;
 }
 
 // Prova solo vettoriale - nudgeXY è disabilitato perché causa problemi
 // quando i campi X/Y sono visibili ma non in uso attivo
 if (nudgeVector(e, k)) return;
 // nudgeXY rimosso - gli utenti devono cliccare sui campi per modificarli
 }, false);
 */
})();
</script>

<style>
/* Canvas Explorer cursor */
#canvas-explorer-cursor {
 position: absolute;
 width: 12px;
 height: 12px;
 margin-left: -6px; /* center on point */
 margin-top: -6px;
 border: 2px solid #222;
 border-radius: 50%;
 background: rgba(255,255,255,0.6);
 box-shadow: 0 0 0 1px #fff, 0 0 6px rgba(0,0,0,0.4);
 pointer-events: none;
 z-index: 9997;
 display: none;
}
#canvas-explorer-hint {
 position: absolute;
 font: 12px/1.2 -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial;
 padding: 6px 8px;
 background: rgba(0,0,0,0.75);
 color: #fff;
 border-radius: 6px;
 box-shadow: 0 2px 10px rgba(0,0,0,0.35);
 pointer-events: none;
 z-index: 9997;
 display: none;
}

 /* ═══════════════════════════════════════════════════════════════════════
 SISTEMA F2 HELP - MODAL PER SPIEGAZIONI EFFETTI GPU
 ═══════════════════════════════════════════════════════════════════════ */
 
 #help-modal {
 display: none;
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0, 0, 0, 0.85);
 z-index: 10000;
 justify-content: center;
 align-items: center;
 backdrop-filter: blur(5px);
 }
 
 #help-modal.active {
 display: flex;
 }
 
 .help-content {
 background: var(--bg-secondary);
 border: 2px solid var(--accent);
 border-radius: 12px;
 padding: 30px;
 max-width: 700px;
 max-height: 80vh;
 overflow-y: auto;
 box-shadow: 0 10px 40px rgba(78, 204, 163, 0.3);
 animation: slideIn 0.3s ease-out;
 }
 
 @keyframes slideIn {
 from {
 opacity: 0;
 transform: translateY(-30px) scale(0.95);
 }
 to {
 opacity: 1;
 transform: translateY(0) scale(1);
 }
 }
 
 .help-content h2 {
 color: var(--accent);
 margin-bottom: 20px;
 font-size: 24px;
 border-bottom: 2px solid var(--accent);
 padding-bottom: 10px;
 }
 
 .help-content h3 {
 color: var(--text-primary);
 margin-top: 25px;
 margin-bottom: 12px;
 font-size: 18px;
 display: flex;
 align-items: center;
 gap: 10px;
 }
 
 .help-content h3 .gpu-badge {
 font-size: 11px;
 padding: 3px 8px;
 }
 
 .help-content p {
 color: var(--text-secondary);
 line-height: 1.6;
 margin-bottom: 15px;
 }
 
 .help-content ul {
 color: var(--text-secondary);
 margin-left: 20px;
 margin-bottom: 15px;
 line-height: 1.8;
 }
 
 .help-content li {
 margin-bottom: 8px;
 }
 
 .help-content code {
 background: rgba(78, 204, 163, 0.15);
 color: var(--accent);
 padding: 2px 6px;
 border-radius: 4px;
 font-family: 'Courier New', monospace;
 font-size: 13px;
 }
 
 .help-content .help-close-btn {
 background: var(--danger);
 color: white;
 border: none;
 padding: 10px 25px;
 border-radius: 6px;
 cursor: pointer;
 font-size: 14px;
 font-weight: bold;
 margin-top: 20px;
 transition: all 0.2s;
 display: block;
 margin-left: auto;
 margin-right: auto;
 }
 
 .help-content .help-close-btn:hover {
 background: var(--danger-hover);
 transform: translateY(-2px);
 box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
 }
 
 .help-content .help-close-btn:focus {
 outline: 2px solid var(--accent);
 outline-offset: 2px;
 }
 
 /* Scrollbar per help modal */
 .help-content::-webkit-scrollbar {
 width: 8px;
 }
 
 .help-content::-webkit-scrollbar-track {
 background: var(--bg-tertiary);
 border-radius: 4px;
 }
 
 .help-content::-webkit-scrollbar-thumb {
 background: var(--accent);
 border-radius: 4px;
 }
 
 .help-content::-webkit-scrollbar-thumb:hover {
 background: var(--accent-hover);
 }
 </style>
<script>
/**
 * Patch v30-fix18 — Canvas Explorer
 * Attiva/Disattiva con Ctrl+E. Esplora il canvas da tastiera senza spostare gli oggetti.
 * Frecce: muovi di 1px — Shift: 10px — Ctrl: 50px.
 * Annuncia: coordinate (X,Y) e colore sotto al cursore (#RRGGBB).
 */
(function(){
 const polite = document.getElementById("sr-polite") || (function(){
 const d = document.createElement("div");
 d.id = "sr-polite"; d.className="sr-only";
 d.setAttribute("role","status"); d.setAttribute("aria-live","polite"); d.setAttribute("aria-atomic","true");
 document.body.prepend(d); return d;
 })();

 // Trova contenitore canvas per posizionare il cursore
 const canvas = document.getElementById("canvas");
 const container = document.querySelector(".canvas-container") || canvas?.parentElement || document.body;
 if (!canvas) return; // niente da fare se non esiste

 // Cursore e hint
 const cursor = document.createElement("div");
 cursor.id = "canvas-explorer-cursor";
 cursor.setAttribute("aria-hidden", "true"); // Impedisci a NVDA di leggere il cursore
 const hint = document.createElement("div");
 hint.id = "canvas-explorer-hint";
 hint.setAttribute("aria-hidden", "true"); // FONDAMENTALE: impedisci a NVDA di leggere hint
 hint.textContent = ""; // Vuoto all'inizio - verrà riempito quando attivato
 container.appendChild(cursor);
 container.appendChild(hint);

 let explorerOn = false;
 let pos = { x: Math.floor(canvas.width/2)||0, y: Math.floor(canvas.height/2)||0 };

 function setVisible(el, v){ el.style.display = v ? "block" : "none"; }

 function canvasOffset(){
 const rect = canvas.getBoundingClientRect();
 const crect = container.getBoundingClientRect();
 return { left: rect.left - crect.left + container.scrollLeft, top: rect.top - crect.top + container.scrollTop };
 }

 function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }

 function toHex(c){
 const s = c.toString(16).padStart(2,'0').toUpperCase();
 return s;
 }

 function sampleColor(x, y){
 try {
 const ctx = canvas.getContext("2d");
 const data = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
 return `#${toHex(data[0])}${toHex(data[1])}${toHex(data[2])}`;
 } catch (e) { return null; }
 }

 function updateCursor(){
 if (!explorerOn) return; // NON aggiornare se l'explorer è spento
 const off = canvasOffset();
 cursor.style.left = (off.left + pos.x) + "px";
 cursor.style.top = (off.top + pos.y) + "px";
 hint.style.left = (off.left + pos.x + 14) + "px";
 hint.style.top = (off.top + pos.y + 14) + "px";
 const hex = sampleColor(pos.x, pos.y);
 hint.textContent = `X ${pos.x}, Y ${pos.y}${hex ? " — Colore " + hex : ""}`;
 }

 // Debounce per gli annunci - riduce la verbosità durante lo scorrimento
 let announceTimer = null;
 function announceExplorerColor(){
 // Cancella l'annuncio precedente
 if (announceTimer) clearTimeout(announceTimer);
 // Annuncia solo dopo 400ms di inattività E solo se l'explorer è ancora attivo
 announceTimer = setTimeout(() => {
 if (!explorerOn) return; // NON annunciare se l'explorer è stato disattivato
 const hex = sampleColor(pos.x, pos.y);
 polite.textContent = `Canvas Explorer: X ${pos.x}, Y ${pos.y}${hex ? ", colore " + hex : ""}`;
 }, 400);
 }

 function stepForEvent(e){
 if (e.ctrlKey) return 50;
 if (e.shiftKey) return 10;
 return 1;
 }

 function toggleExplorer(on){
 const wasActive = explorerOn; // Salva lo stato precedente
 explorerOn = (on === undefined ? !explorerOn : !!on);
 setVisible(cursor, explorerOn);
 setVisible(hint, explorerOn);
 if (explorerOn){
 // centra se fuori
 pos.x = clamp(pos.x, 0, Math.max(0, canvas.width-1));
 pos.y = clamp(pos.y, 0, Math.max(0, canvas.height-1));
 updateCursor();
 // Annuncio immediato all'attivazione
 const hex = sampleColor(pos.x, pos.y);
 polite.textContent = `Canvas Explorer attivato. X ${pos.x}, Y ${pos.y}${hex ? ", colore " + hex : ""}`;
 } else {
 // Cancella eventuali timer pendenti
 if (announceTimer) clearTimeout(announceTimer);
 // CANCELLA il contenuto di hint per impedire a NVDA di leggerlo
 hint.textContent = "";
 // Mostra il messaggio solo se era effettivamente attivo prima
 if (wasActive) {
 polite.textContent = "Canvas Explorer disattivato";
 }
 }
 }

 // DISABILITATO: Questo interferisce con il sistema di esplorazione principale (riga 8486)
 // Shortcut: Ctrl+E per attivare/disattivare
 // window.addEventListener("keydown", function(e){
 // if (e.key.toLowerCase() === "e" && e.ctrlKey){
 // e.preventDefault();
 // toggleExplorer();
 // }
 // }, true);

 // Movimento con frecce quando attivo
 window.addEventListener("keydown", function(e){
 if (!explorerOn) return;
 // Controlla il marker impostato da fix31
 if (e.__fromFormField) return;
 // Non intercettare se l'evento proviene da un campo form
 const target = e.target;
 if (target && target.nodeType === 1) {
 const tag = target.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return;
 const role = (target.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return;
 }
 const k = e.key;
 if (k !== "ArrowLeft" && k !== "ArrowRight" && k !== "ArrowUp" && k !== "ArrowDown") return;
 e.preventDefault();
 const step = stepForEvent(e);
 if (k === "ArrowLeft") pos.x -= step;
 if (k === "ArrowRight") pos.x += step;
 if (k === "ArrowUp") pos.y -= step;
 if (k === "ArrowDown") pos.y += step;
 pos.x = clamp(pos.x, 0, Math.max(0, canvas.width-1));
 pos.y = clamp(pos.y, 0, Math.max(0, canvas.height-1));
 updateCursor();
 announceExplorerColor();
 // scrolla container se serve per tenere il cursore in vista
 const r = cursor.getBoundingClientRect();
 const cr = container.getBoundingClientRect();
 if (r.right > cr.right) container.scrollLeft += (r.right - cr.right) + 20;
 if (r.left < cr.left) container.scrollLeft -= (cr.left - r.left) + 20;
 if (r.bottom > cr.bottom) container.scrollTop += (r.bottom - cr.bottom) + 20;
 if (r.top < cr.top) container.scrollTop -= (cr.top - r.top) + 20;
 }, false); // Usa bubbling phase

 // Riesegui posizionamento su resize
 window.addEventListener("resize", function(){ if (explorerOn) updateCursor(); }, { passive: true });

 // API globale opzionale
 window.toggleCanvasExplorer = toggleExplorer;
})();
</script>

<script>
/**
 * Patch v30-fix19 — Canvas Explorer: annuncia l'elemento sotto al cursore
 * - Sostituisce/integra l'explorer: Ctrl+E per attivare/disattivare
 * - Frecce: 1px • Shift: 10px • Ctrl: 50px
 * - Annuncia: coordinate, colore e, se rilevabile, nome/tipo del livello sotto al punto
 * - Hit-test flessibile su possibili strutture 'layers' dell'app (rettangoli, cerchi, linee, poligoni)
 */
(function(){
 const polite = document.getElementById("sr-polite") || (function(){
 const d = document.createElement("div");
 d.id = "sr-polite"; d.className="sr-only";
 d.setAttribute("role","status"); d.setAttribute("aria-live","polite"); d.setAttribute("aria-atomic","true");
 document.body.prepend(d); return d;
 })();

 const canvas = document.getElementById("canvas");
 const container = document.querySelector(".canvas-container") || canvas?.parentElement || document.body;
 if (!canvas) return;

 // Riusa eventuale cursore/hint esistenti
 let cursor = document.getElementById("canvas-explorer-cursor");
 if (!cursor){
 cursor = document.createElement("div");
 cursor.id = "canvas-explorer-cursor";
 cursor.style.position = "absolute";
 cursor.style.width = "12px";
 cursor.style.height = "12px";
 cursor.style.marginLeft = "-6px";
 cursor.style.marginTop = "-6px";
 cursor.style.border = "2px solid #222";
 cursor.style.borderRadius = "50%";
 cursor.style.background = "rgba(255,255,255,0.6)";
 cursor.style.boxShadow = "0 0 0 1px #fff, 0 0 6px rgba(0,0,0,0.4)";
 cursor.style.pointerEvents = "none";
 cursor.style.zIndex = "9997";
 cursor.style.display = "none";
 container.appendChild(cursor);
 }
 let hint = document.getElementById("canvas-explorer-hint");
 if (!hint){
 hint = document.createElement("div");
 hint.id = "canvas-explorer-hint";
 hint.setAttribute("aria-hidden", "true"); // FONDAMENTALE: impedisci a NVDA di leggere hint
 hint.style.position = "absolute";
 hint.style.font = "12px/1.2 -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial";
 hint.style.padding = "6px 8px";
 hint.style.background = "rgba(0,0,0,0.75)";
 hint.style.color = "#fff";
 hint.style.borderRadius = "6px";
 hint.style.boxShadow = "0 2px 10px rgba(0,0,0,0.35)";
 hint.style.pointerEvents = "none";
 hint.style.zIndex = "9997";
 hint.style.display = "none";
 container.appendChild(hint);
 } else {
 // Assicurati che aria-hidden sia impostato anche se l'elemento esisteva già
 hint.setAttribute("aria-hidden", "true");
 }

 let explorerOn = false;
 let pos = { x: Math.floor(canvas.width/2)||0, y: Math.floor(canvas.height/2)||0 };

 function setVisible(el, v){ el.style.display = v ? "block" : "none"; }

 function canvasOffset(){
 const rect = canvas.getBoundingClientRect();
 const crect = container.getBoundingClientRect();
 return { left: rect.left - crect.left + container.scrollLeft, top: rect.top - crect.top + container.scrollTop };
 }
 function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
 function toHex(c){ return c.toString(16).padStart(2,'0').toUpperCase(); }
 function sampleColor(x, y){
 try {
 const ctx = canvas.getContext("2d");
 const d = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
 return `#${toHex(d[0])}${toHex(d[1])}${toHex(d[2])}`;
 } catch(e){ return null; }
 }
 function updateCursor(){
 if (!explorerOn) return; // NON aggiornare se l'explorer è spento
 const off = canvasOffset();
 cursor.style.left = (off.left + pos.x) + "px";
 cursor.style.top = (off.top + pos.y) + "px";
 hint.style.left = (off.left + pos.x + 14) + "px";
 hint.style.top = (off.top + pos.y + 14) + "px";
 }

 // ---------- HIT TEST ----------
 // Trova un array plausibile di livelli
 function findLayersArray(){
 const cands = [];
 for (const k in window){
 try {
 const v = window[k];
 if (Array.isArray(v) && v.length){
 const a = v;
 // element plausibile se oggetto con qualche posizione/dimensione o type
 const el = a[a.length-1];
 if (el && typeof el === "object"){
 const keys = Object.keys(el);
 const hasGeom = ("x" in el && "y" in el) || ("left" in el && "top" in el);
 const hasSize = ("width" in el || "w" in el) || ("height" in el || "h" in el) || ("radius" in el || "r" in el);
 const hasType = ("type" in el) || ("kind" in el) || ("layerType" in el);
 if (hasGeom && (hasSize || hasType)) {
 // evita enormi array generici
 if (a.length < 1000) cands.push({ key:k, arr:a });
 }
 }
 }
 } catch(e){}
 }
 // preferisci 'layers' nominali
 const named = cands.find(c => /layers|livelli|objects|items/i.test(c.key));
 return (named || cands[0] || null);
 }

 function getNumber(v, altKeys=[], def=0){
 if (typeof v === "number") return v;
 for (const k of altKeys){
 if (typeof v?.[k] === "number") return v[k];
 }
 return def;
 }

 function containsPoint(obj, x, y){
 // standard rect
 const ox = getNumber(obj.x, ["left"]);
 const oy = getNumber(obj.y, ["top"]);
 const ow = getNumber(obj.width, ["w"]);
 const oh = getNumber(obj.height, ["h"]);
 const typ = (obj.type || obj.kind || obj.layerType || "").toString().toLowerCase();

 if ((ow || oh) && !/circle|cerchio/.test(typ)){
 return x >= ox && y >= oy && x <= ox + ow && y <= oy + oh;
 }
 // circle
 if (/circle|cerchio/.test(typ) || ("radius" in obj || "r" in obj)){
 const r = getNumber(obj.radius, ["r"], 0);
 const cx = ("cx" in obj) ? obj.cx : ox + r;
 const cy = ("cy" in obj) ? obj.cy : oy + r;
 const dx = x - cx, dy = y - cy;
 return dx*dx + dy*dy <= r*r;
 }
 // line (thickness approx)
 if (/line|linea/.test(typ) && "x1" in obj && "y1" in obj && "x2" in obj && "y2" in obj){
 const {x1,y1,x2,y2} = obj;
 const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
 const dot = A*C + B*D;
 const len_sq = C*C + D*D;
 let param = -1;
 if (len_sq !== 0) param = dot / len_sq;
 let xx, yy;
 if (param < 0) { xx = x1; yy = y1; }
 else if (param > 1) { xx = x2; yy = y2; }
 else { xx = x1 + param*C; yy = y1 + param*D; }
 const dx = x - xx, dy = y - yy;
 const dist = Math.sqrt(dx*dx + dy*dy);
 const thick = getNumber(obj.strokeWidth, ["thickness","lineWidth"], 3);
 return dist <= Math.max(2, thick/2 + 2);
 }
 // polygon path points
 if (Array.isArray(obj.points) && obj.points.length >= 3){
 return pointInPolygon(x, y, obj.points);
 }
 return false;
 }

 function pointInPolygon(x, y, pts){
 let inside = false;
 for (let i=0, j=pts.length-1; i<pts.length; j=i++){
 const xi = pts[i].x ?? pts[i][0], yi = pts[i].y ?? pts[i][1];
 const xj = pts[j].x ?? pts[j][0], yj = pts[j].y ?? pts[j][1];
 const intersect = ((yi>y)!=(yj>y)) && (x < (xj - xi) * (y - yi) / ((yj - yi)||1e-9) + xi);
 if (intersect) inside = !inside;
 }
 return inside;
 }

 function describe(obj){
 const typ = (obj.type || obj.kind || obj.layerType || obj.shape || "livello").toString();
 const name = obj.name || obj.layerName || obj.id || "";
 let extra = "";
 if (typ.toLowerCase().includes("text") && typeof obj.text === "string"){
 const t = obj.text.trim();
 if (t) extra = `“${t.length>24 ? t.slice(0,24)+'…' : t}”`;
 }
 return [typ, name, extra].filter(Boolean).join(" ").trim();
 }

 function findTopMost(x, y){
 const hitSource = findLayersArray();
 if (!hitSource) return null;
 const arr = hitSource.arr;
 // supponi ultimo = sopra
 for (let i = arr.length - 1; i >= 0; i--){
 const o = arr[i];
 try {
 if (o && typeof o === "object" && containsPoint(o, x, y)) {
 return o;
 }
 } catch(e){}
 }
 return null;
 }

 function stepForEvent(e){
 if (e.ctrlKey) return 50;
 if (e.shiftKey) return 10;
 return 1;
 }

 // Debounce per gli annunci - riduce la verbosità durante lo scorrimento
 let announceTimer = null;
 function announceExplorerFull(){
 // Cancella l'annuncio precedente
 if (announceTimer) clearTimeout(announceTimer);
 // Annuncia solo dopo 400ms di inattività E solo se l'explorer è ancora attivo
 announceTimer = setTimeout(() => {
 if (!explorerOn) return; // NON annunciare se l'explorer è stato disattivato
 const hex = sampleColor(pos.x, pos.y);
 const obj = findTopMost(pos.x, pos.y);
 const desc = obj ? `, sotto: ${describe(obj)}` : "";
 polite.textContent = `Canvas Explorer: X ${pos.x}, Y ${pos.y}${hex ? ", colore "+hex : ""}${desc}`;
 hint.textContent = `X ${pos.x}, Y ${pos.y}${hex ? " — "+hex : ""}${obj ? " — " + describe(obj) : ""}`;
 }, 400);
 }

 function toggleExplorer(on){
 const wasActive = explorerOn; // Salva lo stato precedente
 explorerOn = (on === undefined ? !explorerOn : !!on);
 setVisible(cursor, explorerOn);
 setVisible(hint, explorerOn);
 if (explorerOn){
 pos.x = clamp(pos.x, 0, Math.max(0, canvas.width-1));
 pos.y = clamp(pos.y, 0, Math.max(0, canvas.height-1));
 updateCursor();
 // Annuncio immediato all'attivazione
 const hex = sampleColor(pos.x, pos.y);
 const obj = findTopMost(pos.x, pos.y);
 const desc = obj ? `, sotto: ${describe(obj)}` : "";
 polite.textContent = `Canvas Explorer attivato. X ${pos.x}, Y ${pos.y}${hex ? ", colore "+hex : ""}${desc}`;
 hint.textContent = `X ${pos.x}, Y ${pos.y}${hex ? " — "+hex : ""}${obj ? " — " + describe(obj) : ""}`;
 } else {
 // Cancella eventuali timer pendenti
 if (announceTimer) clearTimeout(announceTimer);
 // CANCELLA il contenuto di hint per impedire a NVDA di leggerlo
 hint.textContent = "";
 // Mostra il messaggio solo se era effettivamente attivo prima
 if (wasActive) {
 polite.textContent = "Canvas Explorer disattivato";
 }
 }
 }

 // Esporta API e sostituisci eventuale precedente
 window.toggleCanvasExplorer = toggleExplorer;

 // DISABILITATO: Questo interferisce con il sistema di esplorazione principale (riga 8486)
 // Shortcut: Ctrl+E
 // window.addEventListener("keydown", function(e){
 // if (e.key.toLowerCase() === "e" && e.ctrlKey){
 // e.preventDefault();
 // e.stopImmediatePropagation();
 // toggleExplorer();
 // }
 // }, true);

 // Movimento con frecce (cattura e blocca altri handler per evitare doppio movimento)
 window.addEventListener("keydown", function(e){
 if (!explorerOn) return;
 // Controlla il marker impostato da fix31
 if (e.__fromFormField) return;
 // Non intercettare se l'evento proviene da un campo form
 const target = e.target;
 if (target && target.nodeType === 1) {
 const tag = target.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return;
 const role = (target.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return;
 }
 const k = e.key;
 if (k !== "ArrowLeft" && k !== "ArrowRight" && k !== "ArrowUp" && k !== "ArrowDown") return;
 e.preventDefault();
 e.stopImmediatePropagation();
 const step = stepForEvent(e);
 if (k === "ArrowLeft") pos.x -= step;
 if (k === "ArrowRight") pos.x += step;
 if (k === "ArrowUp") pos.y -= step;
 if (k === "ArrowDown") pos.y += step;
 pos.x = clamp(pos.x, 0, Math.max(0, canvas.height-1));
 pos.y = clamp(pos.y, 0, Math.max(0, canvas.height-1));
 updateCursor();
 announceExplorerFull();
 // scroll intelligente
 const r = cursor.getBoundingClientRect();
 const cr = container.getBoundingClientRect();
 if (r.right > cr.right) container.scrollLeft += (r.right - cr.right) + 20;
 if (r.left < cr.left) container.scrollLeft -= (cr.left - r.left) + 20;
 if (r.bottom > cr.bottom) container.scrollTop += (r.bottom - cr.bottom) + 20;
 if (r.top < cr.top) container.scrollTop -= (cr.top - r.top) + 20;
 }, false); // Usa bubbling phase
})();
</script>

<script>
/**
 * Patch v30-fix20
 * - ESC chiude Canvas Explorer
 * - Disabilita Ctrl/Shift + Frecce al di fuori dell'Explorer (niente spostamenti globali)
 */
(function(){
 // Marca stato explorer (se definito dal patch precedente, riutilizzalo)
 if (typeof window.__canvasExplorerActive === "undefined") window.__canvasExplorerActive = false;
 // Wrap l'API se presente per aggiornare lo stato
 if (typeof window.toggleCanvasExplorer === "function") {
 const orig = window.toggleCanvasExplorer;
 window.toggleCanvasExplorer = function(on){
 const res = orig(on);
 // prova a dedurre stato dal cursore
 const c = document.getElementById("canvas-explorer-cursor");
 window.__canvasExplorerActive = !!(c && c.style.display !== "none");
 return res;
 };
 }

 // ESC → esci dall'Explorer
 window.addEventListener("keydown", function(e){
 if (e.key === "Escape" && window.__canvasExplorerActive) {
 e.preventDefault();
 try { window.toggleCanvasExplorer(false); } catch(_) {}
 const live = document.getElementById("sr-polite");
 if (live) live.textContent = "Canvas Explorer disattivato";
 }
 }, true);

 // Neutralizza le scorciatoie globali di spostamento (Ctrl/Shift + Frecce) quando l'Explorer NON è attivo
 window.addEventListener("keydown", function(e){
 const isArrow = e.key === "ArrowLeft" || e.key === "ArrowRight" || e.key === "ArrowUp" || e.key === "ArrowDown";
 if (!isArrow) return;
 if (window.__canvasExplorerActive) return; // in Explorer lascio passare
 // se premete Ctrl o Shift con frecce fuori dall'Explorer, blocchiamo per evitare nudge globali
 if (e.ctrlKey || e.shiftKey) {
 e.preventDefault();
 e.stopImmediatePropagation();
 }
 }, true);
})();
</script>

<script>
/**
 * Patch v30-fix21 — Hotkeys in Canvas Explorer
 * - Explorer attivo: 
 * - T = aggiungi Testo al punto (usa X/Y correnti)
 * - F = aggiungi Forma (Rettangolo) al punto
 * - I = seleziona immagine e la posiziona al punto quando caricata
 */
(function(){
 function setVal(id, v){
 const el = document.getElementById(id);
 if (!el) return;
 el.value = v;
 el.dispatchEvent(new Event("input", { bubbles: true }));
 el.dispatchEvent(new Event("change", { bubbles: true }));
 }
 function clickIf(id){
 const el = document.getElementById(id);
 if (el) el.click();
 return !!el;
 }
 function sr(msg){
 const live = document.getElementById("sr-polite");
 if (live) live.textContent = msg;
 }
 function getExplorerPos(){
 // Riutilizza lo stato tenuto dal patch explorer (fix18/19)
 // Deduce dalla posizione del cursore
 const c = document.getElementById("canvas-explorer-cursor");
 const canvas = document.getElementById("canvas");
 if (!c || !canvas) return null;
 // ricava X/Y dal testo dell'hint quando presente
 const hint = document.getElementById("canvas-explorer-hint");
 if (hint && hint.textContent) {
 const m = hint.textContent.match(/X\s+(\d+),\s*Y\s+(\d+)/i);
 if (m) return { x: parseInt(m[1],10), y: parseInt(m[2],10) };
 }
 // fallback: prova a calcolare dall'offset del cursore rispetto al canvas
 const crect = c.getBoundingClientRect();
 const rect = canvas.getBoundingClientRect();
 return { x: Math.round(crect.left - rect.left), y: Math.round(crect.top - rect.top) };
 }

 // Quando seleziono un'immagine, posizionala al punto corrente
 (function hookImageUpload(){
 const up = document.getElementById("image-upload");
 if (!up) return;
 if (up.__fix21_hooked) return;
 up.__fix21_hooked = true;
 up.addEventListener("change", () => {
 // aspetta un tick per consentire all'app di creare il layer
 setTimeout(() => {
 const p = getExplorerPos();
 if (!p) return;
 setVal("new-img-x", p.x);
 setVal("new-img-y", p.y);
 sr(`Immagine caricata. Posizionata a X ${p.x}, Y ${p.y}`);
 }, 50);
 });
 })();

 window.addEventListener("keydown", function(e){
 if (!window.__canvasExplorerActive) return;
 // ignora se digitazione in campo input/textarea
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 if (tag === "input" || tag === "textarea") return;

 const k = e.key.toLowerCase();
 if (k === "t") {
 e.preventDefault();
 const p = getExplorerPos(); if (!p) return;
 setVal("new-text-x", p.x);
 setVal("new-text-y", p.y);
 const textInput = document.getElementById("text-input");
 if (textInput && !textInput.value.trim()) textInput.value = "Nuovo testo";
 if (clickIf("btn-add-text")) {
 sr(`Testo aggiunto a X ${p.x}, Y ${p.y}`);
 }
 } else if (k === "f") {
 e.preventDefault();
 const p = getExplorerPos(); if (!p) return;
 setVal("new-shape-x", p.x);
 setVal("new-shape-y", p.y);
 if (clickIf("btn-add-rect")) {
 sr(`Rettangolo aggiunto a X ${p.x}, Y ${p.y}`);
 }
 } else if (k === "i") {
 e.preventDefault();
 const p = getExplorerPos(); if (!p) return;
 setVal("new-img-x", p.x);
 setVal("new-img-y", p.y);
 const ok = clickIf("image-upload");
 if (ok) sr(`Seleziona un file immagine. Verrà inserita a X ${p.x}, Y ${p.y}.`);
 }
 }, true);
})();
</script>

<script>
/**
 * Patch v30-fix22 — Scelta forma & Disegno vettoriale da Explorer
 * Explorer attivo:
 * - F → apre pannello FORM A (imposta X/Y correnti, focus su tipo forma). Non crea nulla.
 * - C → conferma (crea) usando il pulsante standard "Aggiungi forma", se presente.
 * - D → entra in modalità DISEGNO VETTORIALE (apre il tool di disegno). 
 * - ESC in disegno → annulla il disegno. ESC fuori dal disegno → esce dall'Explorer (già previsto in fix20).
 */
(function(){
 // Helpers
 function get(id){ return document.getElementById(id); }
 function sr(msg){
 const live = get("sr-polite");
 if (live) live.textContent = msg;
 }
 function setVal(id, v){
 const el = get(id);
 if (!el) return false;
 el.value = v;
 el.dispatchEvent(new Event("input", { bubbles: true }));
 el.dispatchEvent(new Event("change", { bubbles: true }));
 return true;
 }
 function tryClick(ids){
 for (const id of ids){
 const el = (typeof id === "string") ? get(id) : id;
 if (el && typeof el.click === "function"){
 el.click();
 return true;
 }
 }
 return false;
 }
 function tryCall(funcNames){
 for (const name of funcNames){
 const fn = window[name];
 if (typeof fn === "function"){ fn(); return true; }
 }
 return false;
 }
 function focusShapeType(){
 const candIds = ["shape-type", "new-shape-type", "shapeKind", "select-shape-type"];
 for (const id of candIds){
 const el = get(id);
 if (el){
 el.focus();
 return true;
 }
 }
 // fallback: cerca select nel gruppo con titolo "Forma"
 const groups = Array.from(document.querySelectorAll(".control-group"));
 for (const g of groups){
 const h = g.querySelector(".control-group-title");
 if (h && /forma/i.test(h.textContent || "")){
 const sel = g.querySelector("select");
 if (sel){ sel.focus(); return true; }
 }
 }
 return false;
 }

 function getExplorerPos(){
 const c = get("canvas-explorer-cursor");
 const canvas = get("canvas");
 const hint = get("canvas-explorer-hint");
 if (!c || !canvas) return null;
 if (hint && hint.textContent){
 const m = hint.textContent.match(/X\s+(\d+),\s*Y\s+(\d+)/i);
 if (m) return { x: parseInt(m[1],10), y: parseInt(m[2],10) };
 }
 const crect = c.getBoundingClientRect();
 const rect = canvas.getBoundingClientRect();
 return { x: Math.round(crect.left - rect.left), y: Math.round(crect.top - rect.top) };
 }

 // Stato disegno vettoriale
 if (typeof window.__vectorDrawingActive === "undefined") window.__vectorDrawingActive = false;

 function enterVectorDraw(){
 // prova: tasti/btn noti
 const clicked = tryClick(["btn-draw-vector", "btn-start-draw", "btn-draw", "toolbar-draw"]);
 const called = clicked ? true : tryCall(["startVectorDraw", "enterDrawMode", "beginDraw"]);
 window.__vectorDrawingActive = !!(clicked || called);
 if (window.__vectorDrawingActive){
 sr("Disegno vettoriale attivato. Esc per annullare, C per confermare.");
 // se esiste un'area focus vettoriale, sposta il focus
 const vf = get("vector-focus-area");
 if (vf) vf.focus();
 } else {
 sr("Impossibile attivare il disegno: nessun comando trovato.");
 }
 }

 function cancelVectorDraw(){
 const clicked = tryClick(["btn-cancel-draw", "btn-draw-cancel"]);
 const called = clicked ? true : tryCall(["cancelVectorDraw", "exitDrawMode", "abortDraw"]);
 if (clicked || called){
 window.__vectorDrawingActive = false;
 sr("Disegno vettoriale annullato.");
 return true;
 }
 return false;
 }

 function confirmVectorDraw(){
 const clicked = tryClick(["btn-commit-draw", "btn-apply-draw", "btn-draw-confirm"]);
 const called = clicked ? true : tryCall(["confirmVectorDraw", "finishDraw", "commitDraw"]);
 if (clicked || called){
 window.__vectorDrawingActive = false;
 sr("Forma vettoriale confermata.");
 return true;
 }
 return false;
 }

 // Hotkeys attive SOLO in Explorer
 window.addEventListener("keydown", function(e){
 if (!window.__canvasExplorerActive) return;

 // se sta scrivendo in input/textarea, ignora
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 if (tag === "input" || tag === "textarea") return;

 const k = e.key.toLowerCase();

 if (k === "f"){ // scegli forma
 e.preventDefault();
 const p = getExplorerPos(); if (!p) return;
 setVal("new-shape-x", p.x);
 setVal("new-shape-y", p.y);
 // prova ad aprire pannello forma se è collassato
 tryClick(["btn-open-shape-panel", "toggle-shape-panel"]);
 const focused = focusShapeType();
 sr(`Posizione forma impostata a X ${p.x}, Y ${p.y}. ${focused ? "Seleziona tipo forma e premi C per confermare." : "Premi C per confermare."}`);
 }
 else if (k === "d"){ // disegno vettoriale
 e.preventDefault();
 enterVectorDraw();
 }
 else if (k === "c"){ // conferma
 e.preventDefault();
 if (window.__vectorDrawingActive){
 if (!confirmVectorDraw()){
 // se non c'è disegno, prova come add-shape
 if (!tryClick(["btn-add-shape", "add-shape"])) {
 sr("Nessun comando di conferma trovato.");
 }
 }
 } else {
 if (!tryClick(["btn-add-shape", "add-shape"])) {
 sr("Nessun comando di conferma forma trovato.");
 } else {
 sr("Forma aggiunta.");
 }
 }
 }
 else if (k === "escape"){ // annulla disegno (Explorer exit già in fix20)
 if (window.__vectorDrawingActive){
 e.preventDefault();
 if (!cancelVectorDraw()){
 sr("Nessun comando di annullamento disegno trovato.");
 }
 }
 }
 }, true);
})();
</script>

<style>
/* Shape Quick Menu (Explorer) */
#shape-quickmenu {
 position: absolute;
 max-height: 260px;
 min-width: 220px;
 overflow: auto;
 background: #111;
 color: #fff;
 border: 2px solid #444;
 border-radius: 10px;
 box-shadow: 0 8px 18px rgba(0,0,0,0.45);
 padding: 6px;
 z-index: 10005;
}
#shape-quickmenu [role="option"] {
 padding: 6px 8px;
 border-radius: 8px;
 outline: none;
}
#shape-quickmenu [role="option"][aria-selected="true"],
#shape-quickmenu [role="option"].active {
 background: #2a2a2a;
}
#shape-quickmenu .hint {
 font-size: 12px;
 opacity: 0.8;
 padding: 4px 8px 2px;
}

 /* ═══════════════════════════════════════════════════════════════════════
 SISTEMA F2 HELP - MODAL PER SPIEGAZIONI EFFETTI GPU
 ═══════════════════════════════════════════════════════════════════════ */
 
 #help-modal {
 display: none;
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0, 0, 0, 0.85);
 z-index: 10000;
 justify-content: center;
 align-items: center;
 backdrop-filter: blur(5px);
 }
 
 #help-modal.active {
 display: flex;
 }
 
 .help-content {
 background: var(--bg-secondary);
 border: 2px solid var(--accent);
 border-radius: 12px;
 padding: 30px;
 max-width: 700px;
 max-height: 80vh;
 overflow-y: auto;
 box-shadow: 0 10px 40px rgba(78, 204, 163, 0.3);
 animation: slideIn 0.3s ease-out;
 }
 
 @keyframes slideIn {
 from {
 opacity: 0;
 transform: translateY(-30px) scale(0.95);
 }
 to {
 opacity: 1;
 transform: translateY(0) scale(1);
 }
 }
 
 .help-content h2 {
 color: var(--accent);
 margin-bottom: 20px;
 font-size: 24px;
 border-bottom: 2px solid var(--accent);
 padding-bottom: 10px;
 }
 
 .help-content h3 {
 color: var(--text-primary);
 margin-top: 25px;
 margin-bottom: 12px;
 font-size: 18px;
 display: flex;
 align-items: center;
 gap: 10px;
 }
 
 .help-content h3 .gpu-badge {
 font-size: 11px;
 padding: 3px 8px;
 }
 
 .help-content p {
 color: var(--text-secondary);
 line-height: 1.6;
 margin-bottom: 15px;
 }
 
 .help-content ul {
 color: var(--text-secondary);
 margin-left: 20px;
 margin-bottom: 15px;
 line-height: 1.8;
 }
 
 .help-content li {
 margin-bottom: 8px;
 }
 
 .help-content code {
 background: rgba(78, 204, 163, 0.15);
 color: var(--accent);
 padding: 2px 6px;
 border-radius: 4px;
 font-family: 'Courier New', monospace;
 font-size: 13px;
 }
 
 .help-content .help-close-btn {
 background: var(--danger);
 color: white;
 border: none;
 padding: 10px 25px;
 border-radius: 6px;
 cursor: pointer;
 font-size: 14px;
 font-weight: bold;
 margin-top: 20px;
 transition: all 0.2s;
 display: block;
 margin-left: auto;
 margin-right: auto;
 }
 
 .help-content .help-close-btn:hover {
 background: var(--danger-hover);
 transform: translateY(-2px);
 box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
 }
 
 .help-content .help-close-btn:focus {
 outline: 2px solid var(--accent);
 outline-offset: 2px;
 }
 
 /* Scrollbar per help modal */
 .help-content::-webkit-scrollbar {
 width: 8px;
 }
 
 .help-content::-webkit-scrollbar-track {
 background: var(--bg-tertiary);
 border-radius: 4px;
 }
 
 .help-content::-webkit-scrollbar-thumb {
 background: var(--accent);
 border-radius: 4px;
 }
 
 .help-content::-webkit-scrollbar-thumb:hover {
 background: var(--accent-hover);
 }
 </style>
<script>
/**
 * Patch v30-fix23 — Menu Forme con F (Explorer)
 * - Prende le forme dalla "Sezione 5" (select esistente del tipo forma) o da gruppi Forma.
 * - Frecce ↑/↓ per scorrere, INVIO conferma e inserisce al punto corrente, ESC chiude il menu.
 * - Valido solo quando Explorer attivo; non esce da Explorer.
 */
(function(){
 function sr(msg){
 const live = document.getElementById("sr-polite");
 if (live) live.textContent = msg;
 }
 function getExplorerPos(){
 const c = document.getElementById("canvas-explorer-cursor");
 const canvas = document.getElementById("canvas");
 const hint = document.getElementById("canvas-explorer-hint");
 if (!c || !canvas) return null;
 if (hint && hint.textContent){
 const m = hint.textContent.match(/X\s+(\d+),\s*Y\s+(\d+)/i);
 if (m) return { x: parseInt(m[1],10), y: parseInt(m[2],10) };
 }
 const crect = c.getBoundingClientRect();
 const rect = canvas.getBoundingClientRect();
 return { x: Math.round(crect.left - rect.left), y: Math.round(crect.top - rect.top) };
 }
 function setVal(id, v){
 const el = document.getElementById(id);
 if (!el) return false;
 el.value = v;
 el.dispatchEvent(new Event("input", { bubbles: true }));
 el.dispatchEvent(new Event("change", { bubbles: true }));
 return true;
 }
 function tryClick(ids){
 for (const id of ids){
 const el = (typeof id === "string") ? document.getElementById(id) : id;
 if (el && typeof el.click === "function"){ el.click(); return true; }
 }
 return false;
 }

 // Trova la select "origine" con l'elenco delle forme (Sezione 5)
 function findShapeSourceSelect(){
 const ids = ["shape-type","new-shape-type","select-shape-type","shapeKind","shape-type-5","section5-shape-type"];
 for (const id of ids){
 const sel = document.getElementById(id);
 if (sel && sel.tagName === "SELECT") return sel;
 }
 // Cerca in gruppi con titolo "Sezione 5" o "Forma/Forme"
 const groups = Array.from(document.querySelectorAll(".control-group"));
 for (const g of groups){
 const h = g.querySelector(".control-group-title");
 const title = (h && h.textContent || "").toLowerCase();
 if (/sezione\s*5/.test(title) || /forma|forme/.test(title)){
 const sel = g.querySelector("select");
 if (sel) return sel;
 }
 }
 // fallback: qualunque select che sembri lista forme (contiene rettangolo/cerchio/linea)
 const selects = Array.from(document.querySelectorAll("select"));
 for (const s of selects){
 const txt = Array.from(s.options).map(o => (o.text || "").toLowerCase()).join("|");
 if (/rettangolo|cerchio|linea|triangolo|freccia|poligono|stella/.test(txt)) return s;
 }
 return null;
 }

 function shapesFromSource(sel){
 if (!sel) return [];
 const out = [];
 for (const opt of sel.options){
 const label = (opt.text || "").trim();
 const val = (opt.value || "").trim();
 if (!label) continue;
 out.push({ label, value: val });
 }
 // de-duplica per etichetta
 const seen = new Set(); const dedup = [];
 for (const o of out){
 const key = o.label.toLowerCase();
 if (!seen.has(key)){ seen.add(key); dedup.push(o); }
 }
 return dedup;
 }

 function openShapeMenu(){
 closeShapeMenu();
 const sel = findShapeSourceSelect();
 const items = shapesFromSource(sel);
 if (!items.length){
 sr("Nessuna forma trovata nella Sezione 5.");
 return;
 }
 // posiziona il menu vicino al cursore
 const container = document.querySelector(".canvas-container") || document.body;
 const cur = document.getElementById("canvas-explorer-cursor");
 const menu = document.createElement("div");
 menu.id = "shape-quickmenu";
 menu.setAttribute("role","listbox");
 menu.setAttribute("tabindex","0");

 // costruisci opzioni
 const list = document.createElement("div");
 items.forEach((it, idx) => {
 const opt = document.createElement("div");
 opt.setAttribute("role","option");
 opt.setAttribute("data-value", it.value);
 opt.setAttribute("data-label", it.label);
 opt.textContent = it.label;
 if (idx === 0) opt.classList.add("active");
 list.appendChild(opt);
 });
 const hint = document.createElement("div");
 hint.className = "hint";
 hint.textContent = "↑/↓ per scegliere • Invio per confermare • Esc chiude";
 menu.appendChild(list);
 menu.appendChild(hint);
 container.appendChild(menu);

 // posiziona
 const r = cur.getBoundingClientRect();
 const cr = container.getBoundingClientRect();
 menu.style.left = (r.left - cr.left + container.scrollLeft + 16) + "px";
 menu.style.top = (r.top - cr.top + container.scrollTop + 16) + "px";

 menu.focus();
 sr(`Seleziona una forma. Sono disponibili ${items.length} forme.`);

 // gestione tastiera
 function options(){ return Array.from(menu.querySelectorAll('[role="option"]')); }
 function activeIndex(){ return options().findIndex(o => o.classList.contains("active")); }
 function setActive(i){
 const opts = options();
 if (!opts.length) return;
 const max = opts.length - 1;
 const idx = Math.max(0, Math.min(max, i));
 opts.forEach(o => o.classList.remove("active"));
 opts[idx].classList.add("active");
 opts[idx].setAttribute("aria-selected","true");
 opts[idx].scrollIntoView({ block: "nearest" });
 sr(`Forma: ${opts[idx].getAttribute("data-label")}`);
 }
 function confirm(){
 const opts = options();
 const idx = activeIndex();
 if (idx < 0) return;
 const opt = opts[idx];
 const value = opt.getAttribute("data-value");
 const label = opt.getAttribute("data-label");
 // posiziona X/Y e imposta select sorgente
 const p = getExplorerPos(); if (!p) return;
 setVal("new-shape-x", p.x);
 setVal("new-shape-y", p.y);
 if (sel) {
 sel.value = value;
 sel.dispatchEvent(new Event("input", { bubbles: true }));
 sel.dispatchEvent(new Event("change", { bubbles: true }));
 }
 // conferma tramite pulsante standard se presente
 if (!tryClick(["btn-add-shape","add-shape"])) {
 // fallback: un rettangolo generico se non c'è il pulsante
 tryClick(["btn-add-rect"]);
 }
 sr(`Forma “${label}” inserita a X ${p.x}, Y ${p.y}`);
 closeShapeMenu();
 }
 function closeShapeMenu(){
 menu.remove();
 window.__shapeMenuOpen = false;
 }

 window.__shapeMenuOpen = true;

 menu.addEventListener("keydown", function(e){
 const k = e.key;
 if (k === "ArrowDown"){ e.preventDefault(); setActive(activeIndex()+1); }
 else if (k === "ArrowUp"){ e.preventDefault(); setActive(activeIndex()-1); }
 else if (k === "Home"){ e.preventDefault(); setActive(0); }
 else if (k === "End"){ e.preventDefault(); setActive(1e9); }
 else if (k === "Enter"){ e.preventDefault(); confirm(); }
 else if (k === "Escape"){ e.preventDefault(); closeShapeMenu(); sr("Selezione forma annullata."); }
 else {
 // ricerca per lettera iniziale
 if (k.length === 1){
 const ch = k.toLowerCase();
 const opts = options();
 const start = activeIndex()+1;
 for (let i=0;i<opts.length;i++){
 const j = (start + i) % opts.length;
 const lbl = (opts[j].getAttribute("data-label") || "").trim().toLowerCase();
 if (lbl.startsWith(ch)){ setActive(j); break; }
 }
 }
 }
 });

 // Click mouse su opzione
 menu.addEventListener("click", function(e){
 const opt = e.target.closest('[role="option"]');
 if (!opt) return;
 options().forEach(o => o.classList.remove("active"));
 opt.classList.add("active");
 confirm();
 });

 // Chiudi se perdi focus (ma con ritardo per consentire click)
 menu.addEventListener("blur", function(){
 setTimeout(() => {
 if (!menu.contains(document.activeElement)) {
 try { menu.remove(); } catch(_){}
 window.__shapeMenuOpen = false;
 }
 }, 100);
 });
 }

 function closeShapeMenuIfOpen(){
 const m = document.getElementById("shape-quickmenu");
 if (m){ try { m.remove(); } catch(_){ } }
 window.__shapeMenuOpen = false;
 }

 // Hotkey F solo in Explorer
 window.addEventListener("keydown", function(e){
 if (!window.__canvasExplorerActive) return;
 if (e.key.toLowerCase() !== "f") return;
 // se si sta digitando in un input, ignora
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 if (tag === "input" || tag === "textarea") return;
 e.preventDefault();
 closeShapeMenuIfOpen();
 openShapeMenu();
 }, true);

 // Blocca il propagarsi dei tasti quando il menu è aperto (per non muovere il cursore)
 window.addEventListener("keydown", function(e){
 if (!window.__shapeMenuOpen) return;
 const k = e.key;
 if (k.startsWith("Arrow") || k === "Enter" || k === "Escape" || k === "Home" || k === "End" || k.length === 1){
 e.stopImmediatePropagation();
 }
 }, true);
})();
</script>

<script>
/**
 * Patch v30-fix24 — Stato Explorer più robusto e hotkey affidabili
 */
(function(){
 // Utility globale per capire se l'Explorer è attivo anche se la flag non è stata impostata
 window.isExplorerActive = function(){
 if (window.__canvasExplorerActive) return true;
 const c = document.getElementById("canvas-explorer-cursor");
 return !!(c && c.style.display && c.style.display !== "none");
 };

 // Forza toggleCanvasExplorer ad aggiornare sempre la flag
 if (typeof window.toggleCanvasExplorer === "function"){
 const _orig = window.toggleCanvasExplorer;
 window.toggleCanvasExplorer = function(on){
 const res = _orig(on);
 const c = document.getElementById("canvas-explorer-cursor");
 window.__canvasExplorerActive = !!(c && c.style.display !== "none");
 return res;
 };
 }

 // Normalizza i listener già esistenti per F/T/I/D affinché usino isExplorerActive()
 const normalizeHotkey = (handlerName, keyTestFn) => {
 const wrapped = function(e){
 try{
 if (!window.isExplorerActive()) return;
 // se siamo in input/textarea, ignora
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 if (tag === "input" || tag === "textarea") return;
 if (!keyTestFn(e)) return;
 // se arriviamo qui, lasciamo che gli handler esistenti lavorino
 }catch(err){console.warn("Silent catch:",err);}
 };
 return wrapped;
 };

 // Inseriamo un listener di guardia prima degli altri, in capturing,
 // che impedisca ad altri di bloccare F/T/I/D quando Explorer è attivo.
 window.addEventListener("keydown", function(e){
 const k = (e.key || "").toLowerCase();
 if (!window.isExplorerActive()) return;
 if (["f","t","i","d"].includes(k)){
 // Niente preventDefault qui: lasciamo passare agli handler già installati nei fix precedenti
 // Ma se qualche altro handler ha già chiamato stopImmediatePropagation, non possiamo evitarlo.
 // Questo listener in capturing si attiva prima per garantire priorità.
 }
 }, true);

 // Annuncia quando si prova a usare F/T/I/D e l'Explorer non è attivo
 window.addEventListener("keydown", function(e){
 const k = (e.key || "").toLowerCase();
 if (!["f","t","i","d"].includes(k)) return;
 // Controlla se il nostro sistema di esplorazione è attivo
 if (state.exploreMode) return; // Se state.exploreMode è attivo, non mostrare il messaggio
 // Controlla anche il vecchio sistema
 if (window.isExplorerActive && window.isExplorerActive()) return;
 const live = document.getElementById("sr-polite");
 if (live) live.textContent = "Attiva prima l'esplorazione canvas con Control più E.";
 }, true);
})();
</script>

<script>
/**
 * Patch v30-fix25 — Hardening Explorer & Hotkeys
 */
(function(){
 // INIZIALIZZAZIONE: Assicurati che l'Explorer sia DISATTIVATO all'avvio
 document.body.dataset.explorerActive = "0";
 
 // --- Live region ---
 let polite = document.getElementById("sr-polite");
 if (!polite) {
 polite = document.createElement("div");
 polite.id = "sr-polite";
 polite.className = "sr-only";
 polite.setAttribute("role","status");
 polite.setAttribute("aria-live","polite");
 polite.setAttribute("aria-atomic","true");
 document.body.prepend(polite);
 }
 function say(msg){ polite.textContent = msg; }

 // --- Canvas lookup (robusto) ---
 function getCanvas(){
 const byId = document.getElementById("canvas");
 if (byId && byId.getContext) return byId;
 const all = Array.from(document.querySelectorAll("canvas"));
 const usable = all.find(c => c.width > 0 && c.height > 0 && c.getContext);
 return usable || byId || null;
 }
 function canvasContainer(){
 const c = getCanvas();
 return document.querySelector(".canvas-container") || (c ? c.parentElement : null) || document.body;
 }

 // --- Explorer elements ---
 function ensureExplorerUI(){
 const container = canvasContainer();
 if (!container) return null;
 // cursor
 let cur = document.getElementById("canvas-explorer-cursor");
 if (!cur){
 cur = document.createElement("div");
 cur.id = "canvas-explorer-cursor";
 cur.setAttribute("aria-hidden", "true"); // Impedisci a NVDA di leggere il cursore
 Object.assign(cur.style, {
 position:"absolute", width:"12px", height:"12px",
 marginLeft:"-6px", marginTop:"-6px",
 border:"2px solid #222", borderRadius:"50%",
 background:"rgba(255,255,255,0.6)",
 boxShadow:"0 0 0 1px #fff, 0 0 6px rgba(0,0,0,0.4)",
 pointerEvents:"none", zIndex:"9997", display:"none"
 });
 container.appendChild(cur);
 } else {
 // Assicurati che aria-hidden sia impostato anche se l'elemento esisteva già
 cur.setAttribute("aria-hidden", "true");
 }
 // hint
 let hint = document.getElementById("canvas-explorer-hint");
 if (!hint){
 hint = document.createElement("div");
 hint.id = "canvas-explorer-hint";
 hint.setAttribute("aria-hidden", "true"); // FONDAMENTALE: impedisci a NVDA di leggere hint
 Object.assign(hint.style, {
 position:"absolute",
 font:"12px/1.2 -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Arial",
 padding:"6px 8px",
 background:"rgba(0,0,0,0.75)", color:"#fff",
 borderRadius:"6px",
 boxShadow:"0 2px 10px rgba(0,0,0,0.35)",
 pointerEvents:"none", zIndex:"9997", display:"none"
 });
 container.appendChild(hint);
 } else {
 // Assicurati che aria-hidden sia impostato anche se l'elemento esisteva già
 hint.setAttribute("aria-hidden", "true");
 }
 return {container, cur, hint};
 }

 function setVisible(el, v){ if (el) el.style.display = v ? "block" : "none"; }

 // Robust state
 function isExplorerActive(){
 if (document.body.dataset.explorerActive === "1") return true;
 const cur = document.getElementById("canvas-explorer-cursor");
 return !!(cur && cur.style.display !== "none");
 }
 function setExplorerActive(on){
 const ui = ensureExplorerUI();
 if (!ui) return false;
 // Controlla lo stato precedente
 const wasActive = document.body.dataset.explorerActive === "1";
 document.body.dataset.explorerActive = on ? "1" : "0";
 document.body.classList.toggle("canvas-explorer-on", !!on);
 setVisible(ui.cur, !!on);
 setVisible(ui.hint, !!on);
 if (on){
 const c = getCanvas();
 if (!c) return false;
 const pos = { x: Math.floor(c.width/2)||0, y: Math.floor(c.height/2)||0 };
 updateCursor(pos);
 announceExplorerPos(pos);
 say("Canvas Explorer attivato. Frecce per muovere, F forme, T testo, I immagine, D disegno, Esc per uscire.");
 } else {
 // CANCELLA il contenuto di hint per impedire a NVDA di leggerlo
 if (ui && ui.hint) ui.hint.textContent = "";
 // Mostra il messaggio solo se era effettivamente attivo prima
 if (wasActive) {
 say("Canvas Explorer disattivato");
 }
 }
 return true;
 }

 function canvasOffsets(){
 const c = getCanvas(); if (!c) return {left:0, top:0};
 const cont = canvasContainer();
 const rect = c.getBoundingClientRect();
 const crect = cont.getBoundingClientRect();
 return { left: rect.left - crect.left + cont.scrollLeft, top: rect.top - crect.top + cont.scrollTop };
 }
 function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
 function toHex(n){ return n.toString(16).padStart(2,"0").toUpperCase(); }
 function sampleColor(x,y){
 const c = getCanvas(); if (!c) return null;
 try{
 const ctx = c.getContext("2d");
 const d = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
 return `#${toHex(d[0])}${toHex(d[1])}${toHex(d[2])}`;
 }catch(_){ return null; }
 }
 function currentPos(){
 const hint = document.getElementById("canvas-explorer-hint");
 if (!hint || !hint.textContent) return null;
 const m = hint.textContent.match(/X\s+(\d+),\s*Y\s+(\d+)/i);
 return m ? { x: parseInt(m[1],10), y: parseInt(m[2],10) } : null;
 }
 function updateCursor(pos){
 const c = getCanvas(); const ui = ensureExplorerUI();
 if (!c || !ui) return;
 const off = canvasOffsets();
 ui.cur.style.left = (off.left + pos.x) + "px";
 ui.cur.style.top = (off.top + pos.y) + "px";
 ui.hint.style.left = (off.left + pos.x + 14) + "px";
 ui.hint.style.top = (off.top + pos.y + 14) + "px";
 }
 function announceExplorerPos(pos){
 if (!isExplorerActive()) return; // NON annunciare se l'explorer è inattivo
 const hex = sampleColor(pos.x, pos.y);
 const ui = ensureExplorerUI();
 if (ui) ui.hint.textContent = `X ${pos.x}, Y ${pos.y}${hex ? " — "+hex : ""}`;
 say(`X ${pos.x}, Y ${pos.y}${hex ? ", colore "+hex : ""}`);
 }
 function moveBy(dx, dy){
 if (!isExplorerActive()) return; // NON muovere se l'explorer non è attivo!
 const c = getCanvas(); if (!c) return;
 let pos = currentPos() || { x: Math.floor(c.width/2)||0, y: Math.floor(c.height/2)||0 };
 pos.x = clamp(pos.x + dx, 0, Math.max(0, c.width-1));
 pos.y = clamp(pos.y + dy, 0, Math.max(0, c.height-1));
 updateCursor(pos);
 announceExplorerPos(pos);
 }

 // DISABILITATO: Questo interferisce con il sistema di esplorazione principale (riga 8486)
 // Ctrl+E: toggle (hard)
 // window.addEventListener("keydown", function(e){
 // if (e.key.toLowerCase() === "e" && e.ctrlKey){
 // e.preventDefault();
 // ensureExplorerUI();
 // setExplorerActive(!isExplorerActive());
 // }
 // }, true);

 // Esc: exit Explorer
 window.addEventListener("keydown", function(e){
 if (e.key === "Escape" && isExplorerActive()){
 e.preventDefault();
 setExplorerActive(false);
 }
 }, true);

 // Arrows: move when Explorer active
 window.addEventListener("keydown", function(e){
 if (!isExplorerActive()) return;
 // Controlla il marker impostato da fix31
 if (e.__fromFormField) return;
 // Non intercettare se l'evento proviene da un campo form
 const target = e.target;
 if (target && target.nodeType === 1) {
 const tag = target.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return;
 const role = (target.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return;
 }
 const k = e.key;
 if (!/^Arrow/.test(k)) return;
 e.preventDefault();
 const step = e.ctrlKey ? 50 : e.shiftKey ? 10 : 1;
 const dx = (k==="ArrowLeft"?-step:k==="ArrowRight"?step:0);
 const dy = (k==="ArrowUp"?-step:k==="ArrowDown"?step:0);
 moveBy(dx, dy);
 }, false); // Usa bubbling phase

 // --- Actions ---
 function setVal(id, v){
 const el = document.getElementById(id);
 if (!el) return false;
 el.value = v;
 el.dispatchEvent(new Event("input", { bubbles: true }));
 el.dispatchEvent(new Event("change", { bubbles: true }));
 return true;
 }
 function clickIf(id){
 const el = document.getElementById(id);
 if (el && typeof el.click === "function"){ el.click(); return true; }
 return false;
 }

 // T: add text
 function doAddText(){
 const pos = currentPos(); if (!pos) return say("Posizione non disponibile.");
 setVal("new-text-x", pos.x);
 setVal("new-text-y", pos.y);
 const input = document.getElementById("text-input");
 if (input && !input.value.trim()) input.value = "Nuovo testo";
 if (clickIf("btn-add-text")) say(`Testo inserito a X ${pos.x}, Y ${pos.y}`);
 else say("Pulsante Aggiungi Testo non trovato.");
 }
 // I: add image
 function doAddImage(){
 const pos = currentPos(); if (!pos) return say("Posizione non disponibile.");
 setVal("new-img-x", pos.x);
 setVal("new-img-y", pos.y);
 if (clickIf("image-upload")) say(`Seleziona immagine: verrà posizionata a X ${pos.x}, Y ${pos.y}`);
 else say("Controllo caricamento immagine non trovato.");
 }
 // D: vector draw
 function doVectorDraw(){
 const ok = clickIf("btn-draw-vector") || clickIf("btn-start-draw") || clickIf("btn-draw") || clickIf("toolbar-draw");
 if (ok) say("Disegno vettoriale attivato. Esc annulla, Invio conferma.");
 else say("Comando disegno vettoriale non trovato.");
 }
 // F: open shape quick menu (reuse fix23 if present; otherwise minimal fallback)
 function openShapeMenu(){
 const existing = document.getElementById("shape-quickmenu");
 if (existing){ try{ existing.remove(); }catch(_){ } }
 // If fix23 already installed, its code will handle 'F'. As fallback, we try to trigger it by dispatching a custom event.
 const ev = new CustomEvent("open-shape-menu", { bubbles: true });
 window.dispatchEvent(ev);
 // If nothing handled, say something
 setTimeout(() => {
 if (!document.getElementById("shape-quickmenu")){
 say("Menu forme non disponibile.");
 }
 }, 30);
 }

 // unified hotkeys; auto-activate Explorer if needed
 window.addEventListener("keydown", function(e){
 const k = (e.key || "").toLowerCase();
 if (!["f","t","i","d"].includes(k)) return;
 // ignore inside inputs
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 if (tag === "input" || tag === "textarea") return;

 if (!isExplorerActive()){
 ensureExplorerUI();
 setExplorerActive(true);
 // allow a brief tick so UI positions
 setTimeout(() => {
 if (k==="f") openShapeMenu();
 if (k==="t") doAddText();
 if (k==="i") doAddImage();
 if (k==="d") doVectorDraw();
 }, 30);
 e.preventDefault();
 return;
 }

 // Explorer already active
 if (k==="f"){ e.preventDefault(); openShapeMenu(); }
 if (k==="t"){ e.preventDefault(); doAddText(); }
 if (k==="i"){ e.preventDefault(); doAddImage(); }
 if (k==="d"){ e.preventDefault(); doVectorDraw(); }
 }, true);

 // Listener that fix23 can hook to
 window.addEventListener("open-shape-menu", function(){
 // do nothing here; fix23 provides the UI; this is just a rendezvous
 });
})();
</script>

<script>
/**
 * Patch v30-fix26 — Shape menu: frecce affidabili, niente numeri, annunci lenti
 */
(function(){
 // Utility: debounce
 function debounce(fn, ms){
 let t = null;
 return function(...args){
 clearTimeout(t);
 t = setTimeout(() => fn.apply(this, args), ms);
 };
 }

 // Hook only if fix23's menu builder exists (we detect by listening to 'open-shape-menu')
 let installed = false;

 window.addEventListener("open-shape-menu", function(){
 if (installed) return;
 installed = true;

 // Monkey-patch the existing builder by intercepting after it creates #shape-quickmenu
 setTimeout(() => {
 const menu = document.getElementById("shape-quickmenu");
 if (!menu) return;

 // Add aria semantics
 menu.setAttribute("role","listbox");
 menu.setAttribute("aria-label","Seleziona forma");
 menu.setAttribute("tabindex","0");

 const opts = Array.from(menu.querySelectorAll('[role="option"]'));
 // Strip numeric prefixes from labels for SR clarity
 opts.forEach(opt => {
 const lbl = (opt.getAttribute("data-label") || opt.textContent || "");
 const clean = lbl.replace(/^\s*\d+[\.\)\-]?\s*/,"");
 opt.setAttribute("data-label", clean);
 opt.textContent = clean;
 });

 // Track active and announce with debounce
 const live = document.getElementById("sr-polite");
 const announce = debounce((msg) => { if (live) live.textContent = msg; }, 180);

 function setActiveIndex(idx){
 const options = Array.from(menu.querySelectorAll('[role="option"]'));
 const max = options.length - 1;
 const i = Math.max(0, Math.min(max, idx));
 options.forEach(o => { o.classList.remove("active"); o.removeAttribute("aria-selected"); });
 const active = options[i];
 if (active){
 active.classList.add("active");
 active.setAttribute("aria-selected","true");
 menu.setAttribute("aria-activedescendant", active.id || (active.id = "opt-" + Math.random().toString(36).slice(2)));
 active.scrollIntoView({block:"nearest"});
 const label = active.getAttribute("data-label") || active.textContent || "";
 // DISABLED: announce("Forma: " + label);
 }
 }

 function getActiveIndex(){
 const options = Array.from(menu.querySelectorAll('[role="option"]'));
 return options.findIndex(o => o.classList.contains("active"));
 }

 // Ensure one active item
 if (getActiveIndex() < 0) setActiveIndex(0);

 // Replace key handler to ignore digits and use letters only
 menu.addEventListener("keydown", function(e){
 const k = e.key;
 const isArrow = (k === "ArrowDown" || k === "ArrowUp");
 const isHomeEnd = (k === "Home" || k === "End");
 const isEnter = (k === "Enter");
 const isEsc = (k === "Escape");
 // letters only a-z for typeahead
 const isLetter = k.length === 1 && /^[a-zA-Z]$/.test(k);

 if (!(isArrow || isHomeEnd || isEnter || isEsc || isLetter)) return;

 e.preventDefault();
 e.stopImmediatePropagation();

 if (isArrow){
 const delta = (k === "ArrowDown") ? 1 : -1;
 setActiveIndex(getActiveIndex() + delta);
 return;
 }
 if (isHomeEnd){
 setActiveIndex(k === "Home" ? 0 : 1e9);
 return;
 }
 if (isLetter){
 const ch = k.toLowerCase();
 const options = Array.from(menu.querySelectorAll('[role="option"]'));
 const start = getActiveIndex() + 1;
 for (let i=0;i<options.length;i++){
 const j = (start + i) % options.length;
 const lbl = (options[j].getAttribute("data-label") || "").trim().toLowerCase();
 if (lbl.startsWith(ch)){ setActiveIndex(j); break; }
 }
 return;
 }
 if (isEnter){
 // trigger original confirm by clicking active option
 const options = Array.from(menu.querySelectorAll('[role="option"]'));
 const idx = getActiveIndex();
 if (idx >= 0){
 options[idx].click();
 }
 return;
 }
 if (isEsc){
 try { menu.remove(); } catch(_){}
 window.__shapeMenuOpen = false;
 if (live) live.textContent = "Selezione forma annullata.";
 return;
 }
 }, true);
 }, 0);
 });
})();
</script>

<script>
/**
 * Patch v30-fix27 — Disattiva movimento con Frecce nell'Explorer
 * - Le Frecce non spostano più il cursore dell'Explorer.
 * - Restano attivi Ctrl+E (toggle), Esc (uscita), F/T/I/D (azioni), e il menu forme con frecce.
 */
(function(){
 // Flag globale per riconoscere quando il menu forme è aperto
 function isShapeMenuOpen(){ return !!document.getElementById("shape-quickmenu"); }
 function isExplorerActive(){
 // NON considerare attivo se state.exploreMode è true (sistema di esplorazione alternativo)
 if (window.state?.exploreMode) return false;
 return document.body?.dataset?.explorerActive === "1" ||
 !!(document.getElementById("canvas-explorer-cursor") && document.getElementById("canvas-explorer-cursor").style.display !== "none");
 }
 // Intercetta le Frecce quando Explorer attivo e menu forme non aperto: non fare nulla
 window.addEventListener("keydown", function(e){
 const k = e.key;
 if (!/^Arrow/.test(k)) return;
 
 // Consenti sempre le frecce se:
 // - Stai interagendo con il menu forme (listbox) => servono per navigare
 // - Sei dentro un input/textarea/select
 // - Sei in modalità disegno vettoriale
 const tag = (e.target && e.target.tagName || "").toLowerCase();
 const isVectorMode = window.state && window.state.vectorDrawMode;
 if (isShapeMenuOpen() || tag === "input" || tag === "textarea" || tag === "select" || isVectorMode) return;
 
 // SOLO SE l'Explorer è attivo E c'è un cursore visibile, blocca le frecce
 if (!isExplorerActive()) return;
 
 // Altrimenti blocca il movimento precedente
 e.preventDefault();
 e.stopImmediatePropagation();
 }, true);

 // Rimuovi dai messaggi qualsiasi istruzione sulle frecce
 (function scrubExplorerHints(){
 const polite = document.getElementById("sr-polite");
 if (!polite) return;
 const origSet = Object.getOwnPropertyDescriptor(Node.prototype, "textContent")?.set;
 // Non sovrascrivere se non possibile
 if (!origSet) return;
 const setter = function(v){
 try {
 if (typeof v === "string" && /frecce.*muovere/i.test(v)) {
 v = v.replace(/,?\s*frecce.*?(?:\.|$)/i, "."); // togli segmento sulle frecce
 v = v.replace(/\s+\./g, "."); // pulizia spazi doppi
 }
 } catch(_) {}
 return origSet.call(this, v);
 };
 Object.defineProperty(polite, "textContent", { set: setter });
 })();
})();
</script>

<script>
/**
 * Patch v30-fix28 — Mappa Sonora robusta
 * - Ctrl+M: attiva/disattiva scanner sonoro (sweep orizzontale) che "vede" gli elementi
 * - P: sonda puntuale (blip) al punto corrente dell'Explorer
 * - Rilevamento: array livelli (rettangoli, cerchi, linee, poligoni) + fallback su pixel del canvas
 * - Audio: WebAudio con oscillatore, gain e panning; non blocca screen reader
 */
(function(){
 // ---------- Utilities Canvas & Layers ----------
 function getCanvas(){
 const byId = document.getElementById("canvas");
 if (byId && byId.getContext) return byId;
 const any = Array.from(document.querySelectorAll("canvas")).find(c => c.width && c.height && c.getContext);
 return any || null;
 }
 function getCTX(){ const c = getCanvas(); return c ? c.getContext("2d") : null; }

 function findLayersArray(){
 const picks = [];
 for (const k in window){
 try{
 const v = window[k];
 if (Array.isArray(v) && v.length){
 const el = v[v.length-1];
 const hasGeom = el && typeof el === "object" && (("x" in el && "y" in el) || ("left" in el && "top" in el));
 const hasSize = el && (("width" in el || "w" in el || "radius" in el || "r" in el) || ("height" in el || "h" in el));
 const hasType = el && (("type" in el) || ("kind" in el) || ("layerType" in el));
 if (hasGeom && (hasSize || hasType) && v.length < 5000){
 picks.push({ key:k, arr:v });
 }
 }
 }catch(err){console.warn("Silent catch:",err);}
 }
 const named = picks.find(c => /layers|livelli|objects|items/i.test(c.key));
 return named || picks[0] || null;
 }
 function num(v, alts=[], d=0){
 if (typeof v === "number") return v;
 for (const k of alts){ if (typeof v?.[k] === "number") return v[k]; }
 return d;
 }
 function inPoly(x,y, pts){
 let inside = false;
 for (let i=0,j=pts.length-1; i<pts.length; j=i++){
 const xi = pts[i].x ?? pts[i][0], yi = pts[i].y ?? pts[i][1];
 const xj = pts[j].x ?? pts[j][0], yj = pts[j].y ?? pts[j][1];
 const inter = ((yi>y)!=(yj>y)) && (x < (xj-xi)*(y-yi)/((yj-yi)||1e-9)+xi);
 if (inter) inside = !inside;
 }
 return inside;
 }
 function lineHit(o,x,y){
 if (!("x1" in o && "y1" in o && "x2" in o && "y2" in o)) return false;
 const {x1,y1,x2,y2} = o;
 const A = x - x1, B = y - y1, C = x2 - x1, D = y2 - y1;
 const dot = A*C + B*D, len2 = C*C + D*D;
 let t = (len2 ? dot/len2 : -1);
 let xx,yy;
 if (t<0){ xx=x1; yy=y1; } else if (t>1){ xx=x2; yy=y2; } else { xx=x1+t*C; yy=y1+t*D; }
 const dx=x-xx, dy=y-yy;
 const thick = num(o.strokeWidth, ["thickness","lineWidth"], 3);
 return Math.sqrt(dx*dx+dy*dy) <= Math.max(2, thick/2 + 2);
 }
 function containsPoint(o,x,y){
 const typ = (o.type || o.kind || o.layerType || "").toString().toLowerCase();
 const ox = num(o.x, ["left"]); const oy = num(o.y, ["top"]);
 const ow = num(o.width, ["w"]); const oh = num(o.height, ["h"]);
 if ((ow || oh) && !/circle|cerchio/.test(typ)){
 return x>=ox && y>=oy && x<=ox+ow && y<=oy+oh;
 }
 if (/circle|cerchio/.test(typ) || ("radius" in o || "r" in o)){
 const r = num(o.radius, ["r"], 0);
 const cx = ("cx" in o) ? o.cx : ox + r;
 const cy = ("cy" in o) ? o.cy : oy + r;
 const dx=x-cx, dy=y-cy;
 return dx*dx+dy*dy <= r*r;
 }
 if (/line|linea/.test(typ) && lineHit(o,x,y)) return true;
 if (Array.isArray(o.points) && o.points.length>=3 && inPoly(x,y,o.points)) return true;
 return false;
 }
 function topAt(x,y){
 const src = findLayersArray();
 if (!src) return null;
 const arr = src.arr;
 for (let i=arr.length-1; i>=0; i--){
 const o = arr[i];
 try { if (o && containsPoint(o,x,y)) return o; } catch(_){}
 }
 return null;
 }
 function pixelBusy(x,y){
 const ctx = getCTX(); if (!ctx) return false;
 try {
 const d = ctx.getImageData(Math.floor(x), Math.floor(y), 1, 1).data;
 // occupato se luminanza o alpha > soglia
 const lum = (0.2126*d[0] + 0.7152*d[1] + 0.0722*d[2]);
 const a = d[3];
 return a > 8 || lum > 12;
 } catch(_){ return false; }
 }
 function hasContentAt(x,y){
 const o = topAt(x,y);
 if (o) return { hit:true, obj:o };
 return { hit: pixelBusy(x,y), obj: null };
 }

 // ---------- Explorer position ----------
 function getExplorerPos(){
 const hint = document.getElementById("canvas-explorer-hint");
 if (!hint || !hint.textContent) return null;
 const m = hint.textContent.match(/X\s+(\d+),\s*Y\s+(\d+)/i);
 return m ? { x: parseInt(m[1],10), y: parseInt(m[2],10) } : null;
 }

 // ---------- Audio ----------
 const Audio = {
 ctx: null, osc: null, gain: null, pan: null,
 ensure(){
 if (this.ctx) return true;
 try {
 this.ctx = new (window.AudioContext || window.webkitAudioContext)();
 this.gain = this.ctx.createGain();
 this.pan = this.ctx.createStereoPanner ? this.ctx.createStereoPanner() : null;
 this.osc = this.ctx.createOscillator();
 this.osc.type = "sine";
 this.osc.frequency.value = 0;
 if (this.pan) {
 this.osc.connect(this.pan); this.pan.connect(this.gain);
 } else {
 this.osc.connect(this.gain);
 }
 this.gain.connect(this.ctx.destination);
 this.gain.gain.value = 0.0;
 this.osc.start();
 return true;
 } catch(e){ return false; }
 },
 set(freq, vol, pan){
 if (!this.ctx) return;
 try {
 this.osc.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.01);
 this.gain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.02);
 if (this.pan) this.pan.pan.setTargetAtTime(pan, this.ctx.currentTime, 0.02);
 } catch(_){}
 },
 off(){ this.set(0, 0.0, 0); }
 };

 // ---------- Sweep controller ----------
 let sweeping = false;
 let raf = null;
 function toggleSweep(on){
 const polite = document.getElementById("sr-polite");
 if (on === undefined) on = !sweeping;
 if (on){
 if (!Audio.ensure()){
 if (polite) polite.textContent = "Audio non disponibile nel browser.";
 return;
 }
 sweeping = true;
 if (polite) polite.textContent = "Mappa sonora attivata.";
 sweepLoop();
 } else {
 sweeping = false;
 if (raf) cancelAnimationFrame(raf);
 Audio.off();
 if (polite) polite.textContent = "Mappa sonora disattivata.";
 }
 }

 let sweepX = 0;
 function sweepLoop(){
 const c = getCanvas(); const ctx = getCTX();
 if (!sweeping || !c || !ctx){ Audio.off(); return; }
 const y = Math.floor(c.height/2);
 // step veloce ~ 240px/s con rAF
 sweepX = (sweepX + 3) % c.width;
 const res = hasContentAt(sweepX, y);
 // audio mapping: frequenza da Y e volume da hit
 const pan = (sweepX / c.width) * 2 - 1; // -1 sx, +1 dx
 const freq = 220 + (y / c.height) * 660; // 220..880
 const vol = res.hit ? 0.25 : 0.0;
 Audio.set(freq, vol, pan);
 raf = requestAnimationFrame(sweepLoop);
 // Salvo il raf globalmente per il cleanup
 window.sweepRaf = raf;
 }

 // ---------- Probe (P) ----------
 function probeAtCursor(){
 const polite = document.getElementById("sr-polite");
 const pos = getExplorerPos();
 if (!pos){ if (polite) polite.textContent = "Posizione non disponibile."; return; }
 const res = hasContentAt(pos.x, pos.y);
 if (!Audio.ensure()){ if (polite) polite.textContent = "Audio non disponibile."; return; }
 // breve blip
 const pan = 0;
 const freq = 440;
 Audio.set(freq, res.hit ? 0.35 : 0.0, pan);
 setTimeout(() => Audio.off(), 180);
 if (polite) polite.textContent = res.hit ? "Sotto il cursore c'è un elemento." : "Area vuota.";
 }

 // ---------- Hotkeys ----------
 window.addEventListener("keydown", function(e){
 // inizializza AudioContext a seguito di gesto utente qualsiasi
 if (!Audio.ctx){
 try {
 if ([" ", "Enter", "m", "M", "p", "P", "f", "F", "t", "T", "i", "I", "d", "D"].includes(e.key)) {
 Audio.ensure();
 }
 } catch(_){}
 }

 // Ctrl+M toggles sweep
 if ((e.key === "m" || e.key === "M") && e.ctrlKey){
 e.preventDefault();
 toggleSweep();
 }
 // P for probe (solo se Explorer attivo)
 if ((e.key === "p" || e.key === "P") && (document.body.dataset.explorerActive === "1")){
 e.preventDefault();
 probeAtCursor();
 }
 }, true);

 // Esporta per eventuale UI
 window.toggleSoundMap = toggleSweep;
 window.probeSoundMap = probeAtCursor;
})();
</script>



<script>
/**
 * Patch v30-fix30 — Stop X/Y quando il focus è su SELECT/INPUT/TEXTAREA/combobox
 * - Attiva un lock durante il focus su campi modulo.
 * - Ripristina immediatamente eventuali modifiche a X/Y durante il lock.
 * - Disattiva vectorNudge e simili durante il lock.
 */
(function(){
 // ---- Lock management ----
 function isFormField(el){
 // --- INIZIO BLOCCO DA AGGIUNGERE ---
 const xyIds = ["pos-x","pos-y","new-text-x","new-text-y","new-shape-x","new-shape-y","new-img-x","new-img-y"];
 if (el.tagName.toLowerCase() === 'input' && xyIds.includes(el.id)) {
   return false; // Questo è un input X/Y, NON deve bloccare
 }
 // --- FINE BLOCCO DA AGGIUNGERE ---

 if (!el || el.nodeType !== 1) return false;
 const tag = el.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return true;
 if (el.isContentEditable) return true;
 const role = (el.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return true;
 return false;
 }
 function updateLock(){
 const a = document.activeElement;
 const lock = isFormField(a);
 document.body.dataset.xyLock = lock ? "1" : "0";
 }
 document.addEventListener("focusin", updateLock, true);
 document.addEventListener("focusout", updateLock, true);
 // init
 updateLock();

 // ---- Neutralize vectorNudge & nudge handlers while locked ----
 const originalVectorNudge = window.vectorNudge;
 if (originalVectorNudge && typeof originalVectorNudge === 'function') {
 window.vectorNudge = function(...args){
 // Se il lock è attivo, non fare nulla
 if (document.body.dataset.xyLock === "1") return;
 // Altrimenti chiama la funzione originale
 return originalVectorNudge.apply(this, args);
 };
 }

 // ---- Protect X/Y inputs: revert any change during lock ----
 const xyIds = ["pos-x","pos-y","new-text-x","new-text-y","new-shape-x","new-shape-y","new-img-x","new-img-y"];
 const xyEls = xyIds.map(id => document.getElementById(id)).filter(Boolean);
 const lastXY = new Map();
 function snapshot(){
 for (const el of xyEls){
 lastXY.set(el.id, el.value);
 }
 }
 snapshot();

 function revertIfLocked(e){
 if (document.body.dataset.xyLock !== "1") { snapshot(); return; }
 const el = e.target;
 if (!el || !xyIds.includes(el.id)) return;
 // revert to previous value
 const prev = lastXY.get(el.id);
 if (prev !== undefined && el.value !== prev){
 el.value = prev;
 // stop further propagation so no canvas update occurs
 e.stopImmediatePropagation();
 }
 }

 for (const el of xyEls){
 el.addEventListener("input", revertIfLocked, true);
 el.addEventListener("change", revertIfLocked, true);
 }

 // Observe dynamic creation of XY inputs and attach guards
 const obs = new MutationObserver((muts) => {
 for (const m of muts){
 if (m.type === "childList"){
 for (const n of m.addedNodes){
 if (!(n instanceof HTMLElement)) continue;
 for (const id of xyIds){
 const el = n.id === id ? n : n.querySelector ? n.querySelector("#"+id) : null;
 if (el && !lastXY.has(id)){
 lastXY.set(id, el.value);
 el.addEventListener("input", revertIfLocked, true);
 el.addEventListener("change", revertIfLocked, true);
 }
 }
 }
 }
 }
 });
 obs.observe(document.body, { childList: true, subtree: true });

 // Aggiorna snapshot periodicamente quando non bloccato
 setInterval(() => { if (document.body.dataset.xyLock !== "1") snapshot(); }, 300);
})();
</script>

<script>
/**
 * Patch v30-fix31 — Protegge le select permettendo il comportamento nativo
 * NON blocca la propagazione, ma marca l'evento così altri handler sanno di ignorarlo
 */
(function(){
 const arrowKeys = new Set(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Home","End","PageUp","PageDown"]);

 function isFormField(el){
 if (!el || el.nodeType !== 1) return false;
 const tag = el.tagName.toLowerCase();
 if (tag === "select" || tag === "input" || tag === "textarea") return true;
 if (el.isContentEditable) return true;
 const role = (el.getAttribute("role") || "").toLowerCase();
 if (role === "combobox" || role === "listbox" || role === "textbox") return true;
 return false;
 }

 function guard(e){
 if (!arrowKeys.has(e.key)) return;
 if (!isFormField(e.target)) return;
 // Marca l'evento come "da un campo form" per altri handler
 e.__fromFormField = true;
 
 // NON fare override di preventDefault
 // Lascia che il comportamento nativo delle select funzioni
 }

 window.addEventListener("keydown", guard, true);
 window.addEventListener("keyup", guard, true);
 window.addEventListener("keypress", guard, true);
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30-fix32 — PERMETTE ENTER NEL TEXTAREA
 * ═══════════════════════════════════════════════════════════════
 * Risolve il problema: il textarea non permette di andare a capo con Enter
 */
(function(){
 console.log(' Patch v30-fix32: Abilitazione Enter in textarea...');
 
 function enableEnterInTextarea() {
 const textarea = document.getElementById('new-text-content');
 if (!textarea) {
 console.warn('Textarea new-text-content non trovato');
 return;
 }
 
 // Rimuovi eventuali handler che prevengono Enter
 textarea.addEventListener('keydown', function(e) {
 if (e.key === 'Enter' && !e.ctrlKey && !e.altKey && !e.metaKey) {
 // Permetti il comportamento di default (inserisce newline)
 // NON chiamare preventDefault()
 e.stopPropagation(); // Ferma propagazione per evitare altri handler
 console.log(' Enter permesso in textarea');
 }
 }, true); // useCapture=true per eseguire PRIMA di altri handler
 
 console.log(' Enter abilitato in textarea new-text-content');
 }
 
 // Esegui quando il DOM è pronto
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', enableEnterInTextarea);
 } else {
 enableEnterInTextarea();
 }
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30-fix33 — SINCRONIZZA aria-expanded CON CSS
 * ═══════════════════════════════════════════════════════════════
 * Risolve: le sezioni dicono "non espanso" quando sono espanse
 */
(function(){
 console.log(' Patch v30-fix33: Sincronizzazione aria-expanded...');
 
 function syncAriaExpanded() {
 let synced = 0;
 
 // 1. Sincronizza section-header (accordion principali)
 document.querySelectorAll('.section-panel').forEach(panel => {
 const header = panel.querySelector('.section-header');
 const content = panel.querySelector('.section-content');
 
 if (header && content) {
 const isCollapsed = content.classList.contains('collapsed');
 const shouldBeExpanded = !isCollapsed;
 const currentExpanded = header.getAttribute('aria-expanded') === 'true';
 
 // Verifica aria-controls
 const ariaControls = header.getAttribute('aria-controls');
 if (ariaControls && ariaControls !== content.id) {
 console.warn(`️ aria-controls mismatch: button="${ariaControls}" content.id="${content.id}"`);
 header.setAttribute('aria-controls', content.id);
 }
 
 if (shouldBeExpanded !== currentExpanded) {
 header.setAttribute('aria-expanded', shouldBeExpanded ? 'true' : 'false');
 synced++;
 }
 }
 });
 
 // 2. Sincronizza btn-toggle-advanced (sottosezioni avanzate)
 document.querySelectorAll('.btn-toggle-advanced').forEach(btn => {
 const targetId = btn.getAttribute('aria-controls');
 
 if (targetId) {
 const target = document.getElementById(targetId);
 
 if (target) {
 const isCollapsed = target.classList.contains('collapsed');
 const shouldBeExpanded = !isCollapsed;
 const currentExpanded = btn.getAttribute('aria-expanded') === 'true';
 
 if (shouldBeExpanded !== currentExpanded) {
 btn.setAttribute('aria-expanded', shouldBeExpanded ? 'true' : 'false');
 
 // Sincronizza anche l'icona visuale
 const icon = btn.querySelector('.icon');
 if (icon) {
 icon.textContent = isCollapsed ? '▼' : '▲';
 }
 
 synced++;
 }
 } else {
 // aria-controls punta a ID inesistente
 console.error(` aria-controls="${targetId}" non trovato per button#${btn.id || 'unknown'}`);
 }
 } else {
 // Bottone senza aria-controls
 console.warn(`️ btn-toggle-advanced senza aria-controls:`, btn);
 }
 });
 
 if (synced > 0) {
 console.log(` Sincronizzati ${synced} accordion (section-header + btn-toggle-advanced)`);
 }
 }
 
 // Sincronizza all'avvio
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', syncAriaExpanded);
 } else {
 syncAriaExpanded();
 }
 
 // Observer per cambiamenti classe "collapsed"
 const observer = new MutationObserver(function(mutations) {
 let needsSync = false;
 
 mutations.forEach(function(mutation) {
 if (mutation.type === 'attributes' && 
 mutation.attributeName === 'class') {
 // Controlla sia section-content che target di btn-toggle-advanced
 const target = mutation.target;
 if (target.classList.contains('section-content') || 
 target.id && document.querySelector(`[aria-controls="${target.id}"]`)) {
 needsSync = true;
 }
 }
 });
 
 if (needsSync) {
 syncAriaExpanded();
 }
 });
 
 // Osserva tutti i section-content
 document.querySelectorAll('.section-content').forEach(content => {
 observer.observe(content, { 
 attributes: true, 
 attributeFilter: ['class'] 
 });
 });
 
 // Osserva anche i target dei btn-toggle-advanced
 document.querySelectorAll('.btn-toggle-advanced').forEach(btn => {
 const targetId = btn.getAttribute('aria-controls');
 if (targetId) {
 const target = document.getElementById(targetId);
 if (target && !target.classList.contains('section-content')) {
 // Se non è già osservato come section-content, osservalo
 observer.observe(target, {
 attributes: true,
 attributeFilter: ['class']
 });
 }
 }
 });
 
 // RIMOSSO: Section headers non sono più pulsanti cliccabili
 /*
 // Sincronizza anche al click sulle sezioni
 document.querySelectorAll('.section-header').forEach(header => {
 header.addEventListener('click', function() {
 // Aspetta che l'animazione CSS completi
 setTimeout(syncAriaExpanded, 100);
 });
 });
 */
 
 // Sincronizza anche al click sui btn-toggle-advanced
 document.querySelectorAll('.btn-toggle-advanced').forEach(btn => {
 btn.addEventListener('click', function() {
 // Aspetta che l'animazione CSS completi
 setTimeout(syncAriaExpanded, 100);
 });
 });
 
 console.log(' Sincronizzazione aria-expanded attiva');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30-fix34 — MOSTRA DIMENSIONI TESTO SUL CANVAS
 * ═══════════════════════════════════════════════════════════════
 * Risolve: non si sa quanto spazio occupa il testo sul canvas
 */
(function(){
 console.log(' Patch v30-fix34: Calcolo dimensioni testo...');
 
 // Funzione per calcolare e mostrare dimensioni testo (GLOBALE)
 window.showTextDimensions = function() {
 // Usa getSelectedLayer dalla funzione principale
 let selectedLayer = null;
 if (typeof window.getSelectedLayer === 'function') {
 selectedLayer = window.getSelectedLayer();
 } else if (window.state && window.state.layers && window.state.selectedIds && window.state.selectedIds.length > 0) {
 const id = window.state.selectedIds[0];
 selectedLayer = window.state.layers.find(l => l.id === id);
 } else if (window.selectedLayer) {
 selectedLayer = window.selectedLayer;
 }
 
 // Cerca il box delle dimensioni (ora è già nell'HTML)
 let dimInfo = document.querySelector('#text-dimensions-box');
 if (!dimInfo) {
 console.warn('Box dimensioni non trovato nell\'HTML');
 return;
 }
 
 // Prova anche a rilevare se c'è un layer testo dal DOM
 const textEditControls = document.getElementById('text-edit-controls');
 const isTextLayerVisible = textEditControls && textEditControls.style.display !== 'none';
 
 // Prova anche a vedere se c'è "Modificando:" nella description
 const editDescription = document.getElementById('edit-description');
 const isModifying = editDescription && editDescription.textContent.includes('Modificando:');
 
 // Se non c'è un livello testo selezionato, mostra messaggio
 if ((!selectedLayer || selectedLayer.type !== 'text') && !isTextLayerVisible && !isModifying) {
 const widthSpan = document.getElementById('text-dim-width');
 const heightSpan = document.getElementById('text-dim-height');
 const linesSpan = document.getElementById('text-dim-lines');
 
 if (widthSpan) widthSpan.textContent = 'Larghezza: -- (nessun testo)';
 if (heightSpan) heightSpan.textContent = 'Altezza: -- (nessun testo)';
 if (linesSpan) linesSpan.textContent = 'Righe di testo: -- (nessun testo)';
 return;
 }
 
 // Se selectedLayer non è disponibile ma i controlli testo sono visibili, 
 // prova a recuperare info dal DOM
 let text = '';
 let fontSize = 20;
 let fontFamily = 'Arial';
 let fontWeight = 400;
 let lineHeight = 1.2;
 
 if (selectedLayer && selectedLayer.type === 'text') {
 text = selectedLayer.text || '';
 fontSize = selectedLayer.fontSize || 20;
 fontFamily = selectedLayer.fontFamily || 'Arial';
 fontWeight = selectedLayer.fontWeight || 400;
 lineHeight = selectedLayer.lineHeight || 1.2;
 } else if (isTextLayerVisible || isModifying) {
 // Recupera dal DOM
 const textEditArea = document.getElementById('text-edit');
 const fontSizeInput = document.getElementById('font-size');
 const fontSelect = document.getElementById('ff');
 const fontWeightInput = document.getElementById('fw');
 const lineHeightInput = document.getElementById('line-height');
 
 if (textEditArea) text = textEditArea.value || '';
 if (fontSizeInput) fontSize = parseInt(fontSizeInput.value) || 20;
 if (fontSelect) fontFamily = fontSelect.value || 'Arial';
 if (fontWeightInput) fontWeight = parseInt(fontWeightInput.value) || 400;
 if (lineHeightInput) lineHeight = parseFloat(lineHeightInput.value) || 1.2;
 
 // Log ridotto per performance
 if (Math.random() < 0.1) { // Solo 10% dei log
 console.log(` Dati: text="${text.substring(0,20)}...", fontSize=${fontSize}`);
 }
 }
 
 if (!text) {
 const widthSpan = document.getElementById('text-dim-width');
 const heightSpan = document.getElementById('text-dim-height');
 const linesSpan = document.getElementById('text-dim-lines');
 
 if (widthSpan) widthSpan.textContent = 'Larghezza: 0 pixel (testo vuoto)';
 if (heightSpan) heightSpan.textContent = 'Altezza: 0 pixel (testo vuoto)';
 if (linesSpan) linesSpan.textContent = 'Righe di testo: 0 (testo vuoto)';
 return;
 }
 
 const canvas = document.getElementById('canvas') || document.getElementById('main-canvas');
 if (!canvas) return;
 
 const ctx = canvas.getContext('2d');
 if (!ctx) return;
 
 try {
 // Salva contesto
 ctx.save();
 
 // Imposta font come nel rendering
 ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
 
 // Misura il testo
 const lines = text.split('\n');
 
 let maxWidth = 0;
 lines.forEach(line => {
 const metrics = ctx.measureText(line);
 maxWidth = Math.max(maxWidth, metrics.width);
 });
 
 const textWidth = Math.ceil(maxWidth);
 const textHeight = Math.ceil(fontSize * lines.length * lineHeight);
 const numLines = lines.length;
 
 // Ripristina contesto
 ctx.restore();
 
 // Aggiorna il contenuto del box usando gli span con ID
 const widthSpan = document.getElementById('text-dim-width');
 const heightSpan = document.getElementById('text-dim-height');
 const linesSpan = document.getElementById('text-dim-lines');
 
 // Log ridotto (solo errori significativi)
 // console.log(' Debug span:', ...)
 
 if (widthSpan) {
 widthSpan.textContent = `Larghezza: ${textWidth} pixel`;
 }
 if (heightSpan) {
 heightSpan.textContent = `Altezza: ${textHeight} pixel`;
 }
 if (linesSpan) {
 if (numLines === 1) {
 linesSpan.textContent = 'Righe di testo: 1 (singola riga)';
 } else {
 linesSpan.textContent = `Righe di testo: ${numLines}`;
 }
 }
 
 // Log solo ogni tanto per debugging
 if (Math.random() < 0.05) {
 console.log(` Dimensioni: ${textWidth}×${textHeight}px, ${numLines} righe`);
 }
 
 } catch(e) {
 console.error('Errore calcolo dimensioni:', e);
 }
 }
 
 // Hook nella funzione di selezione layer
 const originalSelectLayer = window.selectLayer;
 if (originalSelectLayer) {
 window.selectLayer = function(...args) {
 const result = originalSelectLayer.apply(this, args);
 setTimeout(window.showTextDimensions, 100);
 setTimeout(window.showTextDimensions, 300);
 setTimeout(window.showTextDimensions, 500);
 return result;
 };
 }
 
 // Hook anche in displayLayerInfo se esiste
 const originalDisplayInfo = window.displayLayerInfo;
 if (originalDisplayInfo) {
 window.displayLayerInfo = function(...args) {
 const result = originalDisplayInfo.apply(this, args);
 setTimeout(window.showTextDimensions, 100);
 setTimeout(window.showTextDimensions, 300);
 return result;
 };
 }
 
 // Hook quando si applica modifica al testo
 const applyTextBtn = document.getElementById('btn-apply-text-edit');
 if (applyTextBtn) {
 applyTextBtn.addEventListener('click', function() {
 setTimeout(window.showTextDimensions, 200);
 });
 }
 
 // Hook quando cambia la dimensione del font
 const fontSizeInput = document.querySelector('#layer-font-size, input[id*="font"][id*="size"]');
 if (fontSizeInput) {
 fontSizeInput.addEventListener('change', function() {
 setTimeout(window.showTextDimensions, 100);
 });
 }
 
 // Observer per cambiamenti al selectedLayer e ai controlli visibili
 let lastSelectedLayer = null;
 let lastTextEditVisible = false;
 let updateDebounceTimer = null;
 let isUpdating = false; // Flag per prevenire ricorsione
 
 function checkAndUpdate() {
 // Previeni esecuzioni multiple simultanee
 if (isUpdating) return;
 
 const textEditControls = document.getElementById('text-edit-controls');
 const isTextEditVisible = textEditControls && textEditControls.style.display !== 'none';
 
 if (window.selectedLayer !== lastSelectedLayer || isTextEditVisible !== lastTextEditVisible) {
 lastSelectedLayer = window.selectedLayer;
 lastTextEditVisible = isTextEditVisible;
 
 // Debounce per evitare chiamate troppo frequenti
 clearTimeout(updateDebounceTimer);
 updateDebounceTimer = setTimeout(() => {
 isUpdating = true;
 try {
 window.showTextDimensions();
 } finally {
 isUpdating = false;
 }
 }, 150);
 }
 }
 
 // Ridotto da 300ms a 500ms per meno overhead
 setInterval(checkAndUpdate, 500);
 
 // Aggiorna anche quando clicchi su un layer
 const layerList = document.getElementById('layer-list');
 if (layerList) {
 layerList.addEventListener('click', function() {
 setTimeout(window.showTextDimensions, 150);
 });
 }
 
 // Aggiorna quando cambia il textarea del testo (con debouncing)
 const textEditArea = document.getElementById('text-edit');
 if (textEditArea) {
 let inputDebounceTimer = null;
 textEditArea.addEventListener('input', function() {
 clearTimeout(inputDebounceTimer);
 inputDebounceTimer = setTimeout(() => {
 if (!isUpdating) {
 isUpdating = true;
 try {
 window.showTextDimensions();
 } finally {
 isUpdating = false;
 }
 }
 }, 300); // Attendi 300ms dopo l'ultimo input
 });
 }
 
 // Esegui all'avvio con una singola chiamata ritardata
 setTimeout(() => {
 if (!isUpdating) {
 isUpdating = true;
 try {
 window.showTextDimensions();
 } finally {
 isUpdating = false;
 }
 }
 }, 500);
 
 // MutationObserver per rilevare quando cambiano i controlli di modifica (con debouncing)
 const editSection = document.getElementById('edit-section');
 if (editSection) {
 let mutationDebounceTimer = null;
 const observer = new MutationObserver(function(mutations) {
 // Debounce per evitare troppe chiamate
 clearTimeout(mutationDebounceTimer);
 mutationDebounceTimer = setTimeout(() => {
 if (!isUpdating) {
 isUpdating = true;
 try {
 window.showTextDimensions();
 } finally {
 isUpdating = false;
 }
 }
 }, 200);
 });
 
 observer.observe(editSection, {
 childList: true,
 subtree: true,
 attributes: true,
 attributeFilter: ['style']
 });
 }
 
 // Observer per quando appare "Modificando:"
 const editDescription = document.getElementById('edit-description');
 if (editDescription) {
 const descObserver = new MutationObserver(function() {
 if (editDescription.textContent && editDescription.textContent.includes('Modificando:')) {
 setTimeout(window.showTextDimensions, 100);
 }
 });
 
 descObserver.observe(editDescription, {
 childList: true,
 characterData: true,
 subtree: true
 });
 }
 
 console.log(' Calcolo dimensioni testo attivo');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30-fix35 — ELIMINA LETTURE "null" DURANTE NAVIGAZIONE TAB
 * ═══════════════════════════════════════════════════════════════
 * Risolve: NVDA legge "null" mentre si naviga con Tab
 */
(function(){
 console.log(' Patch v30-fix35: Eliminazione letture null...');
 
 function removeNullContent() {
 let fixed = 0;
 
 // Trova tutti gli elementi che potrebbero contenere "null"
 const allElements = document.querySelectorAll('*');
 
 allElements.forEach(el => {
 // Controlla aria-label
 if (el.getAttribute('aria-label') === 'null') {
 el.removeAttribute('aria-label');
 fixed++;
 console.log(' Rimosso aria-label="null" da', el.tagName);
 }
 
 // Controlla title
 if (el.getAttribute('title') === 'null') {
 el.removeAttribute('title');
 fixed++;
 console.log(' Rimosso title="null" da', el.tagName);
 }
 
 // Controlla alt (per immagini)
 if (el.tagName === 'IMG' && el.getAttribute('alt') === 'null') {
 el.setAttribute('alt', '');
 fixed++;
 console.log(' Rimosso alt="null" da IMG');
 }
 
 // Controlla placeholder (per input e textarea)
 if ((el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') && el.getAttribute('placeholder') === 'null') {
 el.removeAttribute('placeholder');
 fixed++;
 console.log(' Rimosso placeholder="null" da', el.tagName);
 }
 
 // Controlla textContent che sia esattamente "null"
 if (el.childNodes.length === 1 && 
 el.childNodes[0].nodeType === 3 && 
 el.textContent && 
 el.textContent.trim() === 'null') {
 el.textContent = '';
 fixed++;
 console.log(' Rimosso textContent="null" da', el.tagName);
 }
 });
 
 console.log(` Rimossi ${fixed} contenuti "null"`);
 }
 
 // Esegui all'avvio
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', removeNullContent);
 } else {
 removeNullContent();
 }
 
 // Observer per rimuovere "null" quando vengono aggiunti dinamicamente
 const observer = new MutationObserver(function(mutations) {
 mutations.forEach(function(mutation) {
 if (mutation.type === 'attributes') {
 const el = mutation.target;
 const attrName = mutation.attributeName;
 
 if ((attrName === 'aria-label' || attrName === 'title' || attrName === 'alt' || attrName === 'placeholder') &&
 el.getAttribute(attrName) === 'null') {
 if (attrName === 'alt' && el.tagName === 'IMG') {
 el.setAttribute(attrName, '');
 } else {
 el.removeAttribute(attrName);
 }
 console.log(` Rimosso ${attrName}="null" dinamicamente`);
 }
 } else if (mutation.type === 'childList' || mutation.type === 'characterData') {
 // Controlla i nuovi nodi aggiunti
 mutation.addedNodes.forEach(node => {
 if (node.nodeType === 1) { // Element
 removeNullContent();
 }
 });
 }
 });
 });
 
 observer.observe(document.body, {
 attributes: true,
 childList: true,
 subtree: true,
 characterData: true,
 attributeFilter: ['aria-label', 'title', 'alt', 'placeholder']
 });
 
 console.log(' Monitor "null" attivo');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30-fix36 — CORREGGE NUMERAZIONE SEZIONI
 * ═══════════════════════════════════════════════════════════════
 * Risolve: numerazione sezioni errata (7, 9, 8 invece di 7, 8, 9)
 */
(function(){
 console.log(' Patch v30-fix36: Correzione numerazione sezioni...');
 
 function fixSectionNumbers() {
 const panels = document.querySelectorAll('.section-panel');
 let corrected = 0;
 
 panels.forEach((panel, index) => {
 const sectionNumber = panel.querySelector('.section-number');
 if (sectionNumber && sectionNumber.textContent) {
 const correctNumber = index + 1;
 const currentNumber = sectionNumber.textContent.trim();
 
 if (currentNumber !== correctNumber.toString()) {
 sectionNumber.textContent = correctNumber;
 corrected++;
 console.log(` Sezione ${currentNumber} → ${correctNumber}`);
 }
 }
 });
 
 console.log(` Corrette ${corrected} numerazioni`);
 }
 
 // Esegui all'avvio
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', fixSectionNumbers);
 } else {
 fixSectionNumbers();
 }
 
 console.log(' Numerazione sezioni corretta');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30.3-fix39 — RIDUZIONE VERBOSITÀ MENU COLORI
 * ═══════════════════════════════════════════════════════════════
 * Durante lo scorrimento colori, non ripete "colore testo" ogni volta
 */
(function(){
 console.log(' Patch v30.3-fix39: Riduzione verbosità colori...');
 
 function reduceColorSelectVerbosity() {
 // Trova tutte le select che contengono colori
 const colorSelects = document.querySelectorAll(
 'select[id*="color"]:not([data-verbosity-reduced]), ' +
 'select[id*="Color"]:not([data-verbosity-reduced]), ' +
 'select[name*="color"]:not([data-verbosity-reduced]), ' +
 'select[name*="Color"]:not([data-verbosity-reduced])'
 );
 
 colorSelects.forEach(select => {
 });
 
 if (colorSelects.length > 0) {
 console.log(` Verbosità ridotta per ${colorSelects.length} select colori`);
 }
 }
 
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', reduceColorSelectVerbosity);
 } else {
 reduceColorSelectVerbosity();
 }
 
 // Applica fix anche ai nuovi elementi aggiunti dinamicamente
 const observer = new MutationObserver(function(mutations) {
 let needsUpdate = false;
 mutations.forEach(function(mutation) {
 if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
 mutation.addedNodes.forEach(node => {
 if (node.nodeType === 1) { // Element node
 // Controlla se il nodo o i suoi figli contengono select di colori
 const hasColorSelect = node.matches && node.matches('select[id*="color"], select[id*="Color"]');
 const childColorSelects = node.querySelectorAll && node.querySelectorAll('select[id*="color"], select[id*="Color"]');
 if (hasColorSelect || (childColorSelects && childColorSelects.length > 0)) {
 needsUpdate = true;
 }
 }
 });
 }
 });
 if (needsUpdate) {
 reduceColorSelectVerbosity();
 }
 });
 
 observer.observe(document.body, {
 childList: true,
 subtree: true
 });
 
 console.log(' Verbosità menu colori ridotta (con MutationObserver)');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * PATCH v30.3-fix40 — INVIO NEL TEXTAREA VA A CAPO
 * ═══════════════════════════════════════════════════════════════
 * Premendo Invio nel textarea del testo, il cursore va a capo
 */
(function(){
 console.log(' Patch v30.3-fix40: Invio nel textarea va a capo...');
 
 function fixTextareaEnterKey() {
 const textareas = document.querySelectorAll('textarea:not([data-enter-fixed])');
 
 textareas.forEach(textarea => {
 textarea.setAttribute('data-enter-fixed', 'true');
 
 // Il comportamento di default del textarea è già a capo
 // Intercettiamo l'evento nella fase di capture per fermare la propagazione
 textarea.addEventListener('keydown', function(e) {
 if (e.key === 'Enter' && !e.ctrlKey && !e.metaKey) {
 // Ferma la propagazione per evitare che altri listener interferiscano
 e.stopPropagation();
 // NON fare preventDefault - lascia che vada a capo naturalmente
 }
 }, true); // use capture
 
 console.log(` Textarea configurato per a capo con Invio`);
 });
 }
 
 if (document.readyState === 'loading') {
 document.addEventListener('DOMContentLoaded', fixTextareaEnterKey);
 } else {
 fixTextareaEnterKey();
 }
 
 // Applica fix anche ai nuovi textarea aggiunti dinamicamente
 const observer = new MutationObserver(function(mutations) {
 let needsUpdate = false;
 mutations.forEach(function(mutation) {
 if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {
 mutation.addedNodes.forEach(node => {
 if (node.nodeType === 1) { // Element node
 // Controlla se il nodo è un textarea o contiene textarea
 const isTextarea = node.matches && node.matches('textarea:not([data-enter-fixed])');
 const childTextareas = node.querySelectorAll && node.querySelectorAll('textarea:not([data-enter-fixed])');
 if (isTextarea || (childTextareas && childTextareas.length > 0)) {
 needsUpdate = true;
 }
 }
 });
 }
 });
 if (needsUpdate) {
 fixTextareaEnterKey();
 }
 });
 
 observer.observe(document.body, {
 childList: true,
 subtree: true
 });
 
 console.log(' Invio nel textarea va a capo (con MutationObserver)');
})();
</script>

<script>
// PATCH v30.3-fix41 COMPLETAMENTE RIMOSSO
// Il sistema di esplorazione è gestito dal listener principale (righe 8468-8700)
// con state.exploreMode attivato da Ctrl+E
console.log(" Sistema esplorazione gestito da listener principale (righe 8468-8700)");
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * INTEGRAZIONE GEMINI AI - FASE 1: "VEDERE"
 * ═══════════════════════════════════════════════════════════════
 * Funzionalità implementate:
 * 1. Descrizione immagine al caricamento
 * 2. Analisi completa del canvas (Ctrl+I)
 * 3. Test connessione API
 * * Configurazione: Richiede API key Google Gemini
 * ═══════════════════════════════════════════════════════════════
 */
(function() {
 console.log(' Inizializzazione Gemini AI Integration...');
 
 // ==================== CONFIGURAZIONE ====================
 const GEMINI_API_ENDPOINT = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent';
 
 // Memorizzazione sicura dell'API key (localStorage)
 /**
 * v39.0: Salva API key con validazione formato
 */
 function saveApiKey(key) {
 try {
 const trimmed = key.trim();
 
 // VALIDAZIONE FORMATO
 if (trimmed.length < 20) {
 throw new Error('API key troppo corta (minimo 20 caratteri)');
 }
 
 if (!trimmed.startsWith('AIza')) {
 throw new Error('API key non valida (deve iniziare con "AIza")');
 }
 
 localStorage.setItem('gemini_api_key', trimmed);
 console.log(' API key validata e salvata');
 return true;
 } catch(e) {
 console.error('Errore salvataggio API key:', e);
 showApiStatus(`Errore: ${e.message}`, 'error');
 return false;
 }
 }
 
 /**
 * v39.0: Recupera API key con validazione formato
 */
 function getApiKey() {
 const input = document.getElementById('gemini-api-key');
 let key = input ? input.value.trim() : '';
 
 // Se non c'è nell'input, prova localStorage
 if (!key) {
 try {
 key = localStorage.getItem('gemini_api_key') || '';
 } catch(e) {
 console.warn('Impossibile leggere localStorage:', e);
 return '';
 }
 }
 
 // VALIDAZIONE FORMATO
 if (!key) return '';
 
 // Le chiavi Gemini iniziano con "AIza" e sono ~39 caratteri
 if (key.length < 20) {
 console.warn('️ API key troppo corta (min 20 caratteri)');
 return '';
 }
 
 if (!key.startsWith('AIza')) {
 console.warn('️ API key non ha formato valido (deve iniziare con AIza)');
 return '';
 }
 
 return key;
 }
 
 /**
 * v39.0: Show API status con auto-hide
 */
 let statusTimeout = null;
 
 function showApiStatus(message, type = 'info', autoHideSec = 5) {
 const statusDiv = document.getElementById('api-status');
 if (!statusDiv) return;
 
 const colors = {
 success: '#10b981',
 error: '#ef4444',
 info: '#3b82f6',
 warning: '#f59e0b'
 };
 
 // PULISCI TIMEOUT PRECEDENTE
 if (statusTimeout) {
 clearTimeout(statusTimeout);
 statusTimeout = null;
 }
 
 statusDiv.style.display = 'block';
 statusDiv.style.background = `${colors[type]}20`;
 statusDiv.style.border = `1px solid ${colors[type]}`;
 statusDiv.style.color = colors[type];
 statusDiv.textContent = message;
 
 // Annuncia vocalmente
 const speak = window.speak || window.announce || function(text) {
 const sr = document.getElementById('sr-polite');
 if (sr) {
 sr.textContent = '';
 setTimeout(() => { sr.textContent = text; }, 50);
 }
 };
 speak(message);
 
 // AUTO-HIDE dopo N secondi (solo per success/info)
 if ((type === 'success' || type === 'info') && autoHideSec > 0) {
 statusTimeout = setTimeout(() => {
 statusDiv.style.display = 'none';
 statusTimeout = null;
 }, autoHideSec * 1000);
 }
 }
 
 // ==================== FUNZIONI CORE API ====================
 
 /**
 * Converte un file o dataURL in base64 puro
 */
 function getBase64FromImage(imageSource) {
 return new Promise((resolve, reject) => {
 if (typeof imageSource === 'string') {
 // È già un dataURL
 const base64 = imageSource.split(',')[1];
 resolve(base64);
 } else if (imageSource instanceof File || imageSource instanceof Blob) {
 // È un file, leggi con FileReader
 const reader = new FileReader();
 reader.onload = () => {
 const base64 = reader.result.split(',')[1];
 resolve(base64);
 };
 reader.onerror = reject;
 reader.readAsDataURL(imageSource);
 } else {
 reject(new Error('Formato immagine non supportato'));
 }
 });
 }
 
 /**
 * v39.0: Chiamata API a Gemini Vision con timeout, validation e error handling
 */
 async function callGeminiVision(imageData, prompt, timeoutMs = 60000) {
 const apiKey = getApiKey();
 
 if (!apiKey) {
 throw new Error(ERROR_MESSAGES.NO_API_KEY);
 }
 
 // VALIDAZIONE API KEY (double-check)
 if (apiKey.length < 20 || !apiKey.startsWith('AIza')) {
 throw new Error(ERROR_MESSAGES.INVALID_API_KEY);
 }
 
 const base64Image = await getBase64FromImage(imageData);
 
 const requestBody = {
 contents: [{
 parts: [
 { text: prompt },
 { 
 inline_data: { 
 mime_type: "image/jpeg", 
 data: base64Image 
 } 
 }
 ]
 }]
 };
 
 // ABORT CONTROLLER per timeout
 const controller = new AbortController();
 const timeoutId = setTimeout(() => {
 controller.abort();
 console.warn(`️ Request aborted dopo ${timeoutMs}ms timeout`);
 }, timeoutMs);
 
 try {
 const response = await fetch(`${GEMINI_API_ENDPOINT}?key=${apiKey}`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(requestBody),
 signal: controller.signal // Aggiungi abort signal
 });
 
 clearTimeout(timeoutId); // Pulisci timeout se successo
 
 if (!response.ok) {
 const errorData = await response.json().catch(() => ({}));
 
 // GESTIONE ERRORI SPECIFICI USER-FRIENDLY
 if (response.status === 429) {
 throw new Error(ERROR_MESSAGES.RATE_LIMIT);
 }
 if (response.status === 401 || response.status === 403) {
 throw new Error(ERROR_MESSAGES.INVALID_API_KEY);
 }
 if (response.status === 400) {
 const msg = errorData.error?.message || 'immagine troppo grande?';
 throw new Error('Richiesta non valida: ' + msg);
 }
 if (response.status === 413) {
 throw new Error(ERROR_MESSAGES.IMAGE_TOO_LARGE);
 }
 
 throw new Error(errorData.error?.message || `Errore API: ${response.status}`);
 }
 
 const data = await response.json();
 
 if (!data.candidates || !data.candidates[0]) {
 throw new Error(ERROR_MESSAGES.INVALID_RESPONSE);
 }
 
 return data.candidates[0].content.parts[0].text;
 
 } catch(error) {
 clearTimeout(timeoutId); // Pulisci anche in caso errore
 
 // GESTIONE ABORT
 if (error.name === 'AbortError') {
 throw new Error(`${ERROR_MESSAGES.TIMEOUT} Richiesta ha impiegato più di ${timeoutMs/1000}s.`);
 }
 
 // GESTIONE NETWORK ERROR
 if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
 throw new Error(ERROR_MESSAGES.NETWORK_ERROR);
 }
 
 throw error; // Rilancia altri errori
 }
 }
 
 /**
 * v39.0: Ottimizza immagine canvas per API (riduce dimensioni se troppo grande)
 */
 function getOptimizedCanvasImage(canvas, maxDimension = 2048, quality = 0.85) {
 const width = canvas.width;
 const height = canvas.height;
 
 // Se già piccolo, usa direttamente
 if (width <= maxDimension && height <= maxDimension) {
 return canvas.toDataURL('image/jpeg', quality);
 }
 
 // CALCOLA RESIZE MANTENENDO ASPECT RATIO
 const scale = Math.min(maxDimension / width, maxDimension / height);
 const newWidth = Math.floor(width * scale);
 const newHeight = Math.floor(height * scale);
 
 console.log(` Ridimensiono canvas per API: ${width}x${height} → ${newWidth}x${newHeight} (${scale.toFixed(2)}x)`);
 
 // CREA CANVAS TEMPORANEO
 const tempCanvas = document.createElement('canvas');
 tempCanvas.width = newWidth;
 tempCanvas.height = newHeight;
 const ctx = tempCanvas.getContext('2d');
 
 // ALTA QUALITÀ RESIZE
 ctx.imageSmoothingEnabled = true;
 ctx.imageSmoothingQuality = 'high';
 
 // Disegna canvas originale ridimensionato
 ctx.drawImage(canvas, 0, 0, newWidth, newHeight);
 
 const dataURL = tempCanvas.toDataURL('image/jpeg', quality);
 
 // CLEANUP
 tempCanvas.width = 0;
 tempCanvas.height = 0;
 
 // VERIFICA SIZE FINALE
 const sizeKB = Math.round((dataURL.length * 3/4) / 1024);
 console.log(` Dimensione immagine finale: ${sizeKB}KB`);
 
 if (sizeKB > 15000) { // 15MB warning
 console.warn('️ Immagine molto grande, timeout possibile');
 }
 
 return dataURL;
 }
 
 /**
 * v39.0: Rileva formato canvas per Safe Zone analysis
 */
 function detectCanvasFormat(width, height) {
 const aspectRatio = (width / height).toFixed(2);
 
 // Formati esatti
 if (width === 1080 && height === 1080) {
 return 'Formato: Instagram Post 1:1 (1080x1080px)';
 }
 if (width === 1080 && height === 1920) {
 return 'Formato: Instagram/TikTok Story 9:16 (1080x1920px)';
 }
 if (width === 1200 && height === 630) {
 return 'Formato: Facebook/LinkedIn Link Preview (1200x630px)';
 }
 if (width === 1080 && height === 1350) {
 return 'Formato: Instagram Ritratto 4:5 (1080x1350px)';
 }
 
 // Formati approssimativi
 if (Math.abs(aspectRatio - 1) < 0.1) {
 return `Formato: Quadrato ~1:1 (${width}x${height}px) - Simile Instagram Post`;
 }
 if (aspectRatio > 1.7 && aspectRatio < 1.8) {
 return `Formato: Orizzontale ~16:9 (${width}x${height}px) - Simile YouTube`;
 }
 if (aspectRatio > 0.55 && aspectRatio < 0.58) {
 return `Formato: Verticale ~9:16 (${width}x${height}px) - Simile Story`;
 }
 
 return `Formato: ${width}x${height}px (ratio ${aspectRatio})`;
 }
 
 /**
 * v39.0: Build prompt ottimizzato per Safe Zone (riduce token cost)
 */
 function buildCanvasAnalysisPrompt(formatInfo) {
 let prompt = `Analizza questa composizione grafica per social media.

${formatInfo}

Fornisci:
1. Descrizione breve (sfondo, elementi principali, colori, stile)
2. Analisi Safe Zone per il formato rilevato:`;

 // AGGIUNGI SOLO LE SAFE ZONE RILEVANTI
 if (formatInfo.includes('Instagram Story') || formatInfo.includes('TikTok Story') || formatInfo.includes('9:16')) {
 prompt += `
 - Testo/CTA nella zona sicura centrale (evita top 14%, bottom 20%)? /
 - UI Instagram/TikTok coprirebbe elementi? /`;
 } 
 else if (formatInfo.includes('Instagram Post') || formatInfo.includes('1:1')) {
 prompt += `
 - Elementi importanti entro margine 10% dai bordi? /
 - Feed preview (primi 400px) mostra contenuto essenziale? /`;
 }
 else if (formatInfo.includes('YouTube') || formatInfo.includes('16:9')) {
 prompt += `
 - Titolo/CTA visibile entro safe area centrale 80%? /
 - Elementi importanti non coperti da overlay? /`;
 }
 else {
 // Generic social safe zone
 prompt += `
 - Elementi importanti entro margine 10% dai bordi? /
 - Testo leggibile su mobile? /`;
 }

 prompt += `
3. Rischi principali (se presenti): elementi fuori safe zone, testo coperto, CTA non visibile
4. 1-2 raccomandazioni immediate

Sii specifico ma conciso. Usa ️ per problemi critici.`;

 return prompt;
 }
 
 /**
 * Funzione di annuncio vocale per Gemini AI
 * (Definita all'inizio dello script principale)
 */
 // announceGemini è già definita globalmente all'inizio del file
 
 // ==================== FEATURE 1: DESCRIVI IMMAGINE CARICATA ====================
 
 let uploadedImageData = null;
 let uploadedBgImageData = null;
 
 // Monitora il caricamento immagine principale
 const imageUpload = document.getElementById('image-upload');
 const btnDescribeUpload = document.getElementById('btn-describe-upload');
 
 if (imageUpload && btnDescribeUpload) {
 imageUpload.addEventListener('change', function(e) {
 const file = e.target.files[0];
 if (file) {
 uploadedImageData = file;
 btnDescribeUpload.style.display = 'block';
 announceGemini('Immagine caricata. Premi il pulsante Descrivi per analizzarla con AI.');
 }
 });
 
 btnDescribeUpload.addEventListener('click', async function() {
 if (!uploadedImageData) {
 // RIMOSSO (ridondante): announceGemini('Nessuna immagine da descrivere.', true);
 return;
 }
 
 try {
 announceGemini('Analisi in corso con Gemini AI, attendi...', true);
 btnDescribeUpload.disabled = true;
 btnDescribeUpload.textContent = ' Analisi in corso...';
 
 const description = await callGeminiVision(
 uploadedImageData,
 'Descrivi questa immagine in modo dettagliato e accurato per un utente non vedente. ' +
 'Indica: oggetti principali, colori dominanti, posizione degli elementi (es. centro, alto, basso, sinistra, destra), ' +
 'stile visivo, mood o atmosfera. Sii specifico e descrittivo.'
 );
 
 // RIMOSSO (ridondante): announceGemini(`Descrizione immagine: ${description}`, true);
 
 } catch(error) {
 console.error('Errore descrizione immagine:', error);
 announceGemini(`Errore: ${error.message}`, true);
 } finally {
 btnDescribeUpload.disabled = false;
 btnDescribeUpload.textContent = ' Descrivi questa Immagine con AI';
 }
 });
 }
 
 // Monitora il caricamento immagine sfondo
 const bgImageUpload = document.getElementById('bg-image-upload');
 const btnDescribeBgUpload = document.getElementById('btn-describe-bg-upload');
 
 if (bgImageUpload && btnDescribeBgUpload) {
 bgImageUpload.addEventListener('change', function(e) {
 const file = e.target.files[0];
 if (file) {
 uploadedBgImageData = file;
 btnDescribeBgUpload.style.display = 'block';
 announceGemini('Immagine sfondo caricata. Premi il pulsante Descrivi per analizzarla con AI.');
 }
 });
 
 btnDescribeBgUpload.addEventListener('click', async function() {
 if (!uploadedBgImageData) {
 // RIMOSSO (ridondante): announceGemini('Nessuna immagine da descrivere.', true);
 return;
 }
 
 try {
 announceGemini('Analisi immagine sfondo in corso con Gemini AI, attendi...', true);
 btnDescribeBgUpload.disabled = true;
 btnDescribeBgUpload.textContent = ' Analisi in corso...';
 
 const description = await callGeminiVision(
 uploadedBgImageData,
 'Descrivi questa immagine che verrà usata come sfondo. ' +
 'Indica: colori dominanti, elementi principali, stile visivo, ' +
 'se è adatta come sfondo (contrasto, texture). Sii specifico.'
 );
 
 // RIMOSSO (ridondante): announceGemini(`Descrizione sfondo: ${description}`, true);
 
 } catch(error) {
 console.error('Errore descrizione sfondo:', error);
 announceGemini(`Errore: ${error.message}`, true);
 } finally {
 btnDescribeBgUpload.disabled = false;
 btnDescribeBgUpload.textContent = ' Descrivi questa Immagine con AI';
 }
 });
 }
 
 // ==================== FEATURE 2: DESCRIVI CANVAS ====================
 
 const btnDescribeCanvas = document.getElementById('btn-describe-canvas');
 const canvas = document.getElementById('canvas');
 
 if (btnDescribeCanvas && canvas) {
 // Array per salvare la conversazione
 let chatHistory = [];
 let currentCanvasImage = null;
 
 // Funzione per creare/mostrare il modale della chat
 function showChatModal(initialDescription) {
 // Rimuovi chat esistente se presente
 let existingModal = document.getElementById('gemini-chat-modal');
 if (existingModal) {
 existingModal.remove();
 }
 
 // Funzione helper per escape HTML
 function escapeHtml(text) {
 const div = document.createElement('div');
 div.textContent = text;
 return div.innerHTML;
 }
 
 // Escape della descrizione iniziale
 const escapedInitialDesc = escapeHtml(initialDescription);
 
 // Crea il modale
 const modal = document.createElement('div');
 modal.id = 'gemini-chat-modal';
 modal.style.cssText = `
 position: fixed;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 background: rgba(0, 0, 0, 0.7);
 display: flex;
 align-items: center;
 justify-content: center;
 z-index: 10000;
 padding: 20px;
 `;
 
 const chatContainer = document.createElement('div');
 chatContainer.style.cssText = `
 background: white;
 border-radius: 12px;
 width: 100%;
 max-width: 800px;
 max-height: 90vh;
 display: flex;
 flex-direction: column;
 box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
 `;
 
 chatContainer.innerHTML = `
 <div style="padding: 20px; border-bottom: 2px solid #e5e7eb; display: flex; justify-content: space-between; align-items: center;">
 <h2 style="margin: 0; color: #1f2937; font-size: 20px;"> Chat con Gemini - Analisi Canvas</h2>
 <button id="close-chat-modal" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #6b7280; padding: 0; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 6px;" aria-label="Chiudi chat" title="Chiudi chat (Esc)">×</button>
 </div>
 
 <div id="chat-messages" style="flex: 1; overflow-y: auto; padding: 20px; display: flex; flex-direction: column; gap: 16px; background: #f9fafb;" role="log" aria-live="off" aria-relevant="additions">
 <div style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 16px; border-radius: 12px; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);">
 <strong style="display: block; margin-bottom: 8px;"> Gemini:</strong>
 <div style="line-height: 1.6; white-space: pre-wrap;">${escapedInitialDesc}</div>
 </div>
 </div>
 
 <div style="padding: 20px; border-top: 2px solid #e5e7eb; background: white; border-radius: 0 0 12px 12px;">
 <div style="display: flex; gap: 12px; align-items: flex-end;">
 <div class="flex-1">
 <label for="chat-input" style="display: block; margin-bottom: 8px; font-weight: 600; color: #374151; font-size: 14px;">La tua domanda:</label>
 <textarea id="chat-input" placeholder="Chiedimi qualsiasi cosa sul canvas... (es: 'Come posso migliorare i colori?', 'Il testo è leggibile?')" style="width: 100%; padding: 12px; border: 2px solid #e5e7eb; border-radius: 8px; font-family: inherit; font-size: 14px; resize: vertical; min-height: 60px; max-height: 150px;" rows="2"></textarea>
 </div>
 <button id="send-chat-message" style="padding: 12px 24px; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 14px; white-space: nowrap; height: fit-content; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3); transition: all 0.2s;" aria-label="Invia messaggio">
 Invia
 </button>
 </div>
 <p style="margin: 12px 0 0 0; font-size: 12px; color: #6b7280;">
 <strong>Suggerimenti:</strong> Chiedi consigli sui colori, layout, leggibilità, miglioramenti possibili, o qualsiasi dubbio sulla tua composizione!
 </p>
 </div>
 `;
 
 modal.appendChild(chatContainer);
 document.body.appendChild(modal);
 
 const chatMessages = document.getElementById('chat-messages');
 const chatInput = document.getElementById('chat-input');
 const sendButton = document.getElementById('send-chat-message');
 const closeButton = document.getElementById('close-chat-modal');
 
 // Focus sull'input
 setTimeout(() => chatInput.focus(), 100);
 
 // Funzione per aggiungere messaggio alla chat
 function addMessage(text, isUser = false) {
 const messageDiv = document.createElement('div');
 messageDiv.style.cssText = isUser 
 ? 'background: #10b981; color: white; padding: 16px; border-radius: 12px; align-self: flex-end; max-width: 80%; box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);'
 : 'background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; padding: 16px; border-radius: 12px; align-self: flex-start; max-width: 85%; box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);';
 
 // Escape HTML per sicurezza, ma preserva newline
 const escapedText = escapeHtml(text);
 
 messageDiv.innerHTML = `
 <strong style="display: block; margin-bottom: 8px;">${isUser ? ' Tu:' : ' Gemini:'}</strong>
 <div style="line-height: 1.6; white-space: pre-wrap;">${escapedText}</div>
 `;
 
 chatMessages.appendChild(messageDiv);
 chatMessages.scrollTop = chatMessages.scrollHeight;
 
 // Annuncia per screen reader
 announceGemini(`${isUser ? 'Tu' : 'Gemini'}: ${text}`, 'polite');
 }
 
 // Funzione per inviare messaggio
 async function sendMessage() {
 const userMessage = chatInput.value.trim();
 if (!userMessage) return;
 
 // Aggiungi messaggio utente
 addMessage(userMessage, true);
 chatInput.value = '';
 
 // v39.0: Aggiungi alla cronologia con timestamp e LIMIT
 chatHistory.push({ role: 'user', text: userMessage, timestamp: Date.now() });
 
 // TRIM automatico se supera limite
 if (chatHistory.length > 50) {
 const removed = chatHistory.length - 50;
 chatHistory = chatHistory.slice(-50);
 console.log(`️ Rimossi ${removed} messaggi vecchi dalla cronologia chat`);
 }
 
 // Disabilita input durante l'elaborazione
 sendButton.disabled = true;
 chatInput.disabled = true;
 sendButton.textContent = ' Elaborazione...';
 
 try {
 // Costruisci prompt con contesto della conversazione
 let conversationContext = chatHistory.slice(-6).map(msg => 
 `${msg.role === 'user' ? 'Utente' : 'Assistente'}: ${msg.text}`
 ).join('\n\n');
 
 const fullPrompt = `Stai analizzando una composizione grafica in un editor. Ecco la conversazione finora:\n\n${conversationContext}\n\nRispondi alla domanda dell'utente in modo chiaro, pratico e specifico rispetto alla grafica visualizzata.`;
 
 // Chiama Gemini con l'immagine del canvas e il contesto
 const response = await callGeminiVision(currentCanvasImage, fullPrompt);
 
 // Aggiungi risposta alla chat
 addMessage(response, false);
 
 // v39.0: Aggiungi risposta con timestamp e TRIM
 chatHistory.push({ role: 'assistant', text: response, timestamp: Date.now() });
 
 // TRIM automatico
 if (chatHistory.length > 50) {
 chatHistory = chatHistory.slice(-50);
 console.log(`️ Chat history trimmed to 50 messages`);
 }
 
 } catch(error) {
 console.error('Errore chat:', error);
 addMessage(`Errore: ${error.message}. Riprova.`, false);
 } finally {
 sendButton.disabled = false;
 chatInput.disabled = false;
 sendButton.textContent = ' Invia';
 chatInput.focus();
 }
 }
 
 // Event listeners
 sendButton.addEventListener('click', sendMessage);
 chatInput.addEventListener('keydown', (e) => {
 if (e.key === 'Enter' && !e.shiftKey) {
 e.preventDefault();
 sendMessage();
 }
 });
 
 // Chiudi modale
 function closeModal() {
 modal.remove();
 // Rimuovi handler ESC
 document.removeEventListener('keydown', escHandler);
 announceGemini('Chat con Gemini chiusa', 'polite');
 }
 
 // Handler ESC dichiarato fuori per poterlo rimuovere correttamente
 function escHandler(e) {
 if (e.key === 'Escape') {
 closeModal();
 }
 }
 
 closeButton.addEventListener('click', closeModal);
 modal.addEventListener('click', (e) => {
 if (e.target === modal) closeModal();
 });
 
 document.addEventListener('keydown', escHandler);
 
 announceGemini('Chat con Gemini aperta. Fai le tue domande sul canvas!', 'assertive');
 }
 
 // v39.0: Variabili globali per race condition prevention
 let isAnalysisInProgress = false;
 
 async function describeCanvas() {
 // GUARD CLAUSE - Previene click multipli
 if (isAnalysisInProgress) {
 announceGemini('Analisi già in corso, attendere...', 'assertive');
 return;
 }
 
 try {
 isAnalysisInProgress = true;
 announceGemini('Analisi canvas in corso con Gemini AI, attendi...', true);
 btnDescribeCanvas.disabled = true;
 btnDescribeCanvas.textContent = ' Analisi...';
 
 // Assicura che il canvas sia completamente renderizzato prima della cattura
 renderSync();
 
 // v39.0: Ottimizza immagine per API (max 2048px, riduce timeout risk)
 currentCanvasImage = getOptimizedCanvasImage(canvas, 2048, 0.85);
 
 // v39.0: USA FUNZIONE RILEVAMENTO FORMATO
 const formatInfo = detectCanvasFormat(canvas.width, canvas.height);
 
 // v39.0: USA PROMPT OTTIMIZZATO (riduce token cost)
 const prompt = buildCanvasAnalysisPrompt(formatInfo);
 
 const description = await callGeminiVision(currentCanvasImage, prompt, 60000);
 
 // Reset cronologia e inizia con la descrizione
 chatHistory = [{ role: 'assistant', text: description, timestamp: Date.now() }];
 
 // Apri la chat con la descrizione iniziale
 showChatModal(description);
 
 } catch(error) {
 console.error('Errore descrizione canvas:', error);
 
 // v39.0: MESSAGGI USER-FRIENDLY
 let userMessage = error.message;
 if (error.message.includes('API key') || error.message.includes('AIza')) {
 userMessage = ERROR_MESSAGES.NO_API_KEY;
 } else if (error.message.includes('Rate limit') || error.message.includes('429')) {
 userMessage = ERROR_MESSAGES.RATE_LIMIT;
 } else if (error.message.includes('Timeout') || error.message.includes('AbortError')) {
 userMessage = ERROR_MESSAGES.TIMEOUT;
 } else if (error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
 userMessage = ERROR_MESSAGES.NETWORK_ERROR;
 }
 
 announceGemini(`Errore: ${userMessage}`, 'assertive');
 
 } finally {
 isAnalysisInProgress = false; // RILASCIA LOCK
 btnDescribeCanvas.disabled = false;
 btnDescribeCanvas.textContent = ' Descrivi Canvas';
 }
 }
 
 btnDescribeCanvas.addEventListener('click', describeCanvas);
 
 // Shortcut Ctrl+I
 document.addEventListener('keydown', function(e) {
 if ((e.ctrlKey || e.metaKey) && e.key === 'i') {
 e.preventDefault();
 describeCanvas();
 }
 });
 }
 
 // ==================== FEATURE 3: DESCRIVI DISEGNO VETTORIALE ====================
 
 const btnDescribeVector = document.getElementById('btn-describe-vector');
 
 if (btnDescribeVector) {
 async function describeVectorDrawing() {
 let tempCanvas = null; // v39.0: Dichiarato fuori per cleanup nel finally
 
 try {
 // 1. Controlla se esiste almeno un layer vettoriale valido
 const state = window.state || window.APP?.state;
 if (!state || !state.layers || state.layers.length === 0) {
 announceGemini('Errore: nessun disegno vettoriale da descrivere. Crea prima un disegno usando la modalità Disegno Vettoriale (Ctrl+P).', 'assertive');
 return;
 }
 
 // Trova layer poligonali (type: 'polygon') con almeno 3 punti
 const vectorLayers = state.layers.filter(layer => 
 layer.type === 'polygon' && 
 layer.polygonPoints && 
 layer.polygonPoints?.length >= 3 &&
 layer.visible !== false
 );
 
 if (vectorLayers.length === 0) {
 // RIMOSSO (ridondante): announceGemini('Errore: nessun disegno vettoriale valido da descrivere. Crea prima una forma usando la modalità Disegno Vettoriale (Ctrl+P + frecce + Invio).', 'assertive');
 return;
 }
 
 // 2. Crea un canvas temporaneo per disegnare solo i layer vettoriali
 announceGemini(`Analisi di ${vectorLayers.length} disegno${vectorLayers.length > 1 ? 'i' : ''} vettoriale${vectorLayers.length > 1 ? 'i' : ''} in corso con Gemini AI, attendi...`, 'assertive');
 btnDescribeVector.disabled = true;
 btnDescribeVector.textContent = ' Analisi...';
 
 // v39.0: Crea canvas temporaneo (verrà ripulito nel finally)
 tempCanvas = document.createElement('canvas');
 const mainCanvas = document.getElementById('canvas');
 tempCanvas.width = mainCanvas.width;
 tempCanvas.height = mainCanvas.height;
 const ctx = tempCanvas.getContext('2d');
 
 // Sfondo bianco
 ctx.fillStyle = '#ffffff';
 ctx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
 
 // Disegna solo i layer vettoriali
 vectorLayers.forEach(layer => {
 if (!layer.polygonPoints || layer.polygonPoints?.length < 3) return;
 
 ctx.save();
 
 // Applica opacità
 ctx.globalAlpha = (layer.opacity !== undefined ? layer.opacity : 100) / 100;
 
 // Applica rotazione se presente
 if (layer.rotation) {
 const centerX = layer.x + layer.width / 2;
 const centerY = layer.y + layer.height / 2;
 ctx.translate(centerX, centerY);
 ctx.rotate((layer.rotation * Math.PI) / 180);
 ctx.translate(-centerX, -centerY);
 }
 
 // Disegna il poligono
 ctx.beginPath();
 const points = layer.polygonPoints;
 ctx.moveTo(layer.x + points[0].x, layer.y + points[0].y);
 for (let i = 1; i < points.length; i++) {
 ctx.lineTo(layer.x + points[i].x, layer.y + points[i].y);
 }
 
 // Chiudi il percorso solo se l'opzione è attiva
 if (layer.closePath !== false) {
 ctx.closePath();
 }
 
 // Riempimento (solo se la forma è chiusa)
 if (layer.closePath !== false && layer.color) {
 ctx.fillStyle = layer.color;
 ctx.fill();
 }
 
 // Bordo
 if (layer.useStroke && layer.stroke) {
 ctx.strokeStyle = layer.stroke.color || '#000000';
 ctx.lineWidth = layer.stroke.width || 2;
 ctx.stroke();
 }
 
 ctx.restore();
 });
 
 // v39.0: Ottimizza immagine per API (riduce size + timeout risk)
 const vectorImageData = getOptimizedCanvasImage(tempCanvas, 2048, 0.9);
 
 // v39.0: Prompt con FIX marker interpretation
 const prompt = vectorLayers.length === 1
 ? 'Analizza questo disegno vettoriale (poligono/linea) e descrivi:\n' +
 '1. La forma generale che sembra rappresentare (es: triangolo, stella, freccia, casa, cuore, animale, lettera, etc.)\n' +
 '2. Numero di lati/vertici e caratteristiche geometriche principali\n' +
 '3. Colori utilizzati (riempimento e bordo se presente)\n' +
 '4. Eventuali simmetrie o pattern riconoscibili\n' +
 '5. A cosa potrebbe assomigliare o cosa potrebbe rappresentare\n\n' +
 '️ IMPORTANTE: I punti finali visibili sono semplici estremità della linea/forma, NON interpretarli come marcatori, pallini o elementi decorativi separati. Descrivi solo la forma creata dalle linee.\n\n' +
 'Sii specifico e descrittivo, aiutando l\'utente a capire che forma ha creato.'
 : `Analizza questi ${vectorLayers.length} disegni vettoriali (poligoni/linee) e per ciascuno descrivi:\n` +
 '1. La forma generale che sembra rappresentare\n' +
 '2. Caratteristiche geometriche principali (lati, angoli, proporzioni)\n' +
 '3. Colori utilizzati\n' +
 '4. Posizione relativa rispetto agli altri disegni\n' +
 '5. Se insieme formano un pattern o una composizione riconoscibile\n\n' +
 '️ IMPORTANTE: I punti finali visibili sono semplici estremità delle linee/forme, NON interpretarli come marcatori, pallini o elementi decorativi separati. Descrivi solo le forme create dalle linee.\n\n' +
 'Sii specifico e descrittivo.';
 
 const description = await callGeminiVision(vectorImageData, prompt, 60000); // timeout 60s
 
 // 4. Mostra la descrizione
 // RIMOSSO (ridondante): announceGemini(`Analisi disegno vettoriale: ${description}`, 'assertive');
 
 } catch(error) {
 console.error('Errore descrizione vettoriale:', error);
 announceGemini(`Errore durante l'analisi: ${error.message}`, 'assertive');
 } finally {
 // v39.0: CLEANUP ESPLICITO CANVAS TEMPORANEO
 if (tempCanvas) {
 tempCanvas.width = 0;
 tempCanvas.height = 0;
 tempCanvas = null;
 console.log('️ Canvas temporaneo vettoriale ripulito');
 }
 
 btnDescribeVector.disabled = false;
 btnDescribeVector.textContent = ' Descrivi Vettoriale';
 }
 }
 
 btnDescribeVector.addEventListener('click', describeVectorDrawing);
 
 // Shortcut Ctrl+Shift+V
 document.addEventListener('keydown', function(e) {
 if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'v') {
 e.preventDefault();
 describeVectorDrawing();
 }
 
 // Shortcut Ctrl+Shift+C per centrare testo nel canvas
 if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key.toLowerCase() === 'c') {
 e.preventDefault();
 const btnCenter = document.getElementById('btn-center-in-canvas');
 if (btnCenter) {
 btnCenter.click();
 }
 }
 });
 }
 
 // ==================== FEATURE 4: TEST CONNESSIONE API ====================
 
 const btnTestApi = document.getElementById('btn-test-api');
 const apiKeyInput = document.getElementById('gemini-api-key');
 
 if (btnTestApi && apiKeyInput) {
 // Carica API key salvata
 const savedKey = getApiKey();
 if (savedKey) {
 apiKeyInput.value = savedKey;
 }
 
 // Salva API key quando cambia
 apiKeyInput.addEventListener('change', function() {
 const key = this.value.trim();
 if (key) {
 saveApiKey(key);
 showApiStatus('API key salvata', 'success');
 }
 });
 
 btnTestApi.addEventListener('click', async function() {
 const key = apiKeyInput.value.trim();
 
 if (!key) {
 showApiStatus('Inserisci prima una API key', 'warning');
 apiKeyInput.focus();
 return;
 }
 
 try {
 btnTestApi.disabled = true;
 btnTestApi.textContent = ' Test in corso...';
 showApiStatus('Test connessione in corso...', 'info');
 
 // Crea un'immagine di test (pixel bianco 1x1)
 const testCanvas = document.createElement('canvas');
 testCanvas.width = 1;
 testCanvas.height = 1;
 const ctx = testCanvas.getContext('2d');
 ctx.fillStyle = 'white';
 ctx.fillRect(0, 0, 1, 1);
 const testImage = testCanvas.toDataURL('image/jpeg');
 
 const response = await callGeminiVision(testImage, 'Rispondi solo con: OK');
 
 saveApiKey(key);
 showApiStatus(' Connessione riuscita! API funzionante.', 'success');
 
 } catch(error) {
 console.error('Errore test API:', error);
 showApiStatus(` Errore: ${error.message}`, 'error');
 } finally {
 btnTestApi.disabled = false;
 btnTestApi.textContent = ' Testa Connessione API';
 }
 });
 }
 
 console.log(' Gemini AI Integration inizializzata');
 console.log(' - Version: 33.8 FIXED');
 console.log(' - Null safety: ENABLED');
 console.log(' - Error handling: ENHANCED');
 console.log(' - Descrivi Immagine: Disponibile nei pannelli Immagini e Sfondo');
 console.log(' - Descrivi Canvas: Toolbar o Ctrl+I');
 console.log(' - Descrivi Disegno Vettoriale: Toolbar o Ctrl+Shift+V');
 console.log(' - Test API: Pannello Gemini AI');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * INTEGRAZIONE GEMINI AI - FASE 2: "CREARE"
 * ═══════════════════════════════════════════════════════════════
 * Funzionalità implementate:
 * 4. Riempimento Generativo da Area Vettoriale (tasto G)
 * * Usa: Stability AI Inpainting API
 * * Richiede: API key Stability AI (25 crediti gratuiti/mese)
 * Ottieni su: https://platform.stability.ai/account/keys
 * ═══════════════════════════════════════════════════════════════
 */
(function() {
 console.log(' Inizializzazione Generative Fill (Fase 2)...');
 
 // ==================== CONFIGURAZIONE ====================
 
 function getInpaintingApiKey() {
 const input = document.getElementById('inpainting-api-key');
 if (input && input.value.trim()) return input.value.trim();
 
 try {
 return localStorage.getItem('inpainting_api_key') || '';
 } catch(e) {
 return '';
 }
 }
 
 function saveInpaintingApiKey(key) {
 try {
 localStorage.setItem('inpainting_api_key', key);
 const input = document.getElementById('inpainting-api-key');
 if (input) input.value = key;
 } catch(e) {
 console.error('Errore salvataggio key:', e);
 }
 }
 
 // ==================== FUNZIONI HELPER ====================
 
 // announceGemini è già definita globalmente all'inizio del file come window.announceGemini
 // Alias locale per compatibilità
 const announceGemini = window.announceGemini;
 
 /**
 * NOTA: Le funzioni di generazione automatica con API sono state rimosse.
 * Ora l'utente genera le immagini esternamente e le carica manualmente.
 * Questo permette maggiore flessibilità e risparmio sui costi API.
 */
 
 // ==================== INTEGRAZIONE CON VECTOR MODE ====================
 
 /**
 * Funzione chiamata quando l'utente preme G in vector mode
 * VERSIONE MANUALE: Non usa API, permette all'utente di generare e caricare
 */
 window.generateFromVectorArea = async function() {
 // Accedi allo state dell'editor
 const state = window.state || window.APP?.state;
 
 if (!state || !state.vectorDrawMode) {
 // RIMOSSO (ridondante): announceGemini('Attiva prima il disegno vettoriale', 'assertive');
 return;
 }
 
 if (state.vectorPoints.length < 3) {
 announceGemini('Servono almeno 3 punti per definire un\'area', 'assertive');
 return;
 }
 
 // Calcola le dimensioni dell'area
 const points = state.vectorPoints;
 let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
 
 points.forEach(p => {
 minX = Math.min(minX, p.x);
 minY = Math.min(minY, p.y);
 maxX = Math.max(maxX, p.x);
 maxY = Math.max(maxY, p.y);
 });
 
 const width = Math.round(maxX - minX);
 const height = Math.round(maxY - minY);
 
 // Valida dimensioni minime
 if (width < 10 || height < 10) {
 announceGemini('Area troppo piccola! Disegna un\'area di almeno 10x10 pixel.', 'assertive');
 return;
 }
 
 // Chiedi cosa vuole generare
 const prompt = window.prompt(
 ' GENERAZIONE MANUALE CON AI ESTERNA\n\n' +
 'PASSO 1: Cosa vuoi generare in quest\'area?\n' +
 'Scrivi una descrizione (es. "un mare calmo", "montagne", "cielo al tramonto")\n\n' +
 'PASSO 2: Dopo aver cliccato OK, ti dirò le dimensioni esatte.\n' +
 'PASSO 3: Genera l\'immagine con la tua AI preferita.\n' +
 'PASSO 4: Torna qui e caricala.\n\n' +
 'Descrizione:'
 );
 
 if (!prompt || prompt.trim() === '') {
 announceGemini('Operazione annullata', 'polite');
 return;
 }
 
 // Salva i dati per dopo
 window._pendingGeneration = {
 points: [...points],
 x: minX,
 y: minY,
 width: width,
 height: height,
 prompt: prompt.trim()
 };
 
 // Mostra le istruzioni
 const instructions = 
 ` DIMENSIONI RICHIESTE PER L'IMMAGINE:\n\n` +
 `Larghezza: ${width} pixel\n` +
 `Altezza: ${height} pixel\n\n` +
 ` PROMPT SUGGERITO:\n` +
 `"${prompt}"\n\n` +
 ` COME PROCEDERE:\n` +
 `1. Usa la tua AI preferita (ChatGPT, Midjourney, ecc.)\n` +
 `2. Genera un'immagine ${width}x${height} px\n` +
 `3. Scarica l'immagine sul tuo computer\n` +
 `4. Torna qui e premi il nuovo pulsante "Carica Immagine Generata"\n\n` +
 `Il pulsante apparirà nel Pannello 6 (Disegno Vettoriale).`;
 
 alert(instructions);
 
 // Crea pulsante temporaneo per caricare l'immagine
 createUploadButtonForGeneration();
 
 // Disattiva il vector mode
 state.vectorDrawMode = false;
 state.vectorPoints = [];
 if (window.updateVectorUI) window.updateVectorUI();
 if (window.scheduleRender) window.scheduleRender();
 
 announce(
 `Area definita: ${width} per ${height} pixel. ` +
 `Genera ora l'immagine esternamente e carica usando il pulsante che è apparso nel Pannello 6.`,
 'assertive'
 );
 };
 
 /**
 * Crea pulsante per caricare l'immagine generata
 */
 function createUploadButtonForGeneration() {
 // Rimuovi pulsante precedente se esiste
 const oldBtn = document.getElementById('btn-upload-generated');
 if (oldBtn) oldBtn.remove();
 
 // Trova la sezione del disegno vettoriale
 const vectorSection = document.getElementById('vector-section');
 if (!vectorSection) return;
 
 // Crea il contenitore
 const container = document.createElement('div');
 container.id = 'generated-upload-container';
 container.className = 'control-group';
 container.style.marginTop = '20px';
 container.style.padding = '20px';
 container.style.background = 'linear-gradient(135deg, #fef3c7 0%, #fde68a 100%)';
 container.style.border = '2px solid #f59e0b';
 container.style.borderRadius = '8px';
 
 const pending = window._pendingGeneration;
 
 container.innerHTML = `
 <h3 style="color: #92400e; margin-bottom: 12px; font-weight: 600;">
 Carica Immagine Generata
 </h3>
 <p style="font-size: 13px; color: #78350f; margin-bottom: 12px; line-height: 1.5;">
 <strong>Area:</strong> ${pending.width}x${pending.height} pixel<br>
 <strong>Prompt:</strong> "${pending.prompt}"
 </p>
 <input type="file" id="generated-image-upload" accept="image/*" 
 style="margin-bottom: 12px; padding: 10px; background: white; border: 2px dashed #f59e0b; border-radius: 6px; width: 100%;">
 <button class="btn btn-warning btn-full" id="btn-upload-generated" style="background: linear-gradient(to right, #f59e0b, #d97706); color: white; font-weight: 600;">
 Aggiungi Immagine al Canvas
 </button>
 <button class="btn btn-secondary btn-full mt-8" id="btn-cancel-generated" >
 Annulla
 </button>
 `;
 
 // Inserisci all'inizio del vector-section
 vectorSection.insertBefore(container, vectorSection.firstChild);
 
 // Event listeners
 document.getElementById('btn-upload-generated').addEventListener('click', handleGeneratedImageUpload);
 document.getElementById('btn-cancel-generated').addEventListener('click', () => {
 container.remove();
 delete window._pendingGeneration;
 announceGemini('Operazione annullata', 'polite');
 });
 }
 
 /**
 * Gestisce il caricamento dell'immagine generata
 */
 function handleGeneratedImageUpload() {
 const fileInput = document.getElementById('generated-image-upload');
 const file = fileInput ? fileInput.files[0] : null;
 
 if (!file) {
 announceGemini('Seleziona prima un\'immagine da caricare', 'assertive');
 return;
 }
 
 const pending = window._pendingGeneration;
 if (!pending) {
 // RIMOSSO (ridondante): announceGemini('Dati area non trovati. Riprova a disegnare l\'area.', 'assertive');
 return;
 }
 
 announceGemini('Caricamento immagine in corso...', 'assertive');
 
 const reader = new FileReader();
 reader.onload = function(e) {
 const img = new Image();
 img.onload = function() {
 // Verifica dimensioni (con tolleranza del 10%)
 let widthOk = true;
 let heightOk = true;
 
 if (pending.width > 0) {
 widthOk = Math.abs(img.width - pending.width) / pending.width < 0.1;
 }
 if (pending.height > 0) {
 heightOk = Math.abs(img.height - pending.height) / pending.height < 0.1;
 }
 
 if (!widthOk || !heightOk) {
 const proceed = confirm(
 `️ ATTENZIONE: Dimensioni diverse!\n\n` +
 `Richiesto: ${pending.width}x${pending.height} px\n` +
 `Caricato: ${img.width}x${img.height} px\n\n` +
 `L'immagine verrà ridimensionata. Continuare?`
 );
 
 if (!proceed) {
 announceGemini('Caricamento annullato', 'polite');
 return;
 }
 }
 
 // Crea il layer
 const state = window.state || window.APP?.state;
 const newLayer = {
 type: 'image',
 name: `Generato: ${pending.prompt.substring(0, 20)}...`,
 imageElement: img,
 imageData: e.target.result,
 x: pending.x,
 y: pending.y,
 width: pending.width,
 height: pending.height,
 opacity: 1,
 visible: true
 };
 
 if (window.addLayer) {
 window.addLayer(newLayer);
 } else if (state && state.layers) {
 state.layers.push(newLayer);
 // Usa selectedIds invece di selected per coerenza
 state.selectedIds = [newLayer.id];
 // Aggiorna anche currentLayerIndex per allineare selezione e target effetti
 state.currentLayerIndex = state.layers.length - 1;
 }
 
 if (window.updateUI) window.updateUI();
 if (window.scheduleRender) window.scheduleRender();
 
 // Rimuovi il pulsante
 const container = document.getElementById('generated-upload-container');
 if (container) container.remove();
 delete window._pendingGeneration;
 
 announce(
 `Immagine aggiunta con successo! "${pending.prompt}" è ora un livello separato alle coordinate ${Math.round(pending.x)}, ${Math.round(pending.y)}.`,
 'assertive'
 );
 };
 img.onerror = function() {
 // RIMOSSO (ridondante): announceGemini('Errore caricamento immagine', 'assertive');
 };
 img.src = e.target.result;
 };
 reader.onerror = function() {
 announceGemini('Errore lettura file', 'assertive');
 };
 reader.readAsDataURL(file);
 }
 
 // ==================== AGGIUNGI CAMPO API KEY NELLA UI ====================
 
 // Aggiungi campo per API key Stability AI nel pannello Gemini
 (function() {
 const geminiSection = document.getElementById('gemini-section');
 if (!geminiSection) return;
 
 const inpaintingField = document.createElement('div');
 inpaintingField.className = 'control-group';
 inpaintingField.style.marginTop = '20px';
 inpaintingField.style.paddingTop = '20px';
 inpaintingField.style.borderTop = '2px solid var(--border-color)';
 inpaintingField.innerHTML = `
 <label for="inpainting-api-key" style="font-weight: 600; margin-bottom: 8px; display: block;">
 API Key Stability AI (Opzionale - Solo per Funzioni Extra)
 </label>
 <input type="password" id="inpainting-api-key" placeholder="Inserisci API key Stability AI..." 
 aria-describedby="inpainting-key-help">
 <p id="inpainting-key-help" style="font-size: 12px; color: var(--text-secondary); margin-top: 8px;">
 <strong>Necessaria SOLO per:</strong><br>
 • Rimuovi Sfondo (Pannello 8)<br>
 • Upscaling AI (Pannello 8)<br>
 • ️ Estrai Oggetto (Pannello 8)<br><br>
 <strong>NON necessaria per:</strong> Generazione immagini (ora manuale)<br><br>
 Ottieni una chiave gratuita su 
 <a href="https://platform.stability.ai/account/keys" target="_blank" 
 style="color: var(--primary-color); text-decoration: underline;">
 Stability AI
 </a> (25 crediti gratuiti al mese)
 </p>
 `;
 
 geminiSection.appendChild(inpaintingField);
 
 // Carica chiave salvata
 const savedKey = getInpaintingApiKey();
 const input = document.getElementById('inpainting-api-key');
 if (savedKey && input) {
 input.value = savedKey;
 }
 
 // Salva quando cambia
 if (input) {
 input.addEventListener('change', function() {
 const key = this.value.trim();
 if (key) {
 saveInpaintingApiKey(key);
 announceGemini('API key Stability AI salvata', 'polite');
 }
 });
 }
 })();
 
 // ==================== INTERCETTA TASTO G IN VECTOR MODE ====================
 
 // Trova il listener esistente del vector mode e aggiungi supporto per G
 document.addEventListener('keydown', function(e) {
 const state = window.state || window.APP?.state;
 
 // Solo se siamo in vector mode
 if (!state || !state.vectorDrawMode) return;
 
 // Tasto G (genera)
 if (e.key === 'g' || e.key === 'G') {
 e.preventDefault();
 e.stopPropagation();
 
 if (state.vectorPoints && state.vectorPoints.length >= 3) {
 window.generateFromVectorArea();
 } else {
 announceGemini('Servono almeno 3 punti per generare. Continua a disegnare l\'area.', 'assertive');
 }
 }
 }, true); // Use capture per intercettare prima
 
 console.log(' Generative Fill (Fase 2 - MANUALE) inizializzato');
 console.log(' - Tasto G nel disegno vettoriale per preparare area');
 console.log(' - Sistema MANUALE: genera immagini esternamente e caricale');
 console.log(' - NON richiede API Stability AI per generazione');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * INTEGRAZIONE GEMINI AI - FASE 3: "MODIFICARE"
 * ═══════════════════════════════════════════════════════════════
 * Funzionalità implementate:
 * 5. Estrazione Oggetto come Livello Separato
 * * Processo in 3 passi:
 * A. Segmentazione con Gemini (identifica oggetto)
 * B. Inpainting con Stability AI (rimuove oggetto e riempie sfondo)
 * C. Creazione livello (ritaglia oggetto come layer separato)
 * * Richiede: API key Gemini + Stability AI
 * ═══════════════════════════════════════════════════════════════
 */
(function() {
 console.log('️ Inizializzazione Object Extraction (Fase 3)...');
 
 // ==================== FUNZIONI HELPER ====================
 
 function announceExtraction(text, priority = 'polite') {
 const regionId = priority === 'assertive' ? 'sr-assert' : 'sr-polite';
 const region = document.getElementById(regionId);
 if (region) {
 region.textContent = '';
 setTimeout(() => { region.textContent = text; }, 50);
 }
 // RIMOSSO: if (window.speak) window.speak(text); - duplica NVDA
 console.log(` ${text}`);
 }
 
 function getGeminiApiKey() {
 const input = document.getElementById('gemini-api-key');
 if (input && input.value.trim()) return input.value.trim();
 try {
 return localStorage.getItem('gemini_api_key') || '';
 } catch(e) {
 return '';
 }
 }
 
 function getStabilityApiKey() {
 const input = document.getElementById('inpainting-api-key');
 if (input && input.value.trim()) return input.value.trim();
 try {
 return localStorage.getItem('inpainting_api_key') || '';
 } catch(e) {
 return '';
 }
 }
 
 // Esporta globalmente per riuso nei blocchi successivi
 window.getStabilityApiKey = getStabilityApiKey;
 window.getGeminiApiKey = getGeminiApiKey;
 
 // ==================== PASSO A: SEGMENTAZIONE ====================
 
 /**
 * Usa Gemini per identificare l'oggetto e generare una maschera
 * NOTA: Gemini non supporta segmentazione nativa, quindi usiamo un approccio creativo
 */
 async function segmentObjectWithGemini(imageDataURL, objectDescription) {
 const apiKey = getGeminiApiKey();
 if (apiKey && apiKey.length < 20) {
 console.warn('️ API key seems too short, check configuration');
 }
 if (!apiKey) {
 throw new Error('[Editor v33.8] API key Gemini non configurata');
 }
 
 const base64Image = imageDataURL.split(',')[1];
 
 // Chiediamo a Gemini di descrivere la posizione dell'oggetto
 const requestBody = {
 contents: [{
 parts: [
 { 
 text: `Analizza questa immagine e identifica: "${objectDescription}". 
 
Rispondi SOLO con un JSON valido in questo formato esatto:
{
 "found": true o false,
 "boundingBox": {
 "x": percentuale da sinistra (0-100),
 "y": percentuale dall'alto (0-100),
 "width": larghezza percentuale (0-100),
 "height": altezza percentuale (0-100)
 },
 "confidence": "high", "medium" o "low"
}

Se l'oggetto non è presente, usa found: false.
NON aggiungere testo prima o dopo il JSON.` 
 },
 { 
 inline_data: { 
 mime_type: "image/jpeg", 
 data: base64Image 
 } 
 }
 ]
 }]
 };
 
 const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(requestBody)
 });
 
 if (!response.ok) {
 throw new Error(`Errore API Gemini: ${response.status}`);
 }
 
 const data = await response.json();
 let responseText = data.candidates[0].content.parts[0].text;
 
 // Pulisci la risposta da eventuali markdown
 responseText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
 
 try {
 const segmentData = JSON.parse(responseText);
 return segmentData;
 } catch(e) {
 console.error('Risposta Gemini non valida:', responseText);
 throw new Error('[Editor v33.8] Impossibile analizzare la risposta di Gemini. Riprova con una descrizione più specifica.');
 }
 }
 
 /**
 * Crea maschera dal bounding box
 */
 function createMaskFromBoundingBox(boundingBox, width, height) {
 const maskCanvas = document.createElement('canvas');
 maskCanvas.width = width;
 maskCanvas.height = height;
 const ctx = maskCanvas.getContext('2d');
 
 // Riempi tutto di nero
 ctx.fillStyle = 'black';
 ctx.fillRect(0, 0, width, height);
 
 // Disegna rettangolo bianco per l'oggetto
 ctx.fillStyle = 'white';
 const x = (boundingBox.x / 100) * width;
 const y = (boundingBox.y / 100) * height;
 const w = (boundingBox.width / 100) * width;
 const h = (boundingBox.height / 100) * height;
 
 // Arrotonda gli angoli per una maschera più naturale
 const radius = Math.min(w, h) * 0.1;
 ctx.beginPath();
 ctx.moveTo(x + radius, y);
 ctx.lineTo(x + w - radius, y);
 ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
 ctx.lineTo(x + w, y + h - radius);
 ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
 ctx.lineTo(x + radius, y + h);
 ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
 ctx.lineTo(x, y + radius);
 ctx.quadraticCurveTo(x, y, x + radius, y);
 ctx.closePath();
 ctx.fill();
 
 return maskCanvas;
 }
 
 // ==================== PASSO B: INPAINTING ====================
 
 async function removeObjectWithInpainting(imageDataURL, maskCanvas) {
 const apiKey = getStabilityApiKey();
 if (apiKey && apiKey.length < 20) {
 console.warn('️ API key seems too short, check configuration');
 }
 if (!apiKey) {
 throw new Error('[Editor v33.8] API key Stability AI non configurata');
 }
 
 const formData = new FormData();
 
 // Converti in Blob
 const imageBlob = await fetch(imageDataURL, { signal: AbortSignal.timeout(30000) }).then(r => r.blob());
 const maskDataURL = maskCanvas.toDataURL('image/png');
 const maskBlob = await fetch(maskDataURL, { signal: AbortSignal.timeout(30000) }).then(r => r.blob());
 
 formData.append('init_image', imageBlob);
 formData.append('mask_image', maskBlob);
 formData.append('text_prompts[0][text]', 'remove object and fill background naturally, seamless inpainting');
 formData.append('text_prompts[0][weight]', '1');
 formData.append('cfg_scale', '7');
 formData.append('samples', '1');
 formData.append('steps', '30');
 
 const response = await fetch('https://api.stability.ai/v1/generation/stable-diffusion-xl-1024-v1-0/image-to-image/masking', {
 method: 'POST',
 headers: {
 'Authorization': `Bearer ${apiKey}`
 },
 body: formData
 });
 
 if (!response.ok) {
 const errorData = await response.json();
 throw new Error(errorData.message || `Errore Stability AI: ${response.status}`);
 }
 
 const data = await response.json();
 return `data:image/png;base64,${data.artifacts[0].base64}`;
 }
 
 // ==================== PASSO C: ESTRAZIONE OGGETTO ====================
 
 function extractObjectFromImage(imageDataURL, maskCanvas) {
 return new Promise((resolve, reject) => {
 const img = new Image();
 img.onload = function() {
 const extractCanvas = document.createElement('canvas');
 extractCanvas.width = img.width;
 extractCanvas.height = img.height;
 const ctx = extractCanvas.getContext('2d');
 
 // Disegna l'immagine
 ctx.drawImage(img, 0, 0);
 
 // Ridimensiona la maschera se necessario
 let finalMask = maskCanvas;
 if (maskCanvas.width !== img.width || maskCanvas.height !== img.height) {
 const resizedMask = document.createElement('canvas');
 resizedMask.width = img.width;
 resizedMask.height = img.height;
 const resizeCtx = resizedMask.getContext('2d');
 resizeCtx.drawImage(maskCanvas, 0, 0, img.width, img.height);
 finalMask = resizedMask;
 }
 
 // Applica la maschera usando composite operation
 const imageData = ctx.getImageData(0, 0, extractCanvas.width, extractCanvas.height);
 const maskData = finalMask.getContext('2d').getImageData(0, 0, finalMask.width, finalMask.height);
 
 // Applica trasparenza basata sulla maschera
 for (let i = 0; i < imageData.data.length; i += 4) {
 const maskValue = maskData.data[i]; // Valore del rosso (0-255)
 imageData.data[i + 3] = maskValue; // Applica come alpha
 }
 
 ctx.putImageData(imageData, 0, 0);
 resolve(extractCanvas.toDataURL('image/png'));
 };
 img.onerror = reject;
 img.src = imageDataURL;
 });
 }
 
 // ==================== FUNZIONE PRINCIPALE ====================
 
 async function extractObject() {
 const promptInput = document.getElementById('extract-prompt');
 const objectDescription = promptInput ? promptInput.value.trim() : '';
 
 if (!objectDescription) {
 announceGemini('Inserisci una descrizione dell\'oggetto da estrarre', 'assertive');
 if (promptInput) promptInput.focus();
 return;
 }
 
 // Verifica API keys
 if (!getGeminiApiKey()) {
 // RIMOSSO (ridondante): announceGemini('API key Gemini mancante. Configurala nel pannello Gemini AI.', 'assertive');
 return;
 }
 
 if (!getStabilityApiKey()) {
 announceGemini('API key Stability AI mancante. Configurala nel pannello Gemini AI.', 'assertive');
 return;
 }
 
 // Ottieni layer corrente dalla selezione
 const state = window.state || window.APP?.state;
 if (!state || !state.selectedIds || state.selectedIds.length === 0) {
 announceGemini('Seleziona prima un livello immagine', 'assertive');
 return;
 }
 
 // Ottieni il primo layer selezionato
 const selectedId = state.selectedIds[0];
 const layer = state.layers.find(l => l.id === selectedId);
 if (!layer || layer.type !== 'image') {
 announceGemini('Il livello selezionato non è un\'immagine', 'assertive');
 return;
 }
 
 const btn = document.getElementById('btn-extract-object');
 const originalText = btn ? btn.textContent : '';
 
 try {
 // PASSO 1: Segmentazione
 if (btn) {
 btn.disabled = true;
 btn.textContent = ' Passo 1/3: Analisi oggetto...';
 }
 // RIMOSSO (ridondante): announceGemini('Passo 1 di 3: Analisi dell\'oggetto con AI...', 'assertive');
 
 const segmentData = await segmentObjectWithGemini(layer.imageData, objectDescription);
 
 if (!segmentData.found) {
 announceGemini(`Oggetto non trovato nell'immagine. Prova con una descrizione più specifica.`, 'assertive');
 return;
 }
 
 announceGemini(`Oggetto identificato con confidenza ${segmentData.confidence}. Procedo con l'estrazione...`, 'polite');
 
 // Crea maschera
 const maskCanvas = createMaskFromBoundingBox(
 segmentData.boundingBox,
 layer.imageElement?.width,
 layer.imageElement?.height
 );
 
 // PASSO 2: Rimuovi oggetto dall'originale
 if (btn) btn.textContent = ' Passo 2/3: Rimozione oggetto...';
 announceGemini('Passo 2 di 3: Rimozione oggetto e riempimento sfondo...', 'assertive');
 
 const cleanBackgroundURL = await removeObjectWithInpainting(layer.imageData, maskCanvas);
 
 // PASSO 3: Estrai oggetto come layer separato
 if (btn) btn.textContent = '️ Passo 3/3: Creazione layer...';
 announceGemini('Passo 3 di 3: Creazione nuovo livello...', 'assertive');
 
 const extractedObjectURL = await extractObjectFromImage(layer.imageData, maskCanvas);
 
 // Aggiorna layer originale con sfondo pulito
 const cleanBgImg = new Image();
 cleanBgImg.onload = function() {
 layer.imageElement = cleanBgImg;
 layer.imageData = cleanBackgroundURL;
 
 // Crea nuovo layer con oggetto estratto
 const extractedImg = new Image();
 extractedImg.onload = function() {
 const newLayer = {
 type: 'image',
 name: `Estratto: ${objectDescription.substring(0, 20)}`,
 imageElement: extractedImg,
 imageData: extractedObjectURL,
 x: layer.x,
 y: layer.y,
 width: layer.width,
 height: layer.height,
 opacity: 1,
 visible: true
 };
 
 if (window.addLayer) {
 window.addLayer(newLayer);
 } else if (state.layers) {
 state.layers.push(newLayer);
 // Usa selectedIds invece di selected per coerenza
 state.selectedIds = [newLayer.id];
 // Aggiorna anche currentLayerIndex per allineare selezione e target effetti
 state.currentLayerIndex = state.layers.length - 1;
 }
 
 if (window.updateUI) window.updateUI();
 if (window.scheduleRender) window.scheduleRender();
 
 announceExtraction(
 `Completato! L'oggetto "${objectDescription}" è stato estratto come nuovo livello. ` +
 `Lo sfondo originale è stato pulito. Ora puoi spostare l'oggetto liberamente.`,
 'assertive'
 );
 
 // Pulisci input
 if (promptInput) promptInput.value = '';
 };
 extractedImg.onerror = function() {
 // RIMOSSO (ridondante): announceGemini('Errore creazione layer estratto', 'assertive');
 };
 extractedImg.src = extractedObjectURL;
 };
 cleanBgImg.onerror = function() {
 announceGemini('Errore aggiornamento sfondo', 'assertive');
 };
 cleanBgImg.src = cleanBackgroundURL;
 
 } catch(error) {
 console.error('Errore estrazione oggetto:', error);
 announceGemini(`Errore: ${error.message}`, 'assertive');
 
 // Suggerimenti
 if (error.message.includes('API key')) {
 setTimeout(() => {
 alert(
 'Per usare l\'estrazione oggetti servono entrambe le API key:\n\n' +
 '1. Gemini (per identificare l\'oggetto)\n' +
 '2. Stability AI (per rimuovere e riempire)\n\n' +
 'Configurale nel pannello Gemini AI in alto.'
 );
 }, 1000);
 }
 } finally {
 if (btn) {
 btn.disabled = false;
 btn.textContent = originalText;
 }
 }
 }
 
 // ==================== EVENT LISTENERS ====================
 
 const btnExtract = document.getElementById('btn-extract-object');
 if (btnExtract) {
 btnExtract.addEventListener('click', extractObject);
 }
 
 // Permetti anche invio nel campo di testo
 const promptInput = document.getElementById('extract-prompt');
 if (promptInput) {
 promptInput.addEventListener('keydown', function(e) {
 if (e.key === 'Enter' && !e.shiftKey) {
 e.preventDefault();
 extractObject();
 }
 });
 }
 
 console.log(' Object Extraction (Fase 3) inizializzato');
 console.log(' - Pannello 8: Estrai Oggetto con AI (solo per immagini)');
 console.log(' - Richiede: Gemini API + Stability API');
})();
</script>

<script>
/**
 * ═══════════════════════════════════════════════════════════════
 * FUNZIONALITÀ EXTRA AI
 * ═══════════════════════════════════════════════════════════════
 * 1. OCR - Estrazione Testo da Immagini (Google Vision API)
 * 2. Background Removal - Rimozione Sfondo (Stability AI)
 * 3. Upscaling AI - Miglioramento Qualità (Stability AI)
 * ═══════════════════════════════════════════════════════════════
 */
(function() {
 console.log(' Inizializzazione Funzionalità Extra AI...');
 
 // ==================== HELPER FUNCTIONS ====================
 
 function announceExtraAI(text, priority = 'polite') {
 const regionId = priority === 'assertive' ? 'sr-assert' : 'sr-polite';
 const region = document.getElementById(regionId);
 if (region) {
 region.textContent = '';
 setTimeout(() => { region.textContent = text; }, 50);
 }
 // RIMOSSO: if (window.speak) window.speak(text); - duplica NVDA
 console.log(` ${text}`);
 }
 
 // Riusa le funzioni già definite nel blocco precedente
 const getGeminiApiKey = window.getGeminiApiKey || function() {
 const input = document.getElementById('gemini-api-key');
 if (input && input.value.trim()) return input.value.trim();
 try { return localStorage.getItem('gemini_api_key') || ''; } catch(e) { return ''; }
 };
 
 const getStabilityApiKey = window.getStabilityApiKey || function() {
 const input = document.getElementById('inpainting-api-key');
 if (input && input.value.trim()) return input.value.trim();
 try { return localStorage.getItem('inpainting_api_key') || ''; } catch(e) { return ''; }
 };
 
 function getCurrentImageLayer() {
 const state = window.state || window.APP?.state;
 if (!state || !state.selectedIds || state.selectedIds.length === 0) return null;
 
 // Ottieni il primo layer selezionato
 const selectedId = state.selectedIds[0];
 const layer = state.layers.find(l => l.id === selectedId);
 
 if (!layer || layer.type !== 'image') return null;
 return layer;
 }
 
 // ==================== 1. OCR - ESTRAZIONE TESTO ====================
 
 async function extractTextWithOCR() {
 const layer = getCurrentImageLayer();
 if (!layer) {
 announceGemini('Seleziona prima un livello immagine', 'assertive');
 return;
 }
 
 const apiKey = getGeminiApiKey();
 if (apiKey && apiKey.length < 20) {
 console.warn('️ API key seems too short, check configuration');
 }
 if (!apiKey) {
 announceGemini('API key Gemini mancante. Configurala nel pannello Gemini AI.', 'assertive');
 return;
 }
 
 const btn = document.getElementById('btn-ocr-extract');
 const originalText = btn ? btn.textContent : '';
 
 try {
 if (btn) {
 btn.disabled = true;
 btn.textContent = ' Analisi testo in corso...';
 }
 announceGemini('Estrazione testo dall\'immagine in corso...', 'assertive');
 
 const base64Image = layer.imageData.split(',')[1];
 
 // Usa Gemini per OCR
 const requestBody = {
 contents: [{
 parts: [
 { 
 text: `Estrai TUTTO il testo visibile in questa immagine. Per ogni blocco di testo trovato, rispondi con un JSON array in questo formato:

[
 {
 "text": "il testo estratto",
 "position": {
 "x": percentuale da sinistra (0-100),
 "y": percentuale dall'alto (0-100)
 },
 "fontSize": dimensione approssimativa (piccolo/medio/grande),
 "confidence": "high" o "medium" o "low"
 }
]

Se non c'è testo, rispondi con un array vuoto: []
NON aggiungere testo prima o dopo il JSON.` 
 },
 { 
 inline_data: { 
 mime_type: "image/jpeg", 
 data: base64Image 
 } 
 }
 ]
 }]
 };
 
 const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${apiKey}`, {
 method: 'POST',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(requestBody)
 });
 
 if (!response.ok) throw new Error(`Errore API: ${response.status}`);
 
 const data = await response.json();
 let responseText = data.candidates[0].content.parts[0].text;
 responseText = responseText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
 
 let textBlocks;
 try {
 textBlocks = JSON.parse(responseText);
 } catch(parseError) {
 console.error('Risposta Gemini non valida:', responseText);
 throw new Error('[Editor v33.8] Impossibile analizzare la risposta. Il modello potrebbe non aver trovato testo leggibile.');
 }
 
 if (!textBlocks || !Array.isArray(textBlocks) || textBlocks.length === 0) {
 announceGemini('Nessun testo trovato nell\'immagine', 'assertive');
 return;
 }
 
 // Crea livelli di testo per ogni blocco
 const state = window.state || window.APP?.state;
 let created = 0;
 
 textBlocks.forEach((block, index) => {
 const fontSize = block.fontSize === 'grande' ? 48 : block.fontSize === 'piccolo' ? 24 : 32;
 const x = (block.position.x / 100) * (layer.width || 1080);
 const y = (block.position.y / 100) * (layer.height || 1080);
 
 const textLayer = {
 type: 'text',
 name: `OCR ${index + 1}: ${block.text.substring(0, 15)}...`,
 text: block.text,
 x: layer.x + x,
 y: layer.y + y,
 fontSize: fontSize,
 fontFamily: 'Arial',
 color: '#000000',
 opacity: 1,
 visible: true
 };
 
 if (window.addLayer) {
 window.addLayer(textLayer);
 } else if (state && state.layers) {
 state.layers.push(textLayer);
 }
 created++;
 });
 
 if (window.updateUI) window.updateUI();
 if (window.scheduleRender) window.scheduleRender();
 
 // RIMOSSO (ridondante): announceGemini(`Testo estratto! Creati ${created} livelli di testo. Puoi ora modificarli nel Pannello 7.`, 'assertive');
 
 } catch(error) {
 console.error('Errore OCR:', error);
 announceGemini(`Errore durante l'estrazione del testo: ${error.message}`, 'assertive');
 } finally {
 if (btn) {
 btn.disabled = false;
 btn.textContent = originalText;
 }
 }
 }
 
 // ==================== 2. BACKGROUND REMOVAL ====================
 
 async function removeBackground() {
 const layer = getCurrentImageLayer();
 if (!layer) {
 announceGemini('Seleziona prima un livello immagine', 'assertive');
 return;
 }
 
 const apiKey = getStabilityApiKey();
 if (apiKey && apiKey.length < 20) {
 console.warn('️ API key seems too short, check configuration');
 }
 if (!apiKey) {
 announceGemini('API key Stability AI mancante. Configurala nel pannello Gemini AI.', 'assertive');
 return;
 }
 
 const btn = document.getElementById('btn-remove-background');
 const originalText = btn ? btn.textContent : '';
 
 try {
 if (btn) {
 btn.disabled = true;
 btn.textContent = '️ Rimozione sfondo...';
 }
 announceGemini('Rimozione sfondo in corso, attendi 10-15 secondi...', 'assertive');
 
 // Converti immagine in blob
 const imageBlob = await fetch(layer.imageData, { signal: AbortSignal.timeout(30000) }).then(r => r.blob());
 
 const formData = new FormData();
 formData.append('image', imageBlob);
 formData.append('output_format', 'png');
 
 const response = await fetch('https://api.stability.ai/v2beta/stable-image/edit/remove-background', {
 method: 'POST',
 headers: {
 'Authorization': `Bearer ${apiKey}`,
 'Accept': 'image/*'
 },
 body: formData
 });
 
 if (!response.ok) {
 throw new Error(`Errore API: ${response.status}`);
 }
 
 const resultBlob = await response.blob();
 const resultURL = await new Promise((resolve) => {
 const reader = new FileReader();
 reader.onloadend = () => resolve(reader.result);
 reader.readAsDataURL(resultBlob);
 });
 
 // Aggiorna l'immagine del layer
 const img = new Image();
 img.onload = function() {
 layer.imageElement = img;
 layer.imageData = resultURL;
 
 if (window.scheduleRender) window.scheduleRender();
 
 // RIMOSSO (ridondante): announceGemini('Sfondo rimosso con successo! L\'immagine ora ha sfondo trasparente.', 'assertive');
 };
 img.onerror = function() {
 announceGemini('Errore caricamento immagine processata', 'assertive');
 };
 img.src = resultURL;
 
 } catch(error) {
 console.error('Errore rimozione sfondo:', error);
 announceGemini(`Errore: ${error.message}`, 'assertive');
 } finally {
 if (btn) {
 btn.disabled = false;
 btn.textContent = originalText;
 }
 }
 }
 
 // ==================== 3. UPSCALING AI ====================
 
 async function upscaleImage() {
 const layer = getCurrentImageLayer();
 if (!layer) {
 announceGemini('Seleziona prima un livello immagine', 'assertive');
 return;
 }
 
 const apiKey = getStabilityApiKey();
 if (apiKey && apiKey.length < 20) {
 console.warn('️ API key seems too short, check configuration');
 }
 if (!apiKey) {
 announceGemini('API key Stability AI mancante. Configurala nel pannello Gemini AI.', 'assertive');
 return;
 }
 
 const factorSelect = document.getElementById('upscale-factor');
 const factor = factorSelect ? parseInt(factorSelect.value) : 2;
 
 const btn = document.getElementById('btn-upscale-image');
 const originalText = btn ? btn.textContent : '';
 
 try {
 if (btn) {
 btn.disabled = true;
 btn.textContent = ` Upscaling ${factor}x...`;
 }
 announceGemini(`Miglioramento risoluzione ${factor}x in corso, attendi 20-40 secondi...`, 'assertive');
 
 // Converti immagine in blob
 const imageBlob = await fetch(layer.imageData, { signal: AbortSignal.timeout(30000) }).then(r => r.blob());
 
 const formData = new FormData();
 formData.append('image', imageBlob);
 formData.append('output_format', 'png');
 
 // Usa conservative per mantenere i dettagli originali
 const response = await fetch('https://api.stability.ai/v2beta/stable-image/upscale/conservative', {
 method: 'POST',
 headers: {
 'Authorization': `Bearer ${apiKey}`,
 'Accept': 'image/*'
 },
 body: formData
 });
 
 if (!response.ok) {
 throw new Error(`Errore API: ${response.status}`);
 }
 
 const resultBlob = await response.blob();
 const resultURL = await new Promise((resolve) => {
 const reader = new FileReader();
 reader.onloadend = () => resolve(reader.result);
 reader.readAsDataURL(resultBlob);
 });
 
 // Aggiorna l'immagine del layer
 const img = new Image();
 img.onload = function() {
 const oldWidth = layer.width;
 const oldHeight = layer.height;
 
 layer.imageElement = img;
 layer.imageData = resultURL;
 // Mantieni le stesse dimensioni sul canvas (non ingrandire visivamente)
 layer.width = oldWidth;
 layer.height = oldHeight;
 
 if (window.scheduleRender) window.scheduleRender();
 
 // RIMOSSO (ridondante): announceGemini(`Risoluzione migliorata! L'immagine ora è ${img.width}x${img.height} pixel (${factor}x più grande) con qualità superiore.`, 'assertive');
 };
 img.onerror = function() {
 announceGemini('Errore caricamento immagine upscaled', 'assertive');
 };
 img.src = resultURL;
 
 } catch(error) {
 console.error('Errore upscaling:', error);
 announceGemini(`Errore: ${error.message}`, 'assertive');
 } finally {
 if (btn) {
 btn.disabled = false;
 btn.textContent = originalText;
 }
 }
 }
 
 // ==================== EVENT LISTENERS ====================
 
 const btnOCR = document.getElementById('btn-ocr-extract');
 if (btnOCR) {
 btnOCR.addEventListener('click', extractTextWithOCR);
 }
 
 const btnRemBg = document.getElementById('btn-remove-background');
 if (btnRemBg) {
 btnRemBg.addEventListener('click', removeBackground);
 }
 
 const btnUpscale = document.getElementById('btn-upscale-image');
 if (btnUpscale) {
 btnUpscale.addEventListener('click', upscaleImage);
 }
 
 console.log(' Funzionalità Extra AI inizializzate');
 console.log(' - OCR: Estrai testo da immagini');
 console.log(' - Background Removal: Rimuovi sfondo automaticamente');
 console.log(' - Upscaling: Migliora risoluzione fino a 4x');


// ═══════════════════════════════════════════════════════════════════
// LAZY LOADING SYSTEM + EFFETTI RAGGRUPPATI v34.0
// ═══════════════════════════════════════════════════════════════════

window.ImageMemoryManager={config:{maxLoadedImages:50,unloadDelay:5000,enableDebugLog:!1},cache:new Map,loadedCount:0,totalMemoryUsed:0,stats:{hits:0,misses:0,unloads:0},loadImage(e,t){if(!e)return void t(null);if(this.cache.has(e)){const a=this.cache.get(e);return a.lastUsed=Date.now(),this.stats.hits++,void t(a.img)}this.stats.misses++;const a=new Image;a.onload=()=>{const i=a.width*a.height*4;this.cache.set(e,{img:a,lastUsed:Date.now(),size:i}),this.loadedCount++,this.totalMemoryUsed+=i,this.cleanupIfNeeded(),t(a)},a.onerror=()=>t(null),a.src=e},cleanupIfNeeded(){this.loadedCount>this.config.maxLoadedImages&&this.unloadOldestImages(this.loadedCount-this.config.maxLoadedImages)},unloadOldestImages(e){const t=Array.from(this.cache.entries()).sort(((e,t)=>e[1].lastUsed-t[1].lastUsed));for(let a=0;a<Math.min(e,t.length);a++){const[e,i]=t[a];this.cache.delete(e),this.loadedCount--,this.totalMemoryUsed-=i.size,this.stats.unloads++}},getStats(){return{...this.stats,loadedCount:this.loadedCount,totalMemoryMB:(this.totalMemoryUsed/1024/1024).toFixed(2),cacheSize:this.cache.size}}};setInterval((()=>{if(window.ImageMemoryManager&&window.state){const e=state.layers.filter((e=>e.visible)),t=new Set(e.filter((e=>"image"===e.type&&e.imageData)).map((e=>e.imageData))),a=[];for(const[e]of ImageMemoryManager.cache)t.has(e)||a.push(e);a.forEach((e=>{const t=ImageMemoryManager.cache.get(e);t&&(ImageMemoryManager.cache.delete(e),ImageMemoryManager.loadedCount--,ImageMemoryManager.totalMemoryUsed-=t.size,ImageMemoryManager.stats.unloads++)}))}}),3e4);window.showMemoryStats=function(){if(!window.ImageMemoryManager)return void console.log(" Lazy Loading non disponibile");const e=ImageMemoryManager.getStats();console.log(`
╔════════════════════════════════════════╗
║ STATISTICHE MEMORIA IMMAGINI ║
╚════════════════════════════════════════╝

️ Immagini: ${e.cacheSize} | RAM: ${e.totalMemoryMB} MB
 Hits: ${e.hits} | Misses: ${e.misses} | ️ Unloads: ${e.unloads}
️ Max: ${ImageMemoryManager.config.maxLoadedImages}

 Cambia: ImageMemoryManager.config.maxLoadedImages = 100
`)};console.log(" Lazy Loading v34.0 (max 50 img) | showMemoryStats() per stats");


// ════════════════════════════════════════════════════════════════════
// EFFETTI AVANZATI v34.1
// ════════════════════════════════════════════════════════════════════

// ════════════════════════════════════════════════════════════════════
// CONVERSIONE AUTOMATICA LAYER → IMMAGINE (VERSIONE ROBUSTA)
// ════════════════════════════════════════════════════════════════════
/**
 * Converte un layer (forma, testo, poligono) in immagine usando Promises
 * Gestisce correttamente il timing asincrono e gli errori
 */
/**
 * Applica un effetto GPU a un layer specifico (non all'intero canvas)
 * @param {Object} layer - Layer da modificare (deve essere o diventare un'immagine)
 * @param {Function} gpuEffectFunction - Funzione GpuEffects da applicare (es: GpuEffects.applyCurves)
 * @param {Array} effectArgs - Argomenti per la funzione effetto (escluso il canvas che viene gestito automaticamente)
 * @returns {Promise<boolean>} - true se l'effetto è stato applicato con successo
 */
async function applyGpuEffectToLayer(layer, gpuEffectFunction, effectArgs = []) {
 try {
 if (!layer) {
 throw new Error('Layer non valido');
 }
 
 // Step 1: Converti in immagine se necessario
 if (layer.type === 'shape' || layer.type === 'text' || layer.type === 'vector') {
 announceGemini('Conversione automatica in immagine per effetto GPU...', 'polite');
 await convertLayerToImage(layer);
 }
 
 // Verifica che ora sia un'immagine
 if (layer.type !== 'image' || !layer.imageElement) {
 throw new Error('Il layer deve essere un\'immagine per applicare effetti GPU');
 }
 
 // Step 2: Crea un canvas temporaneo con l'immagine del layer
 const tempCanvas = document.createElement('canvas');
 const tempCtx = tempCanvas.getContext('2d');
 tempCanvas.width = layer.imageElement.width;
 tempCanvas.height = layer.imageElement.height;
 
 // Disegna l'immagine del layer sul canvas temporaneo
 tempCtx.drawImage(layer.imageElement, 0, 0);
 
 // Step 3: Applica l'effetto GPU al canvas temporaneo
 const success = gpuEffectFunction(tempCanvas, ...effectArgs);
 
 if (!success) {
 throw new Error('Applicazione effetto GPU fallita');
 }
 
 // Step 4: Salva il risultato nel layer
 return new Promise((resolve, reject) => {
 const img = new Image();
 img.onload = () => {
 layer.imageElement = img;
 layer.imageData = tempCanvas.toDataURL();
 
 // Aggiorna dimensioni se cambiate
 layer.width = tempCanvas.width;
 layer.height = tempCanvas.height;
 
 console.log(` Effetto GPU applicato al layer "${layer.name}"`);
 resolve(true);
 };
 img.onerror = () => reject(new Error('Errore caricamento immagine risultato'));
 img.src = tempCanvas.toDataURL();
 });
 
 } catch (error) {
 console.error(' Errore applicazione effetto GPU al layer:', error);
 announceGemini('Errore: ' + error.message, 'assertive');
 return false;
 }
}

function convertLayerToImage(layer) {
 return new Promise((resolve, reject) => {
 if (!layer) {
 reject(new Error('Layer non valido'));
 return;
 }
 
 // Verifica preventiva che le funzioni di rendering siano disponibili
 const renderFunctionsReady = 
 typeof window.renderShape === 'function' &&
 typeof window.renderText === 'function' &&
 typeof window.renderPolygon === 'function';
 
 if (!renderFunctionsReady) {
 reject(new Error('Funzioni di rendering non ancora disponibili. Attendi che l\'app sia completamente caricata.'));
 return;
 }
 
 // Se è già un'immagine, non fare nulla
 if (layer.type === 'image' && layer.imageElement) {
 resolve(layer);
 return;
 }
 
 // Se è una forma, testo o poligono, convertilo
 if (layer.type === 'shape' || layer.type === 'text' || layer.type === 'polygon') {
 try {
 // Salva il tipo originale
 const originalType = layer.type;
 const originalName = layer.name;
 
 // Crea un canvas temporaneo con padding generoso
 const padding = 100; // Padding extra per rotazioni/trasformazioni
 const tempCanvas = document.createElement('canvas');
 const tempCtx = tempCanvas.getContext('2d');
 
 // Calcola dimensioni con padding
 const canvasWidth = Math.ceil(layer.width || 200) + padding * 2;
 const canvasHeight = Math.ceil(layer.height || 150) + padding * 2;
 
 tempCanvas.width = canvasWidth;
 tempCanvas.height = canvasHeight;
 
 // Salva i contesti globali originali
 const originalCtx = window.ctx;
 const originalCanvas = window.canvas;
 
 try {
 // Sostituisci temporaneamente con il nostro context
 window.ctx = tempCtx;
 window.canvas = tempCanvas;
 
 // Salva lo stato del contesto
 tempCtx.save();
 
 // Sposta l'origine al centro del padding
 tempCtx.translate(padding, padding);
 
 // Crea un layer temporaneo CON COPIA MANUALE (non JSON.parse)
 // per evitare problemi con riferimenti circolari
 const tempLayer = {
 // Proprietà comuni a tutti i layer
 type: layer.type,
 x: 0,
 y: 0,
 width: layer.width,
 height: layer.height,
 name: layer.name,
 visible: layer.visible,
 locked: layer.locked,
 opacity: layer.opacity,
 rotation: layer.rotation,
 flipH: layer.flipH,
 flipV: layer.flipV,
 scale: layer.scale,
 id: layer.id,
 
 // Proprietà shape
 shape: layer.shape, // rect, circle, triangle, star, star8, heart, speech, line, hexagon, arrow
 cornerRadius: layer.cornerRadius,
 color: layer.color,
 
 // Gradiente
 useGradient: layer.useGradient,
 gradient: layer.gradient ? {
 type: layer.gradient.type,
 color1: layer.gradient.color1,
 color2: layer.gradient.color2,
 angle: layer.gradient.angle
 } : null,
 
 // Bordo/Stroke
 useStroke: layer.useStroke,
 stroke: layer.stroke ? {
 color: layer.stroke.color,
 width: layer.stroke.width,
 style: layer.stroke.style
 } : null,
 
 // Proprietà testo
 text: layer.text,
 fontFamily: layer.fontFamily,
 fontSize: layer.fontSize,
 fontWeight: layer.fontWeight,
 fontStyle: layer.fontStyle,
 textAlign: layer.textAlign,
 textDecoration: layer.textDecoration,
 letterSpacing: layer.letterSpacing,
 lineHeight: layer.lineHeight,
 // Stili testo legacy (ancora usati)
 bold: layer.bold,
 italic: layer.italic,
 underline: layer.underline,
 lineThrough: layer.lineThrough,
 
 // Proprietà poligono
 points: layer.points ? [...layer.points] : null,
 polygonPoints: layer.polygonPoints ? [...layer.polygonPoints] : null,
 closePath: layer.closePath,
 
 // Ombra (dropShadow)
 dropShadow: layer.dropShadow ? {
 enabled: layer.dropShadow.enabled,
 color: layer.dropShadow.color,
 blur: layer.dropShadow.blur,
 x: layer.dropShadow.x,
 y: layer.dropShadow.y
 } : null,
 
 // Filtri
 filters: layer.filters ? {
 preset: layer.filters.preset,
 brightness: layer.filters.brightness,
 contrast: layer.filters.contrast,
 saturation: layer.filters.saturation,
 hue: layer.filters.hue,
 sepia: layer.filters.sepia,
 blur: layer.filters.blur
 } : null,
 
 // Maschera
 mask: layer.mask,
 maskShape: layer.maskShape,
 
 // Altre proprietà che potrebbero essere usate
 blendMode: layer.blendMode,
 clipPath: layer.clipPath
 };
 
 // Applica trasformazioni se presenti
 if (tempLayer.rotation) {
 const centerX = tempLayer.width / 2;
 const centerY = tempLayer.height / 2;
 tempCtx.translate(centerX, centerY);
 tempCtx.rotate((tempLayer.rotation * Math.PI) / 180);
 tempCtx.translate(-centerX, -centerY);
 }
 
 if (tempLayer.flipH) {
 tempCtx.translate(tempLayer.width, 0);
 tempCtx.scale(-1, 1);
 }
 
 if (tempLayer.flipV) {
 tempCtx.translate(0, tempLayer.height);
 tempCtx.scale(1, -1);
 }
 
 // Opacità
 if (tempLayer.opacity !== undefined && tempLayer.opacity < 100) {
 tempCtx.globalAlpha = tempLayer.opacity / 100;
 }
 
 // Disegna il layer usando le funzioni di render
 // Verifica robusta che le funzioni esistano
 if (tempLayer.type === 'shape') {
 if (typeof window.renderShape !== 'function') {
 throw new Error('Funzione renderShape non disponibile. L\'app potrebbe non essere completamente caricata.');
 }
 window.renderShape(tempLayer);
 } else if (tempLayer.type === 'text') {
 if (typeof window.renderText !== 'function') {
 throw new Error('Funzione renderText non disponibile. L\'app potrebbe non essere completamente caricata.');
 }
 window.renderText(tempLayer);
 } else if (tempLayer.type === 'polygon') {
 if (typeof window.renderPolygon !== 'function') {
 throw new Error('Funzione renderPolygon non disponibile. L\'app potrebbe non essere completamente caricata.');
 }
 window.renderPolygon(tempLayer);
 } else {
 throw new Error(`Tipo layer non supportato per conversione: ${tempLayer.type}`);
 }
 
 tempCtx.restore();
 
 } finally {
 // SEMPRE ripristina i contesti originali (anche in caso di errore)
 window.ctx = originalCtx;
 window.canvas = originalCanvas;
 }
 
 // Converti il canvas in immagine
 const dataURL = tempCanvas.toDataURL('image/png');
 const img = new Image();
 
 // Gestisci caricamento immagine
 img.onload = () => {
 try {
 // Converti il layer originale in tipo image
 layer.type = 'image';
 layer.imageElement = img;
 layer.imageData = dataURL;
 
 // Salva posizione originale
 const oldX = layer.x;
 const oldY = layer.y;
 
 // Aggiorna dimensioni
 layer.width = canvasWidth;
 layer.height = canvasHeight;
 
 // Aggiusta posizione per compensare il padding
 layer.x = oldX - padding;
 layer.y = oldY - padding;
 
 // Reset trasformazioni (sono già applicate nell'immagine)
 layer.rotation = 0;
 layer.flipH = false;
 layer.flipV = false;
 
 // Aggiorna nome
 if (!layer.name.includes('(Convertito)')) {
 layer.name = `${originalName} (Convertito da ${originalType})`;
 }
 
 console.log(` Layer "${layer.name}" convertito in immagine (${canvasWidth}x${canvasHeight})`);
 
 // Aggiorna UI
 if (window.scheduleRender) window.scheduleRender();
 if (window.updateUI) window.updateUI();
 
 resolve(layer);
 
 } catch (error) {
 reject(error);
 }
 };
 
 img.onerror = () => {
 reject(new Error('Errore caricamento immagine convertita'));
 };
 
 img.src = dataURL;
 
 } catch (error) {
 console.error(' Errore conversione layer:', error);
 reject(error);
 }
 } else {
 reject(new Error(`Tipo layer non convertibile: ${layer.type}`));
 }
 });
}

// Esporta per uso globale
window.convertLayerToImage = convertLayerToImage;

// ════════════════════════════════════════════════════════════════════
// WRAPPER AUTOMATICO PER TUTTI GLI EFFETTI (VERSIONE ROBUSTA)
// ════════════════════════════════════════════════════════════════════
/**
 * Wrappa tutti i metodi di AdvancedEffects per convertire automaticamente
 * forme/testo in immagini prima di applicare gli effetti
 */
(function initEffectsWrapper() {
 // Aspetta che TUTTO sia pronto: AdvancedEffects E le funzioni di rendering
 const checkInterval = setInterval(() => {
 // Controlla AdvancedEffects
 if (typeof AdvancedEffects === 'undefined') {
 return; // Continua ad aspettare
 }
 
 // Controlla che le funzioni di rendering siano disponibili
 const renderFunctionsReady = 
 typeof window.renderShape === 'function' &&
 typeof window.renderText === 'function' &&
 typeof window.renderPolygon === 'function';
 
 if (!renderFunctionsReady) {
 // Continua ad aspettare anche le funzioni di rendering
 return;
 }
 
 // TUTTO è pronto, procedi
 clearInterval(checkInterval);
 
 console.log(' Inizializzazione wrapper effetti con conversione automatica...');
 console.log(' AdvancedEffects disponibile');
 console.log(' Funzioni di rendering disponibili (renderShape, renderText, renderPolygon)');
 
 // Lista dei metodi da wrappare (escludi createGradientText che crea un nuovo layer)
 const effectMethods = Object.keys(AdvancedEffects).filter(key => 
 typeof AdvancedEffects[key] === 'function' && key !== 'createGradientText'
 );
 
 // Wrappo ogni metodo
 effectMethods.forEach(methodName => {
 const originalMethod = AdvancedEffects[methodName];
 
 // Sostituisci con versione wrappata (NON async, ma gestisce Promise internamente)
 AdvancedEffects[methodName] = function(layer, ...args) {
 // Se il layer non esiste, fallisci subito
 if (!layer) {
 announceExtraAI('Nessun layer selezionato', 'assertive');
 return false;
 }
 
 // Se è già un'immagine, applica direttamente (comportamento originale)
 if (layer.type === 'image' && layer.imageElement) {
 return originalMethod.call(AdvancedEffects, layer, ...args);
 }
 
 // PROTEZIONE RACE CONDITION: Se il layer è già in conversione, blocca
 if (layer._isConverting) {
 console.warn(`️ [${methodName}] Layer "${layer.name}" già in conversione, attendi...`);
 announceExtraAI('Attendi il completamento della conversione in corso', 'polite');
 return false;
 }
 
 // Se il layer non è un'immagine, convertilo PRIMA (operazione asincrona)
 console.log(` [${methodName}] Conversione ${layer.type} "${layer.name}" in immagine...`);
 
 // Verifica che le funzioni di rendering siano disponibili
 const renderFunctionsReady = 
 typeof window.renderShape === 'function' &&
 typeof window.renderText === 'function' &&
 typeof window.renderPolygon === 'function';
 
 if (!renderFunctionsReady) {
 console.error(` [${methodName}] Funzioni di rendering non disponibili`);
 announceExtraAI('Errore: app non completamente caricata. Riprova tra qualche secondo.', 'assertive');
 return false;
 }
 
 announceExtraAI(`Conversione ${layer.type} in immagine...`, 'polite');
 
 // Marca il layer come "in conversione" per prevenire race conditions
 layer._isConverting = true;
 
 // Avvia la conversione e applica l'effetto quando completa
 // Restituisci true immediatamente (operazione in background)
 convertLayerToImage(layer)
 .then(() => {
 console.log(` [${methodName}] Conversione completata, applico effetto`);
 
 // Rimuovi il flag di conversione
 delete layer._isConverting;
 
 // Ora applica l'effetto (il layer è stato modificato in-place)
 const result = originalMethod.call(AdvancedEffects, layer, ...args);
 
 // Log del risultato per debugging
 if (result === false) {
 console.warn(`️ [${methodName}] L'effetto ha restituito false`);
 }
 
 return result;
 })
 .catch(error => {
 console.error(` [${methodName}] Errore conversione:`, error);
 
 // Rimuovi il flag anche in caso di errore
 delete layer._isConverting;
 
 announceExtraAI(`Errore: ${error.message || 'Conversione fallita'}`, 'assertive');
 });
 
 // Restituisci true per indicare che l'operazione è stata avviata
 // (il chiamante non aspetta il completamento - fire and forget)
 return true;
 };
 });
 
 console.log(` ${effectMethods.length} effetti wrappati con conversione automatica`);
 console.log(` Effetti disponibili:`, effectMethods.join(', '));
 
 }, 50); // Controlla ogni 50ms
 
 // Timeout di sicurezza (10 secondi)
 setTimeout(() => {
 clearInterval(checkInterval);
 if (typeof AdvancedEffects === 'undefined') {
 console.error(' Timeout: AdvancedEffects non trovato dopo 10 secondi');
 }
 }, 10000);
})();

const AdvancedEffects={applyPixelate(e,t){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const a=e.imageElement,i=document.createElement("canvas"),n=i.getContext("2d");i.width=a.width,i.height=a.height,n.drawImage(a,0,0);const o=Math.ceil(a.width/t),s=Math.ceil(a.height/t),l=document.createElement("canvas"),c=l.getContext("2d");l.width=o,l.height=s,c.drawImage(i,0,0,o,s),n.imageSmoothingEnabled=!1,n.drawImage(l,0,0,o,s,0,0,a.width,a.height);const r=new Image;return r.onload=()=>{e.imageElement=r,e.imageData=i.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Pixelate applicato (${t}px blocchi)`,"polite")},r.src=i.toDataURL(),!0},applyGlow(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d"),s=Math.ceil(t);n.width=i.width+2*s,n.height=i.height+2*s,o.shadowColor=a,o.shadowBlur=t,o.shadowOffsetX=0,o.shadowOffsetY=0,o.drawImage(i,s,s);const l=Math.ceil(t/30);for(let e=0;e<l;e++)o.drawImage(i,s,s);const c=new Image;return c.onload=()=>{e.imageElement=c,e.imageData=n.toDataURL(),e.width=n.width,e.height=n.height,window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Glow applicato (intensità ${t})`,"polite")},c.src=n.toDataURL(),!0},applyVignette(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=i.width/2,l=i.height/2,c=Math.sqrt(s*s+l*l),r=c*a/100,d=o.createRadialGradient(s,l,r,s,l,c);d.addColorStop(0,"rgba(0,0,0,0)"),d.addColorStop(1,`rgba(0,0,0,${t/100})`),o.fillStyle=d,o.fillRect(0,0,i.width,i.height);const m=new Image;return m.onload=()=>{e.imageElement=m,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Vignette applicato (int ${t}, size ${a})`,"polite")},m.src=n.toDataURL(),!0},applySharpen(e,t){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const a=e.imageElement,i=document.createElement("canvas"),n=i.getContext("2d");i.width=a.width,i.height=a.height,n.drawImage(a,0,0);const o=n.getImageData(0,0,a.width,a.height),s=o.data,l=[0,-1,0,-1,5,-1,0,-1,0],c=t/100,r=new Uint8ClampedArray(s),d=a.width,m=a.height;for(let e=1;e<m-1;e++)for(let t=1;t<d-1;t++)for(let a=0;a<3;a++){let i=0;for(let n=-1;n<=1;n++)for(let o=-1;o<=1;o++){const c=(e+n)*d+(t+o),r=3*(n+1)+(o+1);i+=s[4*c+a]*l[r]}const n=4*(e*d+t)+a,o=s[n];r[n]=o+(i-o)*c}for(let e=0;e<s.length;e++)s[e]=r[e];n.putImageData(o,0,0);const g=new Image;return g.onload=()=>{e.imageElement=g,e.imageData=i.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Sharpen applicato (amount ${t})`,"polite")},g.src=i.toDataURL(),!0},applyAutoLevels(e,t){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const a=e.imageElement,i=document.createElement("canvas"),n=i.getContext("2d");i.width=a.width,i.height=a.height,n.drawImage(a,0,0);const o=n.getImageData(0,0,a.width,a.height),s=o.data;let l=255,c=0,r=255,d=0,m=255,g=0;for(let e=0;e<s.length;e+=4){const t=s[e],a=s[e+1],i=s[e+2];t<l&&(l=t),t>c&&(c=t),a<r&&(r=a),a>d&&(d=a),i<m&&(m=i),i>g&&(g=i)}const u=t/100;for(let e=0;e<s.length;e+=4){const t=c-l>0?255*(s[e]-l)/(c-l):s[e],a=d-r>0?255*(s[e+1]-r)/(d-r):s[e+1],i=g-m>0?255*(s[e+2]-m)/(g-m):s[e+2];s[e]=Math.min(255,Math.max(0,s[e]+(t-s[e])*u)),s[e+1]=Math.min(255,Math.max(0,s[e+1]+(a-s[e+1])*u)),s[e+2]=Math.min(255,Math.max(0,s[e+2]+(i-s[e+2])*u))}n.putImageData(o,0,0);const h=new Image;return h.onload=()=>{e.imageElement=h,e.imageData=i.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Auto Levels applicato (strength ${t})`,"polite")},h.src=i.toDataURL(),!0},applyNoise(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=o.getImageData(0,0,i.width,i.height),l=s.data,c=t/100*255;for(let e=0;e<l.length;e+=4)if("mono"===a){const t=(Math.random()-.5)*c;l[e]+=t,l[e+1]+=t,l[e+2]+=t}else l[e]+=(Math.random()-.5)*c,l[e+1]+=(Math.random()-.5)*c,l[e+2]+=(Math.random()-.5)*c;o.putImageData(s,0,0);const r=new Image;return r.onload=()=>{e.imageElement=r,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Noise/Grain applicato (${a}, amount ${t})`,"polite")},r.src=n.toDataURL(),!0},applyTemperature(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=o.getImageData(0,0,i.width,i.height),l=s.data,c=t/100,r=a/100;for(let e=0;e<l.length;e+=4){const t=c>0?c*20:c*15,a=c>0?-c*10:c*20;l[e]=Math.min(255,Math.max(0,l[e]+t)),l[e+2]=Math.min(255,Math.max(0,l[e+2]+a));const i=r>0?r*15:-r*15,n=r>0?-r*15:r*15;l[e]=Math.min(255,Math.max(0,l[e]+i)),l[e+1]=Math.min(255,Math.max(0,l[e+1]+n))}o.putImageData(s,0,0);const d=new Image;return d.onload=()=>{e.imageElement=d,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Temperature applicato (temp ${t}, tint ${a})`,"polite")},d.src=n.toDataURL(),!0},createGradientText(text,t,a,i,n){const o=document.createElement("canvas"),s=o.getContext("2d");s.font=`bold ${n}px Arial`;const l=s.measureText(text);o.width=Math.ceil(l.width)+20,o.height=n+40,s.font=`bold ${n}px Arial`,s.textBaseline="middle";const c=s.createLinearGradient(0,0,Math.cos(i*Math.PI/180)*o.width,Math.sin(i*Math.PI/180)*o.height);c.addColorStop(0,t),c.addColorStop(1,a),s.fillStyle=c,s.fillText(text,10,o.height/2);const r=new Image;return r.onload=()=>{const newLayer={type:"image",imageElement:r,imageData:o.toDataURL(),x:100,y:100,width:o.width,height:o.height,name:`Gradient Text: ${text.substring(0,15)}...`,visible:!0,locked:!1};window.state&&window.state.layers&&(window.state.layers.push(newLayer),window.state.currentLayerIndex=window.state.layers.length-1,window.updateLayersList&&window.updateLayersList(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Testo gradient creato: "${text}"`,"polite"))},r.src=o.toDataURL(),!0},applyDuotone(e,t,a,i){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const n=e.imageElement,o=document.createElement("canvas"),s=o.getContext("2d");o.width=n.width,o.height=n.height,s.drawImage(n,0,0);const l=s.getImageData(0,0,n.width,n.height),c=l.data;const r=parseInt(t.slice(1,3),16),d=parseInt(t.slice(3,5),16),m=parseInt(t.slice(5,7),16),g=parseInt(a.slice(1,3),16),u=parseInt(a.slice(3,5),16),h=parseInt(a.slice(5,7),16),p=i/100;for(let e=0;e<c.length;e+=4){const t=.299*c[e]+.587*c[e+1]+.114*c[e+2],a=t/255,i=c[e]*(1-p)+p*(r+a*(g-r)),n=c[e+1]*(1-p)+p*(d+a*(u-d)),o=c[e+2]*(1-p)+p*(m+a*(h-m));c[e]=Math.min(255,Math.max(0,i)),c[e+1]=Math.min(255,Math.max(0,n)),c[e+2]=Math.min(255,Math.max(0,o))}s.putImageData(l,0,0);const f=new Image;return f.onload=()=>{e.imageElement=f,e.imageData=o.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Duotone applicato (intensity ${i})`,"polite")},f.src=o.toDataURL(),!0},applyHSLShift(e,t,a,i){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const n=e.imageElement,o=document.createElement("canvas"),s=o.getContext("2d");o.width=n.width,o.height=n.height,s.drawImage(n,0,0);const l=s.getImageData(0,0,n.width,n.height),c=l.data;function rgbToHsl(e,t,a){e/=255,t/=255,a/=255;const i=Math.max(e,t,a),n=Math.min(e,t,a);let o,s,l=(i+n)/2;if(i===n)o=s=0;else{const c=i-n;s=l>.5?c/(2-i-n):c/(i+n),o=i===e?(t-a)/c+(t<a?6:0):i===t?(a-e)/c+2:(e-t)/c+4,o/=6}return[o,s,l]}function hslToRgb(e,t,a){let i,n,o;if(0===t)i=n=o=a;else{const s=(e,t,a)=>(a<0&&(a+=1),a>1&&(a-=1),a<1/6?e+6*(t-e)*a:a<.5?t:a<2/3?e+(t-e)*(2/3-a)*6:e),l=a<.5?a*(1+t):a+t-a*t,c=2*a-l;i=s(c,l,e+1/3),n=s(c,l,e),o=s(c,l,e-1/3)}return[Math.round(255*i),Math.round(255*n),Math.round(255*o)]}for(let e=0;e<c.length;e+=4){let[n,o,s]=rgbToHsl(c[e],c[e+1],c[e+2]);n=(n+t/360+1)%1,o=Math.min(1,Math.max(0,o+a/100)),s=Math.min(1,Math.max(0,s+i/100));const[l,r,d]=hslToRgb(n,o,s);c[e]=l,c[e+1]=r,c[e+2]=d}s.putImageData(l,0,0);const r=new Image;return r.onload=()=>{e.imageElement=r,e.imageData=o.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`HSL Shift applicato (H:${t} S:${a} L:${i})`,"polite")},r.src=o.toDataURL(),!0},applyOilPainting(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=o.getImageData(0,0,i.width,i.height),l=s.data,c=new Uint8ClampedArray(l),r=i.width,d=i.height;for(let e=0;e<a;e++)for(let e=t;e<d-t;e++)for(let a=t;a<r-t;a++){const i=[];for(let n=-t;n<=t;n++)for(let t=-t;t<=t;t++){const o=4*((e+n)*r+(a+t));i.push([l[o],l[o+1],l[o+2]])}i.sort(((e,t)=>{const a=.299*e[0]+.587*e[1]+.114*e[2],i=.299*t[0]+.587*t[1]+.114*t[2];return a-i}));const n=i[Math.floor(i.length/2)],o=4*(e*r+a);c[o]=n[0],c[o+1]=n[1],c[o+2]=n[2]}for(let e=0;e<l.length;e++)l[e]=c[e];o.putImageData(s,0,0);const m=new Image;return m.onload=()=>{e.imageElement=m,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Oil Painting applicato (brush ${t}, int ${a})`,"polite")},m.src=n.toDataURL(),!0},applyBlur(e,t){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const a=e.imageElement,i=document.createElement("canvas"),n=i.getContext("2d");i.width=a.width,i.height=a.height,n.filter=`blur(${t}px)`,n.drawImage(a,0,0);const o=new Image;return o.onload=()=>{e.imageElement=o,e.imageData=i.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Blur applicato (radius ${t})`,"polite")},o.src=i.toDataURL(),!0},applyEmboss(e,t){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const a=e.imageElement,i=document.createElement("canvas"),n=i.getContext("2d");i.width=a.width,i.height=a.height,n.drawImage(a,0,0);const o=n.getImageData(0,0,a.width,a.height),s=o.data,l=new Uint8ClampedArray(s),c=a.width,r=a.height,d=[-2,-1,0,-1,1,1,0,1,2],m=t/100;for(let e=1;e<r-1;e++)for(let t=1;t<c-1;t++)for(let a=0;a<3;a++){let i=0;for(let n=-1;n<=1;n++)for(let o=-1;o<=1;o++){const l=(e+n)*c+(t+o),r=3*(n+1)+(o+1);i+=s[4*l+a]*d[r]}const n=4*(e*c+t)+a;l[n]=Math.min(255,Math.max(0,128+i*m))}for(let e=0;e<s.length;e+=4)s[e]=l[e],s[e+1]=l[e+1],s[e+2]=l[e+2];n.putImageData(o,0,0);const g=new Image;return g.onload=()=>{e.imageElement=g,e.imageData=i.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Emboss applicato (strength ${t})`,"polite")},g.src=i.toDataURL(),!0},applyEdgeDetect(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=o.getImageData(0,0,i.width,i.height),l=s.data,c=new Uint8ClampedArray(s),r=i.width,d=i.height,m=[-1,-1,-1,-1,8,-1,-1,-1,-1],g=t/100*255;for(let e=1;e<d-1;e++)for(let t=1;t<r-1;t++){let a=0;for(let i=-1;i<=1;i++)for(let n=-1;n<=1;n++){const o=4*((e+i)*r+(t+n)),s=3*(i+1)+(n+1),c=.299*l[o]+.587*l[o+1]+.114*l[o+2];a+=c*m[s]}const i=4*(e*r+t),n=Math.abs(a)>g?255:0;c[i]=n,c[i+1]=n,c[i+2]=n,c[i+3]=255}if("true"===a)for(let e=0;e<c.length;e+=4)c[e]=255-c[e],c[e+1]=255-c[e+1],c[e+2]=255-c[e+2];for(let e=0;e<l.length;e++)l[e]=c[e];o.putImageData(s,0,0);const u=new Image;return u.onload=()=>{e.imageElement=u,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Edge Detect applicato (threshold ${t}, ${"true"===a?"invertito":"normale"})`,"polite")},u.src=n.toDataURL(),!0},applyClarity(e,t,a){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const i=e.imageElement,n=document.createElement("canvas"),o=n.getContext("2d");n.width=i.width,n.height=i.height,o.drawImage(i,0,0);const s=o.getImageData(0,0,i.width,i.height);const l=document.createElement("canvas"),c=l.getContext("2d");l.width=i.width,l.height=i.height,c.filter=`blur(${a}px)`,c.drawImage(i,0,0);const r=c.getImageData(0,0,i.width,i.height),d=s.data,m=r.data,g=t/100;for(let e=0;e<d.length;e+=4){for(let t=0;t<3;t++){const a=e+t,i=d[a]-m[a];d[a]=Math.min(255,Math.max(0,d[a]+i*g))}}o.putImageData(s,0,0);const u=new Image;return u.onload=()=>{e.imageElement=u,e.imageData=n.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Clarity applicato (amount ${t}, radius ${a})`,"polite")},u.src=n.toDataURL(),!0},applyDenoise(e,t,a,i){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const n=e.imageElement,o=document.createElement("canvas"),s=o.getContext("2d");o.width=n.width,o.height=n.height,s.drawImage(n,0,0);const l=s.getImageData(0,0,n.width,n.height),c=l.data,r=n.width,d=n.height,m=Math.ceil(t/20)+1,g=a/100,u=t/100;for(let e=0;e<c.length;e+=4){const t=.299*c[e]+.587*c[e+1]+.114*c[e+2];c[e]=t,c[e+1]=t,c[e+2]=t}const h=new Uint8ClampedArray(c);for(let e=m;e<d-m;e++)for(let t=m;t<r-m;t++){let a=0,i=0;for(let n=-m;n<=m;n++)for(let o=-m;o<=m;o++){const s=4*((e+n)*r+(t+o));a+=c[s],i++}const n=4*(e*r+t),o=a/i,s=c[n];h[n]=s+(o-s)*u,h[n+1]=h[n],h[n+2]=h[n]}s.drawImage(n,0,0);const p=s.getImageData(0,0,n.width,n.height),f=p.data;for(let e=0;e<f.length;e+=4){const t=h[e],a=f[e]-t,n=f[e+1]-t,o=f[e+2]-t,s=1-g;f[e]=Math.min(255,Math.max(0,t+a*s)),f[e+1]=Math.min(255,Math.max(0,t+n*s)),f[e+2]=Math.min(255,Math.max(0,t+o*s))}const y=i/100;for(let e=0;e<f.length;e+=4){const t=f[e]-h[e],a=f[e+1]-h[e+1],i=f[e+2]-h[e+2];f[e]=Math.min(255,Math.max(0,f[e]+t*y)),f[e+1]=Math.min(255,Math.max(0,f[e+1]+a*y)),f[e+2]=Math.min(255,Math.max(0,f[e+2]+i*y))}s.putImageData(p,0,0);const b=new Image;return b.onload=()=>{e.imageElement=b,e.imageData=o.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Denoise applicato (luma ${t}, color ${a}, sharp ${i})`,"polite")},b.src=o.toDataURL(),!0},applyGradientMap(e,t,a,i){if(!e||!e.imageElement)return announceExtraAI("Seleziona un livello immagine valido","assertive"),!1;const n=e.imageElement,o=document.createElement("canvas"),s=o.getContext("2d");o.width=n.width,o.height=n.height,s.drawImage(n,0,0);const l=s.getImageData(0,0,n.width,n.height),c=l.data,r=parseInt(t.slice(1,3),16),d=parseInt(t.slice(3,5),16),m=parseInt(t.slice(5,7),16),g=parseInt(a.slice(1,3),16),u=parseInt(a.slice(3,5),16),h=parseInt(a.slice(5,7),16),p=i/100;for(let e=0;e<c.length;e+=4){const t=.299*c[e]+.587*c[e+1]+.114*c[e+2],a=t/255,i=r+a*(g-r),n=d+a*(u-d),o=m+a*(h-m);c[e]=c[e]*(1-p)+i*p,c[e+1]=c[e+1]*(1-p)+n*p,c[e+2]=c[e+2]*(1-p)+o*p}s.putImageData(l,0,0);const f=new Image;return f.onload=()=>{e.imageElement=f,e.imageData=o.toDataURL(),window.scheduleRender&&window.scheduleRender(),announceExtraAI(`Gradient Map applicato (intensity ${i})`,"polite")},f.src=o.toDataURL(),!0}};

// Event Listeners - CORRETTI per permettere conversione automatica forme → immagini

// Pixelate
document.getElementById("pixelate-size")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("pixelate-size-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + " px";
});

document.getElementById("btn-apply-pixelate")?.addEventListener("click", () => {
 const size = parseInt(document.getElementById("pixelate-size").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyPixelate(layer, size);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Glow
document.getElementById("glow-intensity")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("glow-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

// ═══════════════════════════════════════════════════════════════════
// GLOW - Toggle HEX/RGB e sincronizzazione
// ═══════════════════════════════════════════════════════════════════

// Toggle HEX/RGB per Glow
document.querySelectorAll('input[name="glow-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls = document.getElementById('glow-hex-controls');
 const rgbControls = document.getElementById('glow-rgb-controls');
 
 if (format === 'hex') {
 hexControls.style.display = '';
 rgbControls.style.display = 'none';
 announce('Modalità codice HEX attivata per bagliore', 'polite');
 } else {
 hexControls.style.display = 'none';
 rgbControls.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const color = document.getElementById('glow-color-hex').value;
 if (color) syncHexToRgb(color, 'glow-color');
 
 announce('Modalità valori RGB attivata per bagliore', 'polite');
 }
 });
});

// Listener per campo HEX Glow
document.getElementById('glow-color-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('glow-color').value = value;
 syncHexToRgb(value, 'glow-color');
 }
});

// Listener per campi RGB Glow
['glow-color-r', 'glow-color-g', 'glow-color-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('glow-color-r').value) || 0;
 const g = parseInt(document.getElementById('glow-color-g').value) || 0;
 const b = parseInt(document.getElementById('glow-color-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('glow-color-hex').value = hex;
 document.getElementById('glow-color').value = hex;
 });
});

// Listener per color picker Glow
document.getElementById('glow-color')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('glow-color-hex').value = value;
 syncHexToRgb(value, 'glow-color');
});

document.getElementById("btn-apply-glow")?.addEventListener("click", () => {
 const intensity = parseInt(document.getElementById("glow-intensity").value);
 const color = document.getElementById("glow-color").value;
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyGlow(layer, intensity, color);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Vignette
document.getElementById("vignette-intensity")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("vignette-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("vignette-size")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("vignette-size-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-vignette")?.addEventListener("click", () => {
 const intensity = parseInt(document.getElementById("vignette-intensity").value);
 const size = parseInt(document.getElementById("vignette-size").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyVignette(layer, intensity, size);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Sharpen
document.getElementById("sharpen-amount")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("sharpen-amount-value");
 const presetSelect = document.getElementById("sharpen-preset");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
 if (presetSelect) presetSelect.value = "custom";
});

document.getElementById("sharpen-preset")?.addEventListener("change", (e) => {
 const presets = { light: 50, medium: 100, strong: 150 };
 const value = presets[e.target.value];
 const amountSlider = document.getElementById("sharpen-amount");
 const valueDisplay = document.getElementById("sharpen-amount-value");
 if (value && amountSlider) {
 amountSlider.value = value;
 if (valueDisplay) valueDisplay.textContent = value;
 }
});

document.getElementById("btn-apply-sharpen")?.addEventListener("click", () => {
 const amount = parseInt(document.getElementById("sharpen-amount").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applySharpen(layer, amount);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Auto Levels
document.getElementById("autolevels-strength")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("autolevels-strength-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-autolevels")?.addEventListener("click", () => {
 const strength = parseInt(document.getElementById("autolevels-strength").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyAutoLevels(layer, strength);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Noise
document.getElementById("noise-amount")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("noise-amount-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-noise")?.addEventListener("click", () => {
 const amount = parseInt(document.getElementById("noise-amount").value);
 const type = document.getElementById("noise-type").value;
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyNoise(layer, amount, type);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Temperature/Tint
document.getElementById("temperature-value")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("temperature-value-display");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("tint-value")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("tint-value-display");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-temperature")?.addEventListener("click", () => {
 const temp = parseInt(document.getElementById("temperature-value").value);
 const tint = parseInt(document.getElementById("tint-value").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyTemperature(layer, temp, tint);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Gradient Text
document.getElementById("gradient-text-angle")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("gradient-text-angle-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + "°";
});

document.getElementById("gradient-text-font-size")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("gradient-text-font-size-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + "px";
});

document.getElementById("btn-create-gradient-text")?.addEventListener("click", () => {
 const text = document.getElementById("gradient-text-input").value;
 if (!text || text.trim() === "") {
 announceExtraAI("Inserisci un testo da creare", "assertive");
 return;
 }
 const color1 = document.getElementById("gradient-text-color1").value;
 const color2 = document.getElementById("gradient-text-color2").value;
 const angle = parseInt(document.getElementById("gradient-text-angle").value);
 const fontSize = parseInt(document.getElementById("gradient-text-font-size").value);
 AdvancedEffects.createGradientText(text, color1, color2, angle, fontSize);
});

// Duotone
document.getElementById("duotone-intensity")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("duotone-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

// ═══════════════════════════════════════════════════════════════════
// DUOTONE - Toggle HEX/RGB e sincronizzazione
// ═══════════════════════════════════════════════════════════════════

// Toggle HEX/RGB per Duotone
document.querySelectorAll('input[name="duotone-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls1 = document.getElementById('duotone-hex-controls-1');
 const hexControls2 = document.getElementById('duotone-hex-controls-2');
 const rgbControls1 = document.getElementById('duotone-rgb-controls-1');
 const rgbControls2 = document.getElementById('duotone-rgb-controls-2');
 
 if (format === 'hex') {
 hexControls1.style.display = '';
 hexControls2.style.display = '';
 rgbControls1.style.display = 'none';
 rgbControls2.style.display = 'none';
 announce('Modalità codice HEX attivata per duotone', 'polite');
 } else {
 hexControls1.style.display = 'none';
 hexControls2.style.display = 'none';
 rgbControls1.style.display = '';
 rgbControls2.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const color1 = document.getElementById('duotone-color1-hex').value;
 const color2 = document.getElementById('duotone-color2-hex').value;
 if (color1) syncHexToRgb(color1, 'duotone-color1');
 if (color2) syncHexToRgb(color2, 'duotone-color2');
 
 announce('Modalità valori RGB attivata per duotone', 'polite');
 }
 });
});

// Listener per campo HEX Duotone Colore 1
document.getElementById('duotone-color1-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('duotone-color1').value = value;
 syncHexToRgb(value, 'duotone-color1');
 }
});

// Listener per campo HEX Duotone Colore 2
document.getElementById('duotone-color2-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('duotone-color2').value = value;
 syncHexToRgb(value, 'duotone-color2');
 }
});

// Listener per campi RGB Duotone Colore 1
['duotone-color1-r', 'duotone-color1-g', 'duotone-color1-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('duotone-color1-r').value) || 0;
 const g = parseInt(document.getElementById('duotone-color1-g').value) || 0;
 const b = parseInt(document.getElementById('duotone-color1-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('duotone-color1-hex').value = hex;
 document.getElementById('duotone-color1').value = hex;
 });
});

// Listener per campi RGB Duotone Colore 2
['duotone-color2-r', 'duotone-color2-g', 'duotone-color2-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('duotone-color2-r').value) || 0;
 const g = parseInt(document.getElementById('duotone-color2-g').value) || 0;
 const b = parseInt(document.getElementById('duotone-color2-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('duotone-color2-hex').value = hex;
 document.getElementById('duotone-color2').value = hex;
 });
});

// Listener per color picker Duotone Colore 1
document.getElementById('duotone-color1')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('duotone-color1-hex').value = value;
 syncHexToRgb(value, 'duotone-color1');
});

// Listener per color picker Duotone Colore 2
document.getElementById('duotone-color2')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('duotone-color2-hex').value = value;
 syncHexToRgb(value, 'duotone-color2');
});

document.getElementById("btn-apply-duotone")?.addEventListener("click", () => {
 const color1 = document.getElementById("duotone-color1").value;
 const color2 = document.getElementById("duotone-color2").value;
 const intensity = parseInt(document.getElementById("duotone-intensity").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyDuotone(layer, color1, color2, intensity);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// HSL Shift
document.getElementById("hsl-hue")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("hsl-hue-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + "°";
});

document.getElementById("hsl-saturation")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("hsl-saturation-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + "%";
});

document.getElementById("hsl-lightness")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("hsl-lightness-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value + "%";
});

document.getElementById("btn-apply-hsl")?.addEventListener("click", () => {
 const hue = parseInt(document.getElementById("hsl-hue").value);
 const saturation = parseInt(document.getElementById("hsl-saturation").value);
 const lightness = parseInt(document.getElementById("hsl-lightness").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyHSLShift(layer, hue, saturation, lightness);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Oil Painting
document.getElementById("oil-brush-size")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("oil-brush-size-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("oil-intensity")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("oil-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-oil")?.addEventListener("click", () => {
 const brushSize = parseInt(document.getElementById("oil-brush-size").value);
 const intensity = parseInt(document.getElementById("oil-intensity").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyOilPainting(layer, brushSize, intensity);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Blur
document.getElementById("blur-radius")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("blur-radius-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-blur")?.addEventListener("click", () => {
 const radius = parseInt(document.getElementById("blur-radius").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyBlur(layer, radius);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Emboss
document.getElementById("emboss-strength")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("emboss-strength-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-emboss")?.addEventListener("click", () => {
 const strength = parseInt(document.getElementById("emboss-strength").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyEmboss(layer, strength);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Edge Detect
document.getElementById("edge-threshold")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("edge-threshold-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-edge")?.addEventListener("click", () => {
 const threshold = parseInt(document.getElementById("edge-threshold").value);
 const invert = document.getElementById("edge-invert").value;
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyEdgeDetect(layer, threshold, invert);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Clarity
document.getElementById("clarity-amount")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("clarity-amount-value");
 const presetSelect = document.getElementById("clarity-preset");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
 if (presetSelect) presetSelect.value = "custom";
});

document.getElementById("clarity-radius")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("clarity-radius-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("clarity-preset")?.addEventListener("change", (e) => {
 const presets = { subtle: 30, moderate: 50, strong: 80, extreme: 120 };
 const value = presets[e.target.value];
 const amountSlider = document.getElementById("clarity-amount");
 const valueDisplay = document.getElementById("clarity-amount-value");
 if (value && amountSlider) {
 amountSlider.value = value;
 if (valueDisplay) valueDisplay.textContent = value;
 }
});

document.getElementById("btn-apply-clarity")?.addEventListener("click", () => {
 const amount = parseInt(document.getElementById("clarity-amount").value);
 const radius = parseInt(document.getElementById("clarity-radius").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyClarity(layer, amount, radius);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Denoise
document.getElementById("denoise-luminance")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("denoise-luminance-value");
 const presetSelect = document.getElementById("denoise-preset");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
 if (presetSelect) presetSelect.value = "custom";
});

document.getElementById("denoise-color")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("denoise-color-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("denoise-sharpen")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("denoise-sharpen-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("denoise-preset")?.addEventListener("change", (e) => {
 const presets = {
 light: [30, 20, 15],
 moderate: [50, 30, 20],
 strong: [70, 50, 30],
 aggressive: [85, 70, 40]
 };
 const preset = presets[e.target.value];
 if (preset) {
 const lumSlider = document.getElementById("denoise-luminance");
 const colorSlider = document.getElementById("denoise-color");
 const sharpSlider = document.getElementById("denoise-sharpen");
 if (lumSlider) {
 lumSlider.value = preset[0];
 document.getElementById("denoise-luminance-value").textContent = preset[0];
 }
 if (colorSlider) {
 colorSlider.value = preset[1];
 document.getElementById("denoise-color-value").textContent = preset[1];
 }
 if (sharpSlider) {
 sharpSlider.value = preset[2];
 document.getElementById("denoise-sharpen-value").textContent = preset[2];
 }
 }
});

document.getElementById("btn-apply-denoise")?.addEventListener("click", () => {
 const luminance = parseInt(document.getElementById("denoise-luminance").value);
 const color = parseInt(document.getElementById("denoise-color").value);
 const sharpen = parseInt(document.getElementById("denoise-sharpen").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyDenoise(layer, luminance, color, sharpen);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Soft LUT (rimosso dai listener originali ma includo per completezza se esiste)
document.getElementById("softlut-intensity")?.addEventListener("input", e => {
 const valueDisplay = document.getElementById("softlut-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("btn-apply-softlut")?.addEventListener("click", () => {
 const preset = document.getElementById("softlut-preset").value;
 const intensity = parseInt(document.getElementById("softlut-intensity").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applySoftLUT(layer, preset, intensity);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Posterize
document.getElementById("posterize-levels")?.addEventListener("input", e => {
 const valueDisplay = document.getElementById("posterize-levels-value");
 const presetSelect = document.getElementById("posterize-preset");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
 if (presetSelect) presetSelect.value = "custom";
});

document.getElementById("posterize-preset")?.addEventListener("change", e => {
 const presets = { low: 4, medium: 8, high: 16 };
 const levels = presets[e.target.value];
 const input = document.getElementById("posterize-levels");
 const valueDisplay = document.getElementById("posterize-levels-value");
 if (levels && input) {
 input.value = levels;
 if (valueDisplay) valueDisplay.textContent = levels;
 }
});

document.getElementById("btn-apply-posterize")?.addEventListener("click", () => {
 const levels = parseInt(document.getElementById("posterize-levels").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyPosterize(layer, levels);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Invert Colors
document.getElementById("invert-preset")?.addEventListener("change", e => {
 const presets = {
 full: [true, true, true],
 cyan: [false, true, true],
 magenta: [true, false, true],
 yellow: [true, true, false]
 };
 const preset = presets[e.target.value];
 if (preset) {
 const redCheck = document.getElementById("invert-red");
 const greenCheck = document.getElementById("invert-green");
 const blueCheck = document.getElementById("invert-blue");
 if (redCheck) redCheck.checked = preset[0];
 if (greenCheck) greenCheck.checked = preset[1];
 if (blueCheck) blueCheck.checked = preset[2];
 }
});

document.getElementById("btn-apply-invert")?.addEventListener("click", () => {
 const r = document.getElementById("invert-red").checked;
 const g = document.getElementById("invert-green").checked;
 const b = document.getElementById("invert-blue").checked;
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyInvertColors(layer, r, g, b);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});

// Gradient Map
document.getElementById("gradmap-intensity")?.addEventListener("input", (e) => {
 const valueDisplay = document.getElementById("gradmap-intensity-value");
 if (valueDisplay) valueDisplay.textContent = e.target.value;
});

document.getElementById("gradmap-preset")?.addEventListener("change", (e) => {
 const presets = {
 goldenblue: ["#d4a574", "#4a90e2"],
 cyanred: ["#1fa2a6", "#e63946"],
 purpleorange: ["#7209b7", "#f77f00"],
 greenmint: ["#2d6a4f", "#95d5b2"],
 retrowarm: ["#5a3a31", "#f4dfc8"]
 };
 const preset = presets[e.target.value];
 if (preset) {
 const shadowPicker = document.getElementById("gradmap-shadow");
 const highlightPicker = document.getElementById("gradmap-highlight");
 if (shadowPicker) shadowPicker.value = preset[0];
 if (highlightPicker) highlightPicker.value = preset[1];
 }
});

// ═══════════════════════════════════════════════════════════════════
// GRADIENT MAP - Toggle HEX/RGB e sincronizzazione
// ═══════════════════════════════════════════════════════════════════

// Toggle HEX/RGB per Gradient Map
document.querySelectorAll('input[name="gradmap-color-format"]').forEach(radio => {
 radio.addEventListener('change', e => {
 const format = e.target.value;
 const hexControls1 = document.getElementById('gradmap-hex-controls-1');
 const hexControls2 = document.getElementById('gradmap-hex-controls-2');
 const rgbControls1 = document.getElementById('gradmap-rgb-controls-1');
 const rgbControls2 = document.getElementById('gradmap-rgb-controls-2');
 
 if (format === 'hex') {
 hexControls1.style.display = '';
 hexControls2.style.display = '';
 rgbControls1.style.display = 'none';
 rgbControls2.style.display = 'none';
 announce('Modalità codice HEX attivata per gradient map', 'polite');
 } else {
 hexControls1.style.display = 'none';
 hexControls2.style.display = 'none';
 rgbControls1.style.display = '';
 rgbControls2.style.display = '';
 
 // Sincronizza valori RGB con HEX corrente
 const shadow = document.getElementById('gradmap-shadow-hex').value;
 const highlight = document.getElementById('gradmap-highlight-hex').value;
 if (shadow) syncHexToRgb(shadow, 'gradmap-shadow');
 if (highlight) syncHexToRgb(highlight, 'gradmap-highlight');
 
 announce('Modalità valori RGB attivata per gradient map', 'polite');
 }
 });
});

// Listener per campo HEX Shadow
document.getElementById('gradmap-shadow-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('gradmap-shadow').value = value;
 syncHexToRgb(value, 'gradmap-shadow');
 }
});

// Listener per campo HEX Highlight
document.getElementById('gradmap-highlight-hex')?.addEventListener('input', e => {
 const value = e.target.value;
 if (/^#[0-9A-Fa-f]{6}$/.test(value)) {
 document.getElementById('gradmap-highlight').value = value;
 syncHexToRgb(value, 'gradmap-highlight');
 }
});

// Listener per campi RGB Shadow
['gradmap-shadow-r', 'gradmap-shadow-g', 'gradmap-shadow-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('gradmap-shadow-r').value) || 0;
 const g = parseInt(document.getElementById('gradmap-shadow-g').value) || 0;
 const b = parseInt(document.getElementById('gradmap-shadow-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('gradmap-shadow-hex').value = hex;
 document.getElementById('gradmap-shadow').value = hex;
 });
});

// Listener per campi RGB Highlight
['gradmap-highlight-r', 'gradmap-highlight-g', 'gradmap-highlight-b'].forEach(id => {
 document.getElementById(id)?.addEventListener('input', () => {
 const r = parseInt(document.getElementById('gradmap-highlight-r').value) || 0;
 const g = parseInt(document.getElementById('gradmap-highlight-g').value) || 0;
 const b = parseInt(document.getElementById('gradmap-highlight-b').value) || 0;
 const hex = rgbToHex(r, g, b);
 
 document.getElementById('gradmap-highlight-hex').value = hex;
 document.getElementById('gradmap-highlight').value = hex;
 });
});

// Listener per color picker Shadow
document.getElementById('gradmap-shadow')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('gradmap-shadow-hex').value = value;
 syncHexToRgb(value, 'gradmap-shadow');
});

// Listener per color picker Highlight
document.getElementById('gradmap-highlight')?.addEventListener('change', e => {
 const value = e.target.value;
 document.getElementById('gradmap-highlight-hex').value = value;
 syncHexToRgb(value, 'gradmap-highlight');
});

document.getElementById("btn-apply-gradmap")?.addEventListener("click", () => {
 const shadow = document.getElementById("gradmap-shadow").value;
 const highlight = document.getElementById("gradmap-highlight").value;
 const intensity = parseInt(document.getElementById("gradmap-intensity").value);
 const layer = window.state?.layers[window.state?.currentLayerIndex];
 if (layer) {
 AdvancedEffects.applyGradientMap(layer, shadow, highlight, intensity);
 } else {
 announceExtraAI("Seleziona un layer prima", "assertive");
 }
});


console.log(" Effetti Avanzati v41.1 COMPLETO - 17 Effetti (+ Clarity, Denoise, Gradient Map)");



// ════════════════════════════════════════════════════════════════════
// SISTEMA HELP F2 PER EFFETTI AVANZATI
// ════════════════════════════════════════════════════════════════════

window.EffectF2Helps={pixelate:`<h3 style="color:#0369a1"> Cos'è il Pixelate?</h3><p>Trasforma l'immagine in blocchi di pixel visibili, creando un aspetto "mosaico" o "pixel art". Molto usato per:</p><ul><li>Creare grafica in stile retro/8-bit</li><li>Censurare parti di immagine (volti, targhe)</li><li>Effetti artistici e design moderno</li></ul><h3 style="color:#0369a1;margin-top:16px">️ Dimensione Pixel (1-50)</h3><table class="help-table"><tr style="background:#f0f9ff"><th style="padding:6px;border:1px solid #0ea5e9">Valore</th><th style="padding:6px;border:1px solid #0ea5e9">Effetto</th></tr><tr><td class="help-table-cell">1-5 px</td><td class="help-table-cell">Pixelazione sottile, leggera</td></tr><tr><td class="help-table-cell">6-15 px</td><td class="help-table-cell">Media, censura/privacy</td></tr><tr><td class="help-table-cell">16-30 px</td><td class="help-table-cell">Forte, pixel art marcato</td></tr><tr><td class="help-table-cell">31-50 px</td><td class="help-table-cell">Estremo, pattern astratti</td></tr></table><div class="help-box-info"><strong> Consigli:</strong><ul><li>Censura volto: 12-15 px</li><li>Sfondo retro: 20-25 px</li><li>Arte geometrica: 30-40 px</li></ul></div><div class="help-box-danger"><strong>️ ATTENZIONE:</strong><ul><li>Effetto IRREVERSIBILE</li><li>Salva copia prima di applicare</li><li>Non funziona su testo piccolo</li></ul></div>`,glow:`<h3 style="color:#d97706"> Cos'è il Glow?</h3><p>Crea un alone luminoso attorno all'immagine, simile a una luce diffusa. Perfetto per:</p><ul><li>Effetti dream/ethereal (sogno)</li><li>Evidenziare oggetti importanti</li><li>Simulare luci neon</li><li>Design futuristico e cyberpunk</li></ul><h3 style="color:#d97706;margin-top:16px">️ I Parametri</h3><p><strong>Intensità (0-100):</strong></p><table class="help-table"><tr style="background:#fef3c7"><th style="padding:6px;border:1px solid #f59e0b">Valore</th><th style="padding:6px;border:1px solid #f59e0b">Effetto</th></tr><tr><td class="help-table-cell">0-20</td><td class="help-table-cell">Glow sottile, delicato</td></tr><tr><td class="help-table-cell">21-50</td><td class="help-table-cell">Glow medio, bilanciato</td></tr><tr><td class="help-table-cell">51-80</td><td class="help-table-cell">Glow forte, drammatico</td></tr><tr><td class="help-table-cell">81-100</td><td class="help-table-cell">Estremo, abbagliante</td></tr></table><p><strong>Colore Bagliore:</strong></p><ul><li><strong>Bianco (#FFFFFF)</strong>: Luce pura, angelico</li><li><strong>Rosa (#FF69B4)</strong>: Romantico, magico</li><li><strong>Azzurro (#00BFFF)</strong>: Freddo, tecnologico</li><li><strong>Oro (#FFD700)</strong>: Divino, prezioso</li></ul><div style="background:#fef3c7;padding:12px;border-radius:6px;margin:12px 0"><strong> Esempi:</strong><ul><li>Logo tech: Int. 40, Azzurro</li><li>Personaggio magico: Int. 60, Oro</li><li>Neon sign: Int. 70, Rosa fucsia</li></ul></div>`,vignette:`<h3 style="color:#7e22ce"> Cos'è la Vignette?</h3><p>Scurisce progressivamente i bordi e gli angoli dell'immagine, lasciando il centro più luminoso. Usato per:</p><ul><li>Focalizzare l'attenzione sul centro</li><li>Simulare obiettivi vintage (anni '50-'70)</li><li>Creare atmosfera drammatica</li><li>Inquadrare naturalmente il soggetto</li></ul><h3 style="color:#7e22ce;margin-top:16px">️ I Parametri</h3><p><strong>Intensità (0-100):</strong> Quanto sono scuri i bordi</p><table class="help-table"><tr style="background:#f3e8ff"><th style="padding:6px;border:1px solid #a855f7">Valore</th><th style="padding:6px;border:1px solid #a855f7">Effetto</th></tr><tr><td class="help-table-cell">0-25</td><td class="help-table-cell">Sottile, discreto</td></tr><tr><td class="help-table-cell">26-50</td><td class="help-table-cell">Moderata, ritratti</td></tr><tr><td class="help-table-cell">51-75</td><td class="help-table-cell">Forte, drammatico</td></tr><tr><td class="help-table-cell">76-100</td><td class="help-table-cell">Estrema, tunnel vision</td></tr></table><p><strong>Dimensione (10-90):</strong> Area centrale chiara</p><div style="background:#f3e8ff;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Consigliati:</strong><ul><li>Ritratto classico: Int. 40, Size 50</li><li>Vintage film: Int. 60, Size 40</li><li>Cinema noir: Int. 75, Size 35</li><li>Soft & dreamy: Int. 25, Size 70</li></ul></div>`,sharpen:`<h3 style="color:#15803d"> Cos'è lo Sharpen?</h3><p>Aumenta la definizione dei dettagli e dei bordi, rendendo l'immagine più "crisp" e definita. Fondamentale per:</p><ul><li>Correggere foto leggermente sfocate</li><li>Enfatizzare texture e dettagli</li><li>Compensare resize/compressione</li><li>Preparare immagini per stampa</li></ul><h3 style="color:#15803d;margin-top:16px">️ Preset e Intensità</h3><table class="help-table"><tr style="background:#dcfce7"><th style="padding:6px;border:1px solid #22c55e">Preset</th><th style="padding:6px;border:1px solid #22c55e">Valore</th><th style="padding:6px;border:1px solid #22c55e">Quando Usare</th></tr><tr><td class="help-table-cell">Leggero</td><td class="help-table-cell">50</td><td class="help-table-cell">Ritocco sottile</td></tr><tr><td class="help-table-cell">Medio</td><td class="help-table-cell">100</td><td class="help-table-cell">Uso generale</td></tr><tr><td class="help-table-cell">Forte</td><td class="help-table-cell">150</td><td class="help-table-cell">Foto molto soft</td></tr></table><div class="help-box-success"><strong> Ideale per:</strong><ul><li>Foto leggermente mosse</li><li>Immagini ridimensionate</li><li>Enfatizzare texture (legno, tessuti)</li><li>Preparazione stampa</li></ul></div><div class="help-box-danger"><strong>️ NON usare su:</strong><ul><li>Foto già nitide (crea aloni)</li><li>Ritratti femminili (enfatizza imperfezioni)</li><li>Foto molto sfocate (peggiora)</li><li>Cielo e gradienti (crea rumore)</li></ul></div><p><strong> Regola d'oro:</strong> Se hai dubbi, è troppo! Inizia conservativo e aumenta gradualmente.</p>`,autolevels:`<h3 style="color:#b91c1c"> Auto Levels - Lo Strumento Chirurgico</h3>

<div style="background:#fee2e2;padding:16px;border-radius:8px;margin:16px 0;border-left:4px solid #ef4444">
<strong>️ IMPORTANTE:</strong> Auto Levels NON è un "super brightness" o "super contrast"!<br>
È un'altra cosa completamente diversa.
</div>

<h3 style="color:#b91c1c;margin-top:20px"> Cosa Fa Davvero?</h3>
<p>Auto Levels è uno strumento <strong>di precisione</strong> che:</p>
<ul style="font-size:15px;line-height:1.6">
<li> <strong>Recupera dettagli nelle ombre</strong> → Quelle zone completamente nere dove non si vede niente? Le schiarisce e ti fa vedere cosa c'è dentro</li>
<li>️ <strong>Sistema i bianchi bruciati</strong> → Quelle zone completamente bianche senza dettagli? Le scurisce un po' per far tornare i dettagli</li>
<li> <strong>Ridistribuisce i mezzi toni</strong> → Migliora come sono distribuiti i colori intermedi (né troppo chiari né troppo scuri)</li>
<li> <strong>Corregge errori di esposizione</strong> → Se la foto è venuta male (troppo scura o troppo chiara), la sistema</li>
</ul>

<h3 style="color:#b91c1c;margin-top:20px"> Quando Usare Cosa?</h3>

<table style="width:100%;border-collapse:collapse;margin:16px 0;font-size:14px">
<tr style="background:#fef2f2">
<th style="padding:12px;border:1px solid #ef4444;text-align:left">Strumento</th>
<th style="padding:12px;border:1px solid #ef4444;text-align:left">Quando Usarlo</th>
</tr>
<tr>
<td style="padding:10px;border:1px solid #cbd5e1"><strong>Brightness</strong></td>
<td style="padding:10px;border:1px solid #cbd5e1">La foto è un po' scura o chiara → aggiusto veloce</td>
</tr>
<tr style="background:#fef2f2">
<td style="padding:10px;border:1px solid #cbd5e1"><strong>Contrast</strong></td>
<td style="padding:10px;border:1px solid #cbd5e1">La foto è "spenta" o "piatta" → do più vivacità</td>
</tr>
<tr>
<td style="padding:10px;border:1px solid #cbd5e1"><strong>Auto Levels</strong></td>
<td style="padding:10px;border:1px solid #cbd5e1">Ci sono zone NERE PECE o BIANCHE BRUCIATE dove ho perso dettagli → le recupero</td>
</tr>
</table>

<h3 style="color:#b91c1c;margin-top:20px"> Quando Funziona Benissimo</h3>
<ul style="font-size:14px;line-height:1.6">
<li>Foto con <strong>ombre troppo scure</strong> (tipo quando fotografi controluce)</li>
<li>Foto con <strong>luci bruciate</strong> (tipo cielo completamente bianco)</li>
<li>Scansioni di foto vecchie sbiadite</li>
<li>Foto venute male per esposizione sbagliata</li>
</ul>

<h3 style="color:#b91c1c;margin-top:20px">️ Quando NON Usarlo</h3>
<ul style="font-size:14px;line-height:1.6">
<li>Se la foto è già ok → può peggiorare</li>
<li>Per dominanti di colore (tipo tutta blu o arancione) → usa Temperature invece</li>
</ul>

<h3 style="color:#b91c1c;margin-top:20px"> Come Usarlo (Passo Passo)</h3>
<ol style="font-size:14px;line-height:1.8">
<li><strong>Prova al 100%</strong> → Applica e guarda</li>
<li>Troppo forte? → Riduci l'intensità a 50-70</li>
<li>Ancora troppo "piatta"? → Aggiungi Contrast +10/+20</li>
<li>Vuoi un mood particolare? → Gioca con Temperature</li>
</ol>

<div style="background:#dbeafe;padding:16px;border-radius:8px;margin:20px 0">
<strong> Ricorda:</strong><br>
• Brightness = "Voglio solo schiarire/scurire tutto"<br>
• Contrast = "Voglio rendere la foto più vivace"<br>
• Auto Levels = "Ho PERSO dettagli nelle ombre/luci, voglio recuperarli"
</div>`,noise:`<h3 style="color:#6d28d9"> Cos'è Noise/Grain?</h3><p>Aggiunge texture granulosa all'immagine simulando la grana fotografica delle pellicole analogiche. Crea atmosfera vintage e cinematografica. Perfetto per:</p><ul><li>Effetti film anni '60-'80</li><li>Look cinematografico professionale</li><li>Ridurre l'aspetto "troppo digitale"</li><li>Arte fotografica e progetti nostalgici</li></ul><h3 style="color:#6d28d9;margin-top:16px">️ I Parametri</h3><p><strong>Tipo Grana:</strong></p><table class="help-table"><tr style="background:#f5f3ff"><th style="padding:6px;border:1px solid #8b5cf6">Tipo</th><th style="padding:6px;border:1px solid #8b5cf6">Effetto</th></tr><tr><td class="help-table-cell">Monocromatica</td><td class="help-table-cell">B&N film, uniforme, classica</td></tr><tr><td class="help-table-cell">Colorata</td><td class="help-table-cell">Film a colori, più vivace</td></tr></table><p><strong>Quantità (0-100):</strong></p><table class="help-table"><tr style="background:#f5f3ff"><th style="padding:6px;border:1px solid #8b5cf6">Valore</th><th style="padding:6px;border:1px solid #8b5cf6">Effetto</th></tr><tr><td class="help-table-cell">5-15</td><td class="help-table-cell">Sottile, fotografico</td></tr><tr><td class="help-table-cell">16-35</td><td class="help-table-cell">Moderato, vintage evidente</td></tr><tr><td class="help-table-cell">36-60</td><td class="help-table-cell">Forte, pellicola molto evidente</td></tr><tr><td class="help-table-cell">61-100</td><td class="help-table-cell">Estremo, effetto artistico</td></tr></table><div style="background:#f5f3ff;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Film Classici:</strong><ul><li>Kodak Portra (colori): Colorata, 12-18</li><li>Ilford HP5 (B&N): Mono, 20-25</li><li>Cinestill 800T: Colorata, 25-30</li><li>Fujifilm 400H: Colorata, 10-15</li></ul></div>`,temperature:`<h3 style="color:#c2410c"> Cos'è Temperature?</h3><p>Regola il bilanciamento del bianco simulando diverse temperature di luce Kelvin. Permette di rendere le foto più calde (arancio/giallo) o fredde (blu), proprio come fanno le fotocamere professionali. Usato per:</p><ul><li>Correggere dominanti di colore indesiderate</li><li>Creare mood specifici (tramonto caldo, alba fredda)</li><li>Simulare diverse condizioni di illuminazione</li><li>Color grading cinematografico</li></ul><h3 style="color:#c2410c;margin-top:16px">️ I Controlli</h3><p><strong>Temperature (-100 a +100):</strong></p><table class="help-table"><tr style="background:#fff7ed"><th style="padding:6px;border:1px solid #fb923c">Valore</th><th style="padding:6px;border:1px solid #fb923c">Effetto</th><th style="padding:6px;border:1px solid #fb923c">Simula</th></tr><tr><td class="help-table-cell">-100 a -50</td><td class="help-table-cell">️ Molto freddo, blu intenso</td><td class="help-table-cell">Luce giorno inverno</td></tr><tr><td class="help-table-cell">-49 a -20</td><td class="help-table-cell"> Freddo moderato</td><td class="help-table-cell">Ombra, cielo nuvoloso</td></tr><tr><td class="help-table-cell">-19 a +19</td><td class="help-table-cell">️ Neutro/Naturale</td><td class="help-table-cell">Luce giorno bilanciata</td></tr><tr><td class="help-table-cell">+20 a +49</td><td class="help-table-cell"> Caldo moderato</td><td class="help-table-cell">Tramonto, golden hour</td></tr><tr><td class="help-table-cell">+50 a +100</td><td class="help-table-cell"> Molto caldo, arancio intenso</td><td class="help-table-cell">Luce candela, fuoco</td></tr></table><p><strong>Tinta (-50 a +50):</strong> Regola il bilanciamento verde/magenta</p><ul><li>Negativo: Aggiunge verde (correzione luci fluorescenti)</li><li>Positivo: Aggiunge magenta (pelle più rosata)</li></ul><div class="help-box-warning"><strong> Preset Cinematografici:</strong><ul><li>Teal & Orange: Temp +30, Tint +10</li><li>Nordic Cold: Temp -40, Tint -5</li><li>Warm Nostalgia: Temp +45, Tint +15</li><li>Matrix Green: Temp -15, Tint -30</li></ul></div>`,gradienttext:`<h3 style="color:#be185d"> Cos'è Gradient Text?</h3><p>Crea testo con sfumature di colore personalizzate, perfetto per loghi, titoli e design moderno. Il testo viene generato come immagine vettoriale di alta qualità che puoi posizionare e ridimensionare liberamente. Usato per:</p><ul><li>Loghi e branding moderni</li><li>Titoli accattivanti per social media</li><li>Design web e poster</li><li>Typography artistica</li></ul><h3 style="color:#be185d;margin-top:16px"> I Parametri</h3><p><strong>Testo:</strong> Max 50 caratteri consigliati per leggibilità</p><p><strong>Colori:</strong> Scegli 2 colori che si fondono bene insieme</p><table class="help-table"><tr style="background:#fce7f3"><th style="padding:6px;border:1px solid #ec4899">Combo Colori</th><th style="padding:6px;border:1px solid #ec4899">Effetto/Mood</th></tr><tr><td class="help-table-cell">Rosa → Viola</td><td class="help-table-cell">Romantico, femminile</td></tr><tr><td class="help-table-cell">Blu → Verde</td><td class="help-table-cell">Tech, fresco, naturale</td></tr><tr><td class="help-table-cell">Arancio → Rosso</td><td class="help-table-cell">Energico, passionale</td></tr><tr><td class="help-table-cell">Oro → Arancio</td><td class="help-table-cell">Lusso, calore</td></tr><tr><td class="help-table-cell">Viola → Blu</td><td class="help-table-cell">Misterioso, notturno</td></tr></table><p><strong>Angolo Sfumatura (0-360°):</strong></p><ul><li>0°/180°: Orizzontale (sinistra→destra)</li><li>90°/270°: Verticale (alto→basso)</li><li>45°/135°: Diagonale</li></ul><p><strong>Dimensione Font (20-200px):</strong></p><ul><li>20-40px: Testo corpo, didascalie</li><li>41-80px: Titoli standard</li><li>81-150px: Titoli grandi, hero</li><li>151-200px: Display, poster</li></ul><div style="background:#fce7f3;padding:12px;border-radius:6px;margin:12px 0"><strong> Pro Tips:</strong><ul><li>Usa font bold per gradients più visibili</li><li>Colori simili = transizione soft</li><li>Colori complementari = contrasto forte</li><li>Angolo 45° = effetto dinamico classico</li></ul></div><div class="help-box-danger"><strong>️ Nota:</strong> Il testo viene creato come immagine raster. Per modificarlo, dovrai ricrearlo con parametri diversi.</div>`,blur:`<h3 style="color:#075985"> Cos'è il Blur?</h3><p>Applica una sfocatura gaussiana morbida che simula l'effetto depth-of-field delle fotocamere professionali. Perfetto per:</p><ul><li>Effetti bokeh e sfondi sfocati</li><li>Creare atmosfera dream/soft</li><li>Ridurre noise e imperfezioni</li><li>Simulare motion blur</li></ul><h3 style="color:#075985;margin-top:16px">️ Raggio Sfocatura (0-50)</h3><table class="help-table"><tr style="background:#e0f2fe"><th style="padding:6px;border:1px solid #0284c7">Valore</th><th style="padding:6px;border:1px solid #0284c7">Effetto</th></tr><tr><td class="help-table-cell">0-5</td><td class="help-table-cell">Soft focus leggero</td></tr><tr><td class="help-table-cell">6-15</td><td class="help-table-cell">Blur medio, bokeh</td></tr><tr><td class="help-table-cell">16-30</td><td class="help-table-cell">Forte, sfondo completamente sfocato</td></tr><tr><td class="help-table-cell">31-50</td><td class="help-table-cell">Estremo, abstract</td></tr></table><div style="background:#e0f2fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Usi creativi:</strong><ul><li>Ritratto elegante: 8-12</li><li>Background blur: 15-25</li><li>Dream effect: 20-30</li><li>Nascondere dettagli: 35-50</li></ul></div>`,emboss:`<h3 style="color:#9f1239"> Cos'è l'Emboss?</h3><p>Trasforma l'immagine in un bassorilievo 3D, simulando una scultura o incisione. Evidenzia bordi e contorni creando un effetto di profondità. Usato per:</p><ul><li>Effetti di rilievo e scultura</li><li>Design artistico e loghi</li><li>Simulare incisioni e medaglioni</li><li>Creare texture 3D da immagini flat</li></ul><h3 style="color:#9f1239;margin-top:16px">️ Intensità (0-200)</h3><table class="help-table"><tr style="background:#fce7f3"><th style="padding:6px;border:1px solid #db2777">Valore</th><th style="padding:6px;border:1px solid #db2777">Effetto</th></tr><tr><td class="help-table-cell">0-50</td><td class="help-table-cell">Rilievo sottile, elegante</td></tr><tr><td class="help-table-cell">51-100</td><td class="help-table-cell">Medio, bassorilievo classico</td></tr><tr><td class="help-table-cell">101-150</td><td class="help-table-cell">Forte, effetto incisione</td></tr><tr><td class="help-table-cell">151-200</td><td class="help-table-cell">Estremo, altorilievo drammatico</td></tr></table><div style="background:#fce7f3;padding:12px;border-radius:6px;margin:12px 0"><strong> Suggerimenti artistici:</strong><ul><li>Logo metallico: 80-100</li><li>Monete/medaglie: 120-140</li><li>Arte scultorea: 150-180</li><li>Texture leather: 60-80</li></ul></div><div class="help-box-danger"><strong> Tip Pro:</strong> Funziona meglio su immagini con contrasto alto e dettagli definiti</div>`,edgedetect:`<h3 style="color:#5b21b6"> Cos'è l'Edge Detect?</h3><p>Estrae i contorni e le linee principali dell'immagine, creando un disegno al tratto. Simula disegni tecnici, sketch artistici e arte lineare. Perfetto per:</p><ul><li>Creare disegni da colorare</li><li>Schizzi e bozze artistiche</li><li>Design tecnico e blueprints</li><li>Analisi di forme e strutture</li><li>Base per colorazione manuale</li></ul><h3 style="color:#5b21b6;margin-top:16px">️ I Parametri</h3><p><strong>Soglia Sensibilità (0-100):</strong> Quanto devono essere forti i bordi per essere rilevati</p><table class="help-table"><tr style="background:#ddd6fe"><th style="padding:6px;border:1px solid #7c3aed">Valore</th><th style="padding:6px;border:1px solid #7c3aed">Effetto</th></tr><tr><td class="help-table-cell">0-20</td><td class="help-table-cell">Sensibile, molti dettagli</td></tr><tr><td class="help-table-cell">21-40</td><td class="help-table-cell">Bilanciato, contorni principali</td></tr><tr><td class="help-table-cell">41-70</td><td class="help-table-cell">Selettivo, solo bordi forti</td></tr><tr><td class="help-table-cell">71-100</td><td class="help-table-cell">Minimalista, essenziale</td></tr></table><p><strong>Stile Output:</strong></p><ul><li><strong>Bordi Neri su Bianco:</strong> Classico, disegno tecnico/coloring book</li><li><strong>Bordi Bianchi su Nero:</strong> Artistico, effetto neon/chalk art</li></ul><div style="background:#ddd6fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Applicazioni Creative:</strong><ul><li>Coloring book: Threshold 30, Nero su Bianco</li><li>Sketch artistico: Threshold 25, Nero su Bianco</li><li>Neon art: Threshold 35, Bianco su Nero</li><li>Blueprint tecnico: Threshold 40, Nero su Bianco</li></ul></div>`,clarity:`<h3 style="color:#a16207"> Cos'è Clarity / Local Contrast?</h3><p>Aumenta il micro-contrasto locale senza alterare contrasto ed esposizione globale. A differenza dello Sharpen che enfatizza solo i bordi, Clarity lavora sulle transizioni tonali medie, rendendo texture e dettagli più definiti e "pop". Essenziale per:</p><ul><li>Fotografia paesaggistica (texture rocce, alberi, nuvole)</li><li>Ritratti maschili e caratteriali</li><li>Architettura e dettagli urbani</li><li>Product photography professionale</li><li>Recuperare dettagli da foto "flat"</li></ul><h3 style="color:#a16207;margin-top:16px">️ I Parametri</h3><p><strong>Intensità (0-150):</strong> Quanto aumentare il micro-contrasto</p><table class="help-table"><tr style="background:#fef9c3"><th style="padding:6px;border:1px solid #eab308">Valore</th><th style="padding:6px;border:1px solid #eab308">Effetto</th><th style="padding:6px;border:1px solid #eab308">Uso Ideale</th></tr><tr><td class="help-table-cell">0-30</td><td class="help-table-cell"> Sottile, naturale</td><td class="help-table-cell">Ritratti femminili delicati</td></tr><tr><td class="help-table-cell">31-60</td><td class="help-table-cell"> Moderato, bilanciato</td><td class="help-table-cell">Uso generale, paesaggi</td></tr><tr><td class="help-table-cell">61-100</td><td class="help-table-cell"> Forte, drammatico</td><td class="help-table-cell">Architettura, dettagli macro</td></tr><tr><td class="help-table-cell">101-150</td><td class="help-table-cell"> Estremo, HDR effect</td><td class="help-table-cell">Effetti artistici, urban grunge</td></tr></table><p><strong>Raggio (1-10 px):</strong> Dimensione dell'area di analisi</p><ul><li><strong>1-3 px:</strong> Micro-dettagli (texture pelle, tessuti)</li><li><strong>4-6 px:</strong> Bilanciato (uso generale)</li><li><strong>7-10 px:</strong> Macro-texture (rocce, nuvole, fogliame)</li></ul><div style="background:#fef9c3;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Consigliati:</strong><ul><li><strong>Ritratto Maschile:</strong> Int. 40, Radius 4</li><li><strong>Paesaggio Drammatico:</strong> Int. 70, Radius 6</li><li><strong>Architettura:</strong> Int. 85, Radius 5</li><li><strong>Fashion Beauty (delicato):</strong> Int. 25, Radius 3</li><li><strong>HDR Effect:</strong> Int. 120, Radius 7</li></ul></div><div class="help-box-success"><strong>🆚 Clarity vs Sharpen:</strong><ul><li><strong>Sharpen:</strong> Enfatizza SOLO i bordi/contorni</li><li><strong>Clarity:</strong> Aumenta contrasto nelle zone DI TRANSIZIONE tonale (non solo bordi)</li><li>Risultato: Clarity rende l'intera immagine più "presente" e 3D</li></ul></div><div class="help-box-danger"><strong>️ EVITA su:</strong><ul><li>Ritratti beauty femminili (enfatizza imperfezioni)</li><li>Skin close-up (crea texture innaturale)</li><li>Foto già contrastate (diventa grungy)</li><li>Cieli sereni uniformi (crea banding)</li></ul></div><p><strong> Pro Tip:</strong> Combina Clarity (50) + Denoise leggero (30) per foto nitide ma pulite!</p>`,denoise:`<h3 style="color:#166534"> Cos'è Denoise (Riduzione Rumore)?</h3><p>Rimuove il rumore digitale (grain indesiderato) mantenendo i dettagli importanti. Algoritmo avanzato che tratta separatamente rumore di luminanza (B&N) e crominanza (colore). Fondamentale per:</p><ul><li>Foto scattate con ISO alto (3200+)</li><li>Immagini notturne o sottoesposte</li><li>Pulizia di vecchie foto digitalizzate</li><li>Video frame con grain eccessivo</li><li>Preparazione per stampa professionale</li></ul><h3 style="color:#166534;margin-top:16px">️ I 3 Controlli Separati</h3><p><strong>1. Riduzione Luminanza (0-100):</strong> Rumore B&N "granuloso"</p><table class="help-table"><tr style="background:#f0fdf4"><th style="padding:6px;border:1px solid #16a34a">Valore</th><th style="padding:6px;border:1px solid #16a34a">Effetto</th></tr><tr><td class="help-table-cell">0-30</td><td class="help-table-cell">Pulizia leggera (ISO 800-1600)</td></tr><tr><td class="help-table-cell">31-60</td><td class="help-table-cell">Moderata (ISO 1600-3200)</td></tr><tr><td class="help-table-cell">61-85</td><td class="help-table-cell">Forte (ISO 3200-6400)</td></tr><tr><td class="help-table-cell">86-100</td><td class="help-table-cell">Aggressiva (ISO 6400+)</td></tr></table><p><strong>2. Riduzione Colore (0-100):</strong> Macchie colorate random (chroma noise)</p><ul><li><strong>0-20:</strong> Pulizia sottile</li><li><strong>21-40:</strong> Moderata (tipico per ISO 1600+)</li><li><strong>41-70:</strong> Forte (ISO alto + scarsa luce)</li><li><strong>71-100:</strong> Massima (noise estremo)</li></ul><p><strong>3. Recupero Dettagli (0-100):</strong> Sharpening post-denoise</p><ul><li><strong>0-15:</strong> Soft, smooth (ritratti beauty)</li><li><strong>16-30:</strong> Bilanciato (uso generale)</li><li><strong>31-50:</strong> Dettagliato (paesaggi, architettura)</li><li><strong>51-100:</strong> Crisp (macro, prodotti)</li></ul><div style="background:#f0fdf4;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset per Scenario:</strong><ul><li><strong>ISO 800-1600 (leggero):</strong> Lum 30, Color 20, Sharp 15</li><li><strong>ISO 1600-3200 (moderato):</strong> Lum 50, Color 30, Sharp 20</li><li><strong>ISO 3200-6400 (forte):</strong> Lum 70, Color 50, Sharp 30</li><li><strong>ISO 6400+ (aggressivo):</strong> Lum 85, Color 70, Sharp 40</li><li><strong>Ritratto Notturno:</strong> Lum 60, Color 45, Sharp 15 (skin smooth)</li></ul></div><div class="help-box-info"><strong> Come Funziona (Tecnico):</strong><ol class="help-list"><li>Converte immagine in B&N per analizzare rumore luminanza</li><li>Applica filtro mediano per smoothing rumore luma</li><li>Riapplica colori originali riducendo saturazione delle variazioni random (chroma noise)</li><li>Applica micro-sharpen controllato per recuperare dettagli persi</li></ol></div><div class="help-box-danger"><strong>️ Trade-off Inevitabili:</strong><ul><li>Denoise troppo alto = perdita texture naturali (pelle "plastica")</li><li>Su foto già nitide = può creare artefatti</li><li>Non può recuperare dettagli già persi da noise estremo</li><li><strong>Regola d'oro:</strong> Parti conservativo, aumenta gradualmente fino al minimo accettabile</li></ul></div><p><strong> Workflow Pro:</strong> Denoise PRIMA di altri effetti (Clarity, Sharpen) per risultati ottimali!</p>`,gradientmap:`<h3 style="color:#86198f"> Cos'è Gradient Map (Rimappa Tonalità)?</h3><p>Rimappa i valori tonali dell'immagine (dal nero al bianco) su un gradiente di colore personalizzato. Tecnica pro di color grading usata in cinema, fotografia commerciale e design. Permette di:</p><ul><li>Creare look cinematografici distintivi</li><li>Color grading professionale stile Hollywood</li><li>Effetti creativi e atmosfere specifiche</li><li>Trasformare foto B&N in duotone artistici</li><li>Unificare palette colori di progetti complessi</li></ul><h3 style="color:#86198f;margin-top:16px"> Come Funziona</h3><p>Prende la luminosità di ogni pixel e la "traduce" in un colore dal gradiente:</p><ul><li><strong>Pixel scuri (ombre) →</strong> Colore Ombre (primo colore)</li><li><strong>Pixel medi (mezzitoni) →</strong> Mix/transizione tra i 2 colori</li><li><strong>Pixel chiari (luci) →</strong> Colore Luci (secondo colore)</li></ul><h3 style="color:#86198f;margin-top:16px">️ I Parametri</h3><p><strong>Colore Ombre:</strong> Applicato alle zone scure</p><p><strong>Colore Luci:</strong> Applicato alle zone chiare</p><p><strong>Intensità Mix (0-100%):</strong> Quanto sostituire vs mescolare</p><table class="help-table"><tr style="background:#fae8ff"><th style="padding:6px;border:1px solid #c026d3">Valore</th><th style="padding:6px;border:1px solid #c026d3">Effetto</th></tr><tr><td class="help-table-cell">0-30</td><td class="help-table-cell">Sottile, tinta leggera</td></tr><tr><td class="help-table-cell">31-60</td><td class="help-table-cell">Bilanciato, look evidente ma naturale</td></tr><tr><td class="help-table-cell">61-85</td><td class="help-table-cell">Forte, grading cinematografico</td></tr><tr><td class="help-table-cell">86-100</td><td class="help-table-cell">Totale, sostituzione completa</td></tr></table><div style="background:#fae8ff;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Cinematografici Famosi:</strong><ul><li><strong>Golden Hour (oro→blu):</strong> #d4a574 → #4a90e2, Int. 70<br>Effetto: Sunset warm con ombre fredde (Instagram favorite)</li><li><strong>Teal & Orange (ciano→rosso):</strong> #1fa2a6 → #e63946, Int. 75<br>Effetto: Hollywood blockbuster, Michael Bay style</li><li><strong>Sunset Dream (viola→arancio):</strong> #7209b7 → #f77f00, Int. 65<br>Effetto: Tramonto magico, ethereal</li><li><strong>Nature Fresh (verde→menta):</strong> #2d6a4f → #95d5b2, Int. 60<br>Effetto: Fresco, naturale, eco-friendly</li><li><strong>Retro Warm (marrone→crema):</strong> #5a3a31 → #f4dfc8, Int. 70<br>Effetto: Vintage '70s, polaroid nostalgica</li></ul></div><div style="background:#e0f2fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Regole Color Theory per Gradient Map:</strong><ol class="help-list"><li><strong>Colori Complementari</strong> (opposti ruota cromatica) = contrasto drammatico<br>Es: Blu/Arancio, Rosso/Ciano, Giallo/Viola</li><li><strong>Colori Analoghi</strong> (vicini ruota) = transizione armoniosa<br>Es: Arancio/Rosso, Blu/Verde, Viola/Rosso</li><li><strong>Monocromatico</strong> (stesso hue, diversa saturazione) = elegante, minimal<br>Es: Blu scuro → Blu chiaro</li><li><strong>Contrasto Temperatura</strong> = look professionale<br>Ombre fredde (blu/ciano) + Luci calde (arancio/giallo)</li></ol></div><div class="help-box-success"><strong> Applicazioni Specifiche:</strong><ul><li><strong>Ritratti:</strong> Ombre blu/viola (#3b4d8f) + Luci pesca (#ffd4b8), Int 50</li><li><strong>Paesaggi:</strong> Ombre verde scuro + Luci giallo caldo, Int 60</li><li><strong>Urban Night:</strong> Ombre nero/blu + Luci ciano/bianco, Int 80</li><li><strong>Duotone Artistico:</strong> 2 colori qualsiasi, Int 100 (sostituzione totale)</li></ul></div><div class="help-box-danger"><strong>️ Errori Comuni:</strong><ul><li>Intensità troppo alta su ritratti = pelle innaturale</li><li>Colori troppo saturi = look "cheap" e amatoriale</li><li>Ignorare contrasto temperatura = risultato flat</li><li><strong>Fix:</strong> Usa sempre colori leggermente desaturati per look pro!</li></ul></div><p><strong> Workflow Pro:</strong> Applica Gradient Map DOPO correzioni exposure ma PRIMA di Clarity/Sharpen per color grading cinematografico perfetto!</p>`,
vibrance:`<h3 style="color:#ec4899"> Cos'è Vibrance?</h3><p>Aumenta l'intensità dei colori in modo intelligente, preservando i toni della pelle e agendo principalmente sui colori desaturati. A differenza della saturazione che amplifica tutti i colori uniformemente, Vibrance è selettivo e protettivo. Perfetto per:</p><ul><li>Rendere più vivide foto sbiadite senza esagerare</li><li>Ritratti (non altera troppo il tono della pelle)</li><li>Paesaggi naturali (cieli, vegetazione)</li><li>Correggere foto piatte mantenendo naturalezza</li></ul><h3 style="color:#ec4899;margin-top:16px">️ Intensità (-100 a +100)</h3><table class="help-table"><tr style="background:#fce7f3"><th style="padding:6px;border:1px solid #ec4899">Valore</th><th style="padding:6px;border:1px solid #ec4899">Effetto</th></tr><tr><td class="help-table-cell">-100 a -50</td><td class="help-table-cell">Desaturazione forte (verso B&N)</td></tr><tr><td class="help-table-cell">-49 a -20</td><td class="help-table-cell">Colori smorzati, vintage</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">Nessun cambiamento</td></tr><tr><td class="help-table-cell">+1 a +30</td><td class="help-table-cell">Vivacità naturale, uso quotidiano</td></tr><tr><td class="help-table-cell">+31 a +60</td><td class="help-table-cell">Colori pop, social media</td></tr><tr><td class="help-table-cell">+61 a +100</td><td class="help-table-cell">Iper-saturato, artistico</td></tr></table><div style="background:#fce7f3;padding:12px;border-radius:6px;margin:12px 0"><strong>🆚 Vibrance vs Saturazione:</strong><ul><li><strong>Saturazione:</strong> Aumenta TUTTI i colori uniformemente (rischio oversaturation)</li><li><strong>Vibrance:</strong> Aumenta SOLO colori deboli, protegge toni pelle</li><li>Risultato: Vibrance è più sicuro e naturale per ritratti</li></ul></div><div class="help-box-success"><strong> Ideale per:</strong><ul><li>Ritratti all'aperto (vivacizza sfondo senza alterare pelle)</li><li>Foto di paesaggi naturali</li><li>Correzione foto scattate in giornate nuvolose</li><li>Food photography (colori appetitosi)</li></ul></div><div class="help-box-danger"><strong>️ ATTENZIONE su:</strong><ul><li>Foto già molto sature (crea colori innaturali)</li><li>Cieli sereni uniformi (possono diventare artificiali)</li></ul></div><p><strong> Pro Tip:</strong> Per ritratti, usa Vibrance +20/+30 invece di Saturazione per risultati naturali!</p>`,
whitebalance:`<h3 style="color:#f97316"> Cos'è White Balance Pro?</h3><p>Sistema avanzato di bilanciamento del bianco che simula le impostazioni professionali delle fotocamere. Permette di correggere o creare atmosfere tramite temperatura colore (Kelvin) e tinta (verde/magenta). Essenziale per:</p><ul><li>Correggere dominanti colore indesiderate</li><li>Creare mood specifici (caldo/freddo)</li><li>Simulare diverse condizioni di luce</li><li>Color grading cinematografico professionale</li></ul><h3 style="color:#f97316;margin-top:16px">️ I Due Controlli</h3><p><strong>1. Temperature / Temperatura (-100 a +100):</strong></p><table class="help-table"><tr style="background:#ffedd5"><th style="padding:6px;border:1px solid #f97316">Valore</th><th style="padding:6px;border:1px solid #f97316">Kelvin Simulato</th><th style="padding:6px;border:1px solid #f97316">Effetto</th></tr><tr><td class="help-table-cell">-100</td><td class="help-table-cell">~2000K</td><td class="help-table-cell">️ Blu ghiaccio estremo</td></tr><tr><td class="help-table-cell">-50</td><td class="help-table-cell">~4000K</td><td class="help-table-cell"> Freddo (lampade fluorescenti)</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">~5500K</td><td class="help-table-cell">️ Neutro (luce giorno)</td></tr><tr><td class="help-table-cell">+50</td><td class="help-table-cell">~3200K</td><td class="help-table-cell"> Caldo (tungsteno/tramonto)</td></tr><tr><td class="help-table-cell">+100</td><td class="help-table-cell">~2000K</td><td class="help-table-cell"> Arancio fuoco estremo</td></tr></table><p><strong>2. Tint / Tinta (-50 a +50):</strong> Bilanciamento verde ↔ magenta</p><ul><li><strong>Valori Negativi (-50 a -1):</strong> Aggiunge verde (corregge luci fluorescenti/LED)</li><li><strong>0:</strong> Neutro</li><li><strong>Valori Positivi (+1 a +50):</strong> Aggiunge magenta (pelle più rosata, correzione dominante verde)</li></ul><div style="background:#ffedd5;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Cinematografici:</strong><ul><li><strong>Teal & Orange:</strong> Temp +30, Tint +12 (Hollywood blockbuster)</li><li><strong>Nordic Cold:</strong> Temp -45, Tint -8 (Scandinavian noir)</li><li><strong>Golden Hour:</strong> Temp +55, Tint +5 (Tramonto caldo)</li><li><strong>Matrix Green:</strong> Temp -20, Tint -35 (Sci-fi cyberpunk)</li><li><strong>Warm Vintage:</strong> Temp +40, Tint +20 (Polaroid '70s)</li></ul></div><div class="help-box-info"><strong> Correzioni Comuni:</strong><ul><li><strong>Foto scattata con luce tungsteno/incandescente:</strong> Temp -30/-40 (rimuove arancione)</li><li><strong>Foto sotto luci fluorescenti:</strong> Temp +10, Tint -15 (rimuove verde)</li><li><strong>Ombra in giornata soleggiata:</strong> Temp +20 (rimuove blu eccessivo)</li><li><strong>Foto indoor con mix luci:</strong> Esperimenta con entrambi i controlli</li></ul></div><div class="help-box-success"><strong> Workflow Professionale:</strong><ol class="help-list"><li>Identifica la dominante colore (troppo blu/arancio/verde?)</li><li>Correggi prima la Temperature per neutralizzare</li><li>Regola la Tint per bilanciare verde/magenta</li><li>Valuta se vuoi correzione neutra o look creativo</li></ol></div><div class="help-box-danger"><strong>️ Errori Comuni:</strong><ul><li>Over-correzione = colori innaturali e piatti</li><li>Ignorare la Tint = dominante verde/magenta residua</li><li><strong>Regola d'oro:</strong> Meno è meglio. Parti conservativo!</li></ul></div>`,
highlights:`<h3 style="color:#0891b2"> Cos'è Highlights & Shadows?</h3><p>Controllo separato e indipendente delle zone chiare (highlights) e scure (shadows) dell'immagine. Permette di recuperare dettagli persi in zone sovraesposte o sottoesposte senza alterare i mezzitoni. Tecnica professionale essenziale per:</p><ul><li>Recuperare dettagli in cieli bruciati (overexposed)</li><li>Schiarire ombre troppo scure senza perdere contrasto</li><li>Bilanciare foto con alto contrasto dinamico</li><li>Simulare effetto HDR controllato</li></ul><h3 style="color:#0891b2;margin-top:16px">️ I Due Controlli Indipendenti</h3><p><strong>1. Highlights / Luci (-100 a +100):</strong> Zone chiare dell'immagine</p><table class="help-table"><tr style="background:#cffafe"><th style="padding:6px;border:1px solid #0891b2">Valore</th><th style="padding:6px;border:1px solid #0891b2">Effetto</th><th style="padding:6px;border:1px solid #0891b2">Quando Usare</th></tr><tr><td class="help-table-cell">-100 a -50</td><td class="help-table-cell">Scurisce molto le luci</td><td class="help-table-cell">Recuperare cieli bruciati, finestre sovraesposte</td></tr><tr><td class="help-table-cell">-49 a -20</td><td class="help-table-cell">Riduzione moderata</td><td class="help-table-cell">Bilanciare contrasto alto</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">Nessun cambiamento</td><td class="help-table-cell">-</td></tr><tr><td class="help-table-cell">+1 a +50</td><td class="help-table-cell">Aumenta luminosità luci</td><td class="help-table-cell">Foto piatta che necessita punch</td></tr><tr><td class="help-table-cell">+51 a +100</td><td class="help-table-cell">Massima luminosità</td><td class="help-table-cell">Effetto high-key, dreamy</td></tr></table><p><strong>2. Shadows / Ombre (-100 a +100):</strong> Zone scure dell'immagine</p><table class="help-table"><tr style="background:#cffafe"><th style="padding:6px;border:1px solid #0891b2">Valore</th><th style="padding:6px;border:1px solid #0891b2">Effetto</th><th style="padding:6px;border:1px solid #0891b2">Quando Usare</th></tr><tr><td class="help-table-cell">-100 a -50</td><td class="help-table-cell">Scurisce ancora di più</td><td class="help-table-cell">Effetto drammatico, low-key</td></tr><tr><td class="help-table-cell">-49 a -20</td><td class="help-table-cell">Ombre più profonde</td><td class="help-table-cell">Aumentare contrasto</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">Nessun cambiamento</td><td class="help-table-cell">-</td></tr><tr><td class="help-table-cell">+1 a +50</td><td class="help-table-cell">Schiarisce ombre</td><td class="help-table-cell">Recuperare dettagli persi (uso più comune!)</td></tr><tr><td class="help-table-cell">+51 a +100</td><td class="help-table-cell">Ombre quasi eliminate</td><td class="help-table-cell">Effetto flat, stile illustrazione</td></tr></table><div style="background:#cffafe;padding:12px;border-radius:6px;margin:12px 0"><strong> Scenari Comuni:</strong><ul><li><strong>Foto backlit (controluce):</strong> Shadows +40/+60, Highlights -20 (recupera soggetto scuro)</li><li><strong>Cielo bruciato:</strong> Highlights -50/-70 (recupera dettagli nuvole)</li><li><strong>Ritratto in ombra:</strong> Shadows +30/+50 (schiarisci viso)</li><li><strong>Foto piatta:</strong> Highlights +20, Shadows -20 (aumenta contrasto)</li><li><strong>Effetto HDR:</strong> Highlights -40, Shadows +40 (look "compresso")</li></ul></div><div class="help-box-success"><strong> Pro Tips:</strong><ul><li>Muovi i due slider in DIREZIONI OPPOSTE per massimo recupero dettaglio</li><li>Shadows +40 è il valore più usato dai professionisti</li><li>Dopo aver recuperato ombre, spesso serve ridurre Highlights per bilanciare</li><li>Usa in combinazione con Exposure per risultati ottimali</li></ul></div><div class="help-box-danger"><strong>️ Limiti Tecnici:</strong><ul><li>Non può recuperare dettagli COMPLETAMENTE persi (100% bianco o nero)</li><li>Over-recovery crea artefatti e aloni</li><li>Ombre troppo schiarite (+80/+100) = rumore visibile</li><li><strong>Regola:</strong> Se vedi artefatti, hai esagerato</li></ul></div><p><strong> Workflow Pro:</strong> 1) Correggi Exposure generale → 2) Recupera Shadows → 3) Bilancia Highlights → 4) Aggiusta Contrast finale</p>`,
bloom:`<h3 style="color:#db2777"> Cos'è Bloom Pro?</h3><p>Crea un effetto di diffusione luminosa estrema che simula l'overexposure delle fotocamere analogiche e l'effetto "lens flare" cinematografico. A differenza del semplice Glow, Bloom Pro aggiunge un halo luminoso diffuso che si espande dalle zone chiare verso quelle scure, creando un'atmosfera eterea e dreamlike. Perfetto per:</p><ul><li>Effetti dream/ethereal professionali</li><li>Simulare fotografia analogica sovraesposta</li><li>Look cinematografico romantico</li><li>Fantasy art e illustrazioni magiche</li><li>Music video e contenuti artistici</li></ul><h3 style="color:#db2777;margin-top:16px">️ I Parametri</h3><p><strong>Intensità (0-100):</strong> Quanto è forte la diffusione luminosa</p><table class="help-table"><tr style="background:#fce7f3"><th style="padding:6px;border:1px solid #db2777">Valore</th><th style="padding:6px;border:1px solid #db2777">Effetto</th><th style="padding:6px;border:1px solid #db2777">Uso Tipico</th></tr><tr><td class="help-table-cell">0-20</td><td class="help-table-cell"> Bloom sottile</td><td class="help-table-cell">Soft focus delicato</td></tr><tr><td class="help-table-cell">21-40</td><td class="help-table-cell"> Bloom moderato</td><td class="help-table-cell">Ritratti romantici</td></tr><tr><td class="help-table-cell">41-65</td><td class="help-table-cell"> Bloom forte</td><td class="help-table-cell">Look cinematografico</td></tr><tr><td class="help-table-cell">66-85</td><td class="help-table-cell"> Bloom drammatico</td><td class="help-table-cell">Fantasy, effetti magici</td></tr><tr><td class="help-table-cell">86-100</td><td class="help-table-cell">️ Bloom estremo</td><td class="help-table-cell">Abstract, overexposure artistico</td></tr></table><p><strong>Threshold / Soglia (0-255):</strong> Luminosità minima per attivare bloom</p><ul><li><strong>0-50:</strong> Bloom su TUTTE le zone, anche scure (effetto massimo)</li><li><strong>51-128:</strong> Bloom solo su mezzitoni e luci (bilanciato)</li><li><strong>129-200:</strong> Bloom solo su zone molto chiare (selettivo)</li><li><strong>201-255:</strong> Bloom solo su highlights estremi (minimalista)</li></ul><p><strong>Raggio Diffusione (5-50px):</strong> Quanto si espande il bloom</p><ul><li><strong>5-15px:</strong> Bloom compatto, vicino alle luci</li><li><strong>16-30px:</strong> Espansione media (uso generale)</li><li><strong>31-50px:</strong> Diffusione ampia, effetto nebbia luminosa</li></ul><div style="background:#fce7f3;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Cinematografici:</strong><ul><li><strong>Soft Romantic:</strong> Int. 35, Threshold 100, Radius 20</li><li><strong>Golden Hour Dream:</strong> Int. 55, Threshold 80, Radius 30</li><li><strong>Fantasy Magic:</strong> Int. 70, Threshold 120, Radius 25</li><li><strong>Analog Film:</strong> Int. 45, Threshold 90, Radius 18</li><li><strong>Heavenly Glow:</strong> Int. 80, Threshold 60, Radius 35</li></ul></div><div class="help-box-warning"><strong>🆚 Bloom vs Glow:</strong><ul><li><strong>Glow:</strong> Alone uniforme ATTORNO all'immagine (effetto esterno)</li><li><strong>Bloom:</strong> Diffusione luminosa che PARTE DALLE LUCI e si espande (effetto interno)</li><li>Bloom è più cinematografico e simula comportamento reale della luce</li></ul></div><div class="help-box-success"><strong> Ideale per:</strong><ul><li>Ritratti backlit (controluce) con sole dietro soggetto</li><li>Scene notturne con luci artificiali (neon, lampioni)</li><li>Fantasy art con elementi magici/luminosi</li><li>Simulare lens flare e aberrazioni ottiche vintage</li><li>Music video e contenuti dreamlike</li></ul></div><div class="help-box-danger"><strong>️ Considerazioni:</strong><ul><li>Effetto computazionalmente intenso (può essere lento su immagini grandi)</li><li>Bloom troppo forte riduce contrasto e "lava via" dettagli</li><li>Funziona meglio su immagini con zone chiare ben definite</li><li>Su foto già sovraesposte può peggiorare la situazione</li></ul></div><p><strong> Pro Tip:</strong> Combina Bloom (Int. 50) + Vibrance (+20) + Warm Temperature (+15) per il perfetto look "golden hour magic"!</p>`,
blurpro:`<h3 style="color:#0369a1"> Cos'è Blur Pro?</h3><p>Versione avanzata dello sfocatura standard con controlli professionali che permettono di simulare diversi tipi di blur fotografico: dal bokeh creamy delle lenti fotografiche al motion blur direzionale. Perfetto per:</p><ul><li>Simulare depth-of-field (profondità di campo) professionale</li><li>Creare sfondi sfocati per ritratti (effetto bokeh)</li><li>Motion blur artistico e direzionale</li><li>Effetti dream/soft focus controllati</li><li>Ridurre dettagli e imperfezioni in modo artistico</li></ul><h3 style="color:#0369a1;margin-top:16px">️ I Parametri Avanzati</h3><p><strong>1. Tipo Blur:</strong></p><ul><li><strong>Gaussian (Gaussiano):</strong> Sfocatura uniforme morbida, classico bokeh fotografico</li><li><strong>Box:</strong> Sfocatura più "meccanica", effetto quadrato</li><li><strong>Motion:</strong> Sfocatura direzionale (simula movimento)</li></ul><p><strong>2. Raggio/Intensità (0-100):</strong></p><table class="help-table"><tr style="background:#e0f2fe"><th style="padding:6px;border:1px solid #0369a1">Valore</th><th style="padding:6px;border:1px solid #0369a1">Effetto</th><th style="padding:6px;border:1px solid #0369a1">Uso Tipico</th></tr><tr><td class="help-table-cell">0-15</td><td class="help-table-cell">Soft focus leggero</td><td class="help-table-cell">Skin smoothing, imperfezioni</td></tr><tr><td class="help-table-cell">16-35</td><td class="help-table-cell">Blur medio</td><td class="help-table-cell">Background blur ritratti</td></tr><tr><td class="help-table-cell">36-60</td><td class="help-table-cell">Blur forte</td><td class="help-table-cell">Sfondi completamente sfocati</td></tr><tr><td class="help-table-cell">61-100</td><td class="help-table-cell">Blur estremo</td><td class="help-table-cell">Abstract, nascondere totale</td></tr></table><p><strong>3. Angolo Motion (0-360°):</strong> Solo per Motion Blur</p><ul><li><strong>0° / 180°:</strong> Movimento orizzontale →</li><li><strong>90° / 270°:</strong> Movimento verticale ↓</li><li><strong>45° / 135°:</strong> Movimento diagonale ↘</li></ul><p><strong>4. Qualità (Bassa/Media/Alta):</strong></p><ul><li><strong>Bassa:</strong> Veloce ma può avere artefatti</li><li><strong>Media:</strong> Bilanciata (consigliata)</li><li><strong>Alta:</strong> Massima qualità ma più lenta</li></ul><div style="background:#e0f2fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Fotografici:</strong><ul><li><strong>Portrait Bokeh (f/1.8):</strong> Gaussian, Radius 25, Quality High</li><li><strong>Soft Beauty:</strong> Gaussian, Radius 8, Quality Medium</li><li><strong>Background Separation:</strong> Gaussian, Radius 40, Quality High</li><li><strong>Speed Motion:</strong> Motion 90°, Radius 30, Quality Medium</li><li><strong>Dream Haze:</strong> Gaussian, Radius 18, Quality High</li></ul></div><div class="help-box-success"><strong> Tecniche Avanzate:</strong><ul><li><strong>Fake Bokeh:</strong> Duplica layer, sfoca sfondo (Radius 35), mantieni soggetto nitido</li><li><strong>Orton Effect:</strong> Blur leggero (10) + blend con originale = glow soft</li><li><strong>Motion Freeze:</strong> Sfoca sfondo con Motion blur per simulare movimento</li><li><strong>Tilt-Shift Fake:</strong> Blur graduale per simulare miniature</li></ul></div><div class="help-box-warning"><strong>🆚 Confronto Tipi Blur:</strong><table class="help-table"><tr><th style="padding:6px;border:1px solid #f97316">Tipo</th><th style="padding:6px;border:1px solid #f97316">Pro</th><th style="padding:6px;border:1px solid #f97316">Contro</th></tr><tr><td class="help-table-cell"><strong>Gaussian</strong></td><td class="help-table-cell">Più realistico, simula lenti</td><td class="help-table-cell">Più lento</td></tr><tr><td class="help-table-cell"><strong>Box</strong></td><td class="help-table-cell">Veloce, effetto "meccanico"</td><td class="help-table-cell">Meno naturale</td></tr><tr><td class="help-table-cell"><strong>Motion</strong></td><td class="help-table-cell">Simula movimento</td><td class="help-table-cell">Serve angolo giusto</td></tr></table></div><div class="help-box-danger"><strong>️ ATTENZIONE:</strong><ul><li>Blur è IRREVERSIBILE - salva copia originale!</li><li>Blur forte (60+) su immagini grandi = molto lento</li><li>Motion blur necessita direzione coerente con soggetto</li><li>Qualità Alta su Radius 50+ può richiedere minuti</li></ul></div><p><strong> Pro Tip:</strong> Per ritratti professionali, usa Gaussian Blur (Radius 25-30) solo sullo sfondo, mantenendo soggetto nitido. Poi aggiungi leggerissimo blur al soggetto (Radius 3-5) per skin smoothing!</p>`,
exposure:`<h3 style="color:#7c3aed"> Cos'è Exposure (Esposizione)?</h3><p>Controllo fondamentale che regola la luminosità complessiva dell'immagine simulando l'apertura del diaframma o il tempo di esposizione della fotocamera. È il primo parametro da correggere in ogni workflow di editing professionale. Essenziale per:</p><ul><li>Correggere foto sovraesposte (troppo chiare) o sottoesposte (troppo scure)</li><li>Bilanciare l'esposizione generale prima di altri ritocchi</li><li>Creare effetti high-key (molto chiaro) o low-key (molto scuro)</li><li>Preparare l'immagine per ulteriori regolazioni tonali</li></ul><h3 style="color:#7c3aed;margin-top:16px">️ Range di Valori (-2.0 a +2.0 EV)</h3><p><strong>EV (Exposure Value):</strong> Unità fotografica standard. Ogni +1 EV = raddoppia la luce, -1 EV = dimezza la luce</p><table class="help-table"><tr style="background:#ede9fe"><th style="padding:6px;border:1px solid #7c3aed">Valore</th><th style="padding:6px;border:1px solid #7c3aed">EV</th><th style="padding:6px;border:1px solid #7c3aed">Effetto</th><th style="padding:6px;border:1px solid #7c3aed">Quando Usare</th></tr><tr><td class="help-table-cell">-2.0</td><td class="help-table-cell">-2 stop</td><td class="help-table-cell"> Oscuramento drammatico</td><td class="help-table-cell">Foto molto sovraesposta o effetto low-key</td></tr><tr><td class="help-table-cell">-1.0</td><td class="help-table-cell">-1 stop</td><td class="help-table-cell"> Riduzione significativa</td><td class="help-table-cell">Foto troppo chiara</td></tr><tr><td class="help-table-cell">-0.3 a -0.7</td><td class="help-table-cell">-⅓ a -⅔ stop</td><td class="help-table-cell"> Correzione leggera</td><td class="help-table-cell">Fine tuning, leggermente sovraesposta</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">0 EV</td><td class="help-table-cell"> Nessun cambiamento</td><td class="help-table-cell">Esposizione corretta</td></tr><tr><td class="help-table-cell">+0.3 a +0.7</td><td class="help-table-cell">+⅓ a +⅔ stop</td><td class="help-table-cell"> Schiarimento leggero</td><td class="help-table-cell">Fine tuning, leggermente sottoesposta</td></tr><tr><td class="help-table-cell">+1.0</td><td class="help-table-cell">+1 stop</td><td class="help-table-cell">️ Aumento significativo</td><td class="help-table-cell">Foto scura/sottoesposta</td></tr><tr><td class="help-table-cell">+2.0</td><td class="help-table-cell">+2 stop</td><td class="help-table-cell"> Schiarimento drammatico</td><td class="help-table-cell">Foto molto scura o effetto high-key</td></tr></table><div style="background:#ede9fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Scenari Comuni:</strong><ul><li><strong>Foto backlit (controluce):</strong> +0.7 a +1.3 EV (schiarisci soggetto scuro)</li><li><strong>Foto con flash troppo forte:</strong> -0.5 a -1.0 EV (riduci sovraesposizione)</li><li><strong>Scatto notturno sottoesposto:</strong> +1.0 a +1.5 EV (recupera visibilità)</li><li><strong>Foto in pieno sole:</strong> -0.3 a -0.7 EV (evita highlight bruciati)</li><li><strong>Ritratto in ombra:</strong> +0.5 a +1.0 EV (illumina viso)</li></ul></div><div class="help-box-info"><strong> Effetti Creativi:</strong><ul><li><strong>High-Key Portrait:</strong> Exposure +1.2, Highlights -30, Shadows +20 (look etereo)</li><li><strong>Low-Key Drama:</strong> Exposure -0.8, Shadows -40, Contrast +20 (mood scuro)</li><li><strong>Airy & Bright:</strong> Exposure +0.5, Vibrance +25, Clarity -10 (luminoso e soft)</li><li><strong>Moody & Dark:</strong> Exposure -0.7, Saturation -15, Vignette 60 (atmosfera cupa)</li></ul></div><div class="help-box-success"><strong> Workflow Professionale (Ordine Operazioni):</strong><ol class="help-list"><li><strong>PRIMA:</strong> Correggi Exposure (luminosità generale)</li><li><strong>POI:</strong> Bilancia Highlights & Shadows (recupera dettagli)</li><li><strong>POI:</strong> Regola Contrast (punch e profondità)</li><li><strong>POI:</strong> White Balance (correzione colore)</li><li><strong>INFINE:</strong> Vibrance, Clarity, Sharpen (rifinitura)</li></ol></div><div class="help-box-danger"><strong>️ Limiti e Considerazioni:</strong><ul><li><strong>+2 EV su foto scura = molto rumore visibile</strong> (ISO alto simulato)</li><li><strong>-2 EV = perdita dettagli nelle ombre</strong> (nero puro)</li><li>Exposure NON recupera highlight completamente bruciati (255 255 255)</li><li>Meglio correggere in camera quando possibile che in post</li><li><strong>Regola d'oro:</strong> Incrementi di ±0.3 EV per regolazioni fini</li></ul></div><div class="help-box-warning"><strong>🆚 Exposure vs Brightness:</strong><ul><li><strong>Exposure:</strong> Simula cambio esposizione camera (moltiplica TUTTI i valori tonali)</li><li><strong>Brightness:</strong> Shift lineare (sposta curve verso alto/basso)</li><li><strong>Differenza pratica:</strong> Exposure preserva meglio il rapporto tra luci/ombre</li><li>Usa Exposure per correzioni "fotografiche" naturali</li></ul></div><p><strong> Pro Tip:</strong> Usa l'istogramma (se disponibile) per valutare l'esposizione: grafico spostato a sinistra = sottoesposta (+EV), spostato a destra = sovraesposta (-EV). Obiettivo: curva centrata senza clipping agli estremi!</p>`,
threshold:`<h3 style="color:#0d9488"> Cos'è Threshold (Soglia)?</h3><p>Converte l'immagine in puro bianco e nero (senza sfumature di grigio) usando un valore di soglia. Ogni pixel viene confrontato con la soglia: se è più chiaro diventa bianco, se è più scuro diventa nero. Perfetto per:</p><ul><li>Creare grafica ad alto contrasto</li><li>Loghi e design minimalisti</li><li>Preparare immagini per stampa su tessuti</li><li>Effetti artistici stile stencil/silhouette</li><li>Isolare soggetti per compositing</li></ul><h3 style="color:#0d9488;margin-top:16px">️ Valore Soglia (0-255)</h3><p>Il valore determina il "punto di taglio" tra bianco e nero. È espresso in luminosità RGB dove 0 = nero puro e 255 = bianco puro.</p><table class="help-table"><tr style="background:#ccfbf1"><th style="padding:6px;border:1px solid #0d9488">Valore</th><th style="padding:6px;border:1px solid #0d9488">Effetto Visivo</th><th style="padding:6px;border:1px solid #0d9488">Quando Usare</th></tr><tr><td class="help-table-cell">0-50</td><td class="help-table-cell"> Quasi tutto nero</td><td class="help-table-cell">Isolare solo elementi molto chiari</td></tr><tr><td class="help-table-cell">51-100</td><td class="help-table-cell"> Prevalentemente nero</td><td class="help-table-cell">Silhouette, ombre marcate</td></tr><tr><td class="help-table-cell">101-155</td><td class="help-table-cell">️ Bilanciato</td><td class="help-table-cell">Uso generale, dettaglio moderato</td></tr><tr><td class="help-table-cell">156-200</td><td class="help-table-cell"> Prevalentemente bianco</td><td class="help-table-cell">High-key, luci dominanti</td></tr><tr><td class="help-table-cell">201-255</td><td class="help-table-cell"> Quasi tutto bianco</td><td class="help-table-cell">Isolare solo elementi molto scuri</td></tr></table><div style="background:#ccfbf1;padding:12px;border-radius:6px;margin:12px 0"><strong> Applicazioni Creative:</strong><ul><li><strong>Silhouette Portrait:</strong> Threshold 80-110 (profilo nero su sfondo bianco)</li><li><strong>High Contrast Logo:</strong> Threshold 120-140 (bilanciato)</li><li><strong>Stencil Art:</strong> Threshold 100-130 (per stampa su tessuti)</li><li><strong>Comic Book Effect:</strong> Threshold 110-150 + outline neri</li><li><strong>Woodcut Print:</strong> Threshold 90-120 (stampa xilografica)</li></ul></div><div class="help-box-info"><strong> Come Scegliere il Valore:</strong><ol class="help-list"><li>Analizza l'istogramma (se disponibile) per vedere distribuzione tonale</li><li>Inizia con threshold a metà (127)</li><li>Se vuoi preservare più dettagli chiari → abbassa il valore</li><li>Se vuoi preservare più dettagli scuri → alza il valore</li><li>Regola finemente ±10 alla volta per risultato desiderato</li></ol></div><div class="help-box-danger"><strong>️ ATTENZIONE:</strong><ul><li>Effetto IRREVERSIBILE - perdi tutte le sfumature tonali!</li><li>Non funziona bene su foto con illuminazione non uniforme</li><li>Dettagli fini e texture vengono persi completamente</li><li>Salva sempre una copia originale prima di applicare</li></ul></div><p><strong> Pro Tip:</strong> Per migliori risultati, applica prima Auto Levels o aumenta Contrast per separare meglio luci/ombre, POI applica Threshold!</p>`,
invert:`<h3 style="color:#be123c"> Cos'è Invert (Inversione Colori)?</h3><p>Inverte tutti i colori dell'immagine trasformando ogni pixel nel suo opposto cromatico. Il nero diventa bianco, il rosso diventa ciano, il blu diventa giallo, ecc. È l'equivalente digitale di un negativo fotografico. Perfetto per:</p><ul><li>Creare effetti artistici surreali</li><li>Simulare negativi fotografici analogici</li><li>Design grafico e poster psichedelici</li><li>Visualizzare immagini in modo alternativo</li><li>Effetti X-ray e radiografia</li></ul><h3 style="color:#be123c;margin-top:16px"> Come Funziona Tecnicamente</h3><p>Per ogni pixel, l'inversione calcola: <strong>Nuovo Valore = 255 - Valore Originale</strong></p><table class="help-table"><tr style="background:#ffe4e6"><th style="padding:6px;border:1px solid #be123c">Colore Originale</th><th style="padding:6px;border:1px solid #be123c">→</th><th style="padding:6px;border:1px solid #be123c">Colore Invertito</th></tr><tr><td class="help-table-cell"> Nero (0,0,0)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell"> Bianco (255,255,255)</td></tr><tr><td class="help-table-cell"> Bianco (255,255,255)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell"> Nero (0,0,0)</td></tr><tr><td class="help-table-cell"> Rosso (255,0,0)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell">🩵 Ciano (0,255,255)</td></tr><tr><td class="help-table-cell"> Verde (0,255,0)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell"> Magenta (255,0,255)</td></tr><tr><td class="help-table-cell"> Blu (0,0,255)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell"> Giallo (255,255,0)</td></tr><tr><td class="help-table-cell">🩵 Ciano (0,255,255)</td><td style="padding:6px;text-align:center">→</td><td class="help-table-cell"> Rosso (255,0,0)</td></tr></table><div style="background:#ffe4e6;padding:12px;border-radius:6px;margin:12px 0"><strong> Applicazioni Creative:</strong><ul><li><strong>Effetto Negativo Fotografico:</strong> Invert + desaturazione leggera (vintage film)</li><li><strong>X-Ray Look:</strong> Invert immagine, aumenta contrast (effetto radiografia)</li><li><strong>Psychedelic Art:</strong> Invert + saturazione alta (poster '60s-'70s)</li><li><strong>Infrared Simulation:</strong> Invert + canale swap rosso/blu</li><li><strong>Night Vision:</strong> Invert + gradient map verde</li></ul></div><div class="help-box-success"><strong> Usi Pratici:</strong><ul><li><strong>Correggere negativi scansionati:</strong> Scansiona pellicola negativa → Invert per ottenere positivo</li><li><strong>Visualizzare meglio dettagli scuri:</strong> Su immagini molto scure, invert rende visibili dettagli</li><li><strong>Creare maschere:</strong> Invert per invertire selezioni/maschere</li><li><strong>Analisi immagine:</strong> A volte difetti/pattern sono più visibili invertiti</li></ul></div><div class="help-box-info"><strong>🆚 Effetti Correlati:</strong><ul><li><strong>Invert vs Threshold:</strong> Invert preserva tutti i colori (solo li inverte), Threshold li elimina (B&N puro)</li><li><strong>Invert vs Gradient Map:</strong> Invert è automatico, Gradient Map permette controllo creativo delle mappature colore</li><li><strong>Doppia inversione:</strong> Invert → Invert = ritorno all'originale (reversibile!)</li></ul></div><div class="help-box-warning"><strong> Combo Effetti Creativi:</strong><ul><li><strong>Solarizzazione:</strong> Invert + Blend con originale al 50%</li><li><strong>False Color:</strong> Invert + Temperature shift + Saturation boost</li><li><strong>Thermal Vision:</strong> Invert + Gradient Map (blu freddo → rosso caldo)</li></ul></div><p><strong> Pro Tip:</strong> Invert è completamente reversibile - applica due volte per tornare all'originale. Usalo per analizzare immagini da prospettive diverse!</p>`,
brightness:`<h3 style="color:#f59e0b"> Cos'è Brightness (Luminosità)?</h3><p>Regola la luminosità generale dell'immagine aggiungendo o sottraendo un valore uniforme a tutti i pixel. A differenza di Exposure che moltiplica i valori, Brightness li sposta linearmente. Usato per:</p><ul><li>Correzioni rapide di luminosità generale</li><li>Schiarire o scurire immagini in modo uniforme</li><li>Regolazioni preliminari prima di altri effetti</li><li>Creare effetti di sovra/sotto illuminazione</li></ul><h3 style="color:#f59e0b;margin-top:16px">️ Range di Valori (-100 a +100)</h3><table class="help-table"><tr style="background:#fef3c7"><th style="padding:6px;border:1px solid #f59e0b">Valore</th><th style="padding:6px;border:1px solid #f59e0b">Effetto</th><th style="padding:6px;border:1px solid #f59e0b">Quando Usare</th></tr><tr><td class="help-table-cell">-100</td><td class="help-table-cell"> Nero puro (estremo)</td><td class="help-table-cell">Effetti drammatici, silhouette</td></tr><tr><td class="help-table-cell">-50 a -70</td><td class="help-table-cell"> Molto scuro</td><td class="help-table-cell">Look moody, cinematografico</td></tr><tr><td class="help-table-cell">-20 a -40</td><td class="help-table-cell"> Scurimento moderato</td><td class="help-table-cell">Ridurre sovraesposizione</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell"> Originale</td><td class="help-table-cell">Nessun cambiamento</td></tr><tr><td class="help-table-cell">+20 a +40</td><td class="help-table-cell"> Schiarimento moderato</td><td class="help-table-cell">Foto leggermente sottoesposte</td></tr><tr><td class="help-table-cell">+50 a +70</td><td class="help-table-cell">️ Molto chiaro</td><td class="help-table-cell">High-key, look etereo</td></tr><tr><td class="help-table-cell">+100</td><td class="help-table-cell"> Bianco bruciato (estremo)</td><td class="help-table-cell">Effetti artistici estremi</td></tr></table><div style="background:#fef3c7;padding:12px;border-radius:6px;margin:12px 0"><strong>🆚 Brightness vs Exposure:</strong><table class="help-table"><tr><th style="padding:6px;border:1px solid #f59e0b">Aspetto</th><th style="padding:6px;border:1px solid #f59e0b">Brightness</th><th style="padding:6px;border:1px solid #f59e0b">Exposure</th></tr><tr><td class="help-table-cell"><strong>Calcolo</strong></td><td class="help-table-cell">Somma lineare: Pixel + Valore</td><td class="help-table-cell">Moltiplicazione: Pixel × Fattore</td></tr><tr><td class="help-table-cell"><strong>Nero (0)</strong></td><td class="help-table-cell">Può diventare grigio (+Brightness)</td><td class="help-table-cell">Resta nero (0 × qualsiasi = 0)</td></tr><tr><td class="help-table-cell"><strong>Contrasto</strong></td><td class="help-table-cell">Può appiattire il contrasto</td><td class="help-table-cell">Preserva il contrasto relativo</td></tr><tr><td class="help-table-cell"><strong>Naturalezza</strong></td><td class="help-table-cell">Meno naturale per fotografia</td><td class="help-table-cell">Più naturale, simula camera</td></tr><tr><td class="help-table-cell"><strong>Uso ideale</strong></td><td class="help-table-cell">Correzioni rapide, grafica</td><td class="help-table-cell">Fotografia, correzioni tonali</td></tr></table></div><div class="help-box-success"><strong> Esempi Pratici:</strong><ul><li><strong>Foto leggermente scura:</strong> Brightness +25 a +35 (correzione veloce)</li><li><strong>Ridurre highlights:</strong> Brightness -20 a -30 (abbassa zone chiare)</li><li><strong>High-key portrait:</strong> Brightness +40, Contrast -10 (look soffice)</li><li><strong>Low-key mood:</strong> Brightness -40, Contrast +15 (drammatico)</li></ul></div><div class="help-box-danger"><strong>️ Limiti di Brightness:</strong><ul><li><strong>Clipping:</strong> Valori estremi "tagliano" luci (→255) o ombre (→0)</li><li><strong>Appiattimento:</strong> Può ridurre profondità e contrasto</li><li><strong>Nero che diventa grigio:</strong> +Brightness trasforma neri profondi in grigi (spesso indesiderato)</li><li><strong>Soluzione:</strong> Per fotografia, preferisci Exposure + Highlights/Shadows</li></ul></div><p><strong> Workflow Consigliato:</strong> Usa Brightness per regolazioni rapide/preview, poi passa a Exposure + Contrast per controllo fine. Brightness è ottimo per grafica/design, meno per fotografia realistica.</p>`,
contrast:`<h3 style="color:#dc2626"> Cos'è Contrast (Contrasto)?</h3><p>Regola la differenza tra le zone chiare e scure dell'immagine. Aumentare il contrasto rende le luci più luminose e le ombre più scure (maggior "punch"), ridurlo avvicina tutti i toni verso il grigio medio (immagine più "flat"). Essenziale per:</p><ul><li>Dare profondità e tridimensionalità</li><li>Recuperare "punch" in foto piatte/sbiadite</li><li>Creare mood drammatico o soft</li><li>Bilanciare immagini dopo correzioni di esposizione</li></ul><h3 style="color:#dc2626;margin-top:16px">️ Range di Valori (-100 a +100)</h3><table class="help-table"><tr style="background:#fee2e2"><th style="padding:6px;border:1px solid #dc2626">Valore</th><th style="padding:6px;border:1px solid #dc2626">Effetto Visivo</th><th style="padding:6px;border:1px solid #dc2626">Quando Usare</th></tr><tr><td class="help-table-cell">-100 a -60</td><td class="help-table-cell">️ Grigio uniforme estremo</td><td class="help-table-cell">Effetti nebbia, sogno estremo</td></tr><tr><td class="help-table-cell">-40 a -59</td><td class="help-table-cell"> Molto flat, low contrast</td><td class="help-table-cell">Look pastello, soft portrait</td></tr><tr><td class="help-table-cell">-20 a -39</td><td class="help-table-cell"> Ridotto, delicato</td><td class="help-table-cell">Ritratti femminili, beauty</td></tr><tr><td class="help-table-cell">0</td><td class="help-table-cell">️ Originale</td><td class="help-table-cell">Nessun cambiamento</td></tr><tr><td class="help-table-cell">+1 a +25</td><td class="help-table-cell"> Moderato, bilanciato</td><td class="help-table-cell">Uso generale, più "pop"</td></tr><tr><td class="help-table-cell">+26 a +50</td><td class="help-table-cell"> Forte, drammatico</td><td class="help-table-cell">Paesaggi, architettura</td></tr><tr><td class="help-table-cell">+51 a +100</td><td class="help-table-cell"> Estremo, HDR-like</td><td class="help-table-cell">Effetti artistici, poster</td></tr></table><div class="help-box-danger"><strong> Applicazioni per Genere:</strong><ul><li><strong>Ritratto Beauty:</strong> Contrast -10 a -20 (pelle morbida, riduce imperfezioni)</li><li><strong>Ritratto Maschile:</strong> Contrast +15 a +25 (carattere, definizione)</li><li><strong>Paesaggio Drammatico:</strong> Contrast +30 a +45 (nuvole, texture)</li><li><strong>Street Photography:</strong> Contrast +20 a +35 (gritty, urban)</li><li><strong>Fashion Editorial:</strong> Contrast +10 a +20 (punch ma elegante)</li><li><strong>Newborn/Baby:</strong> Contrast -15 a -25 (soft, dreamy)</li></ul></div><div class="help-box-info"><strong> Come Funziona (Tecnico):</strong><p>Il contrasto "stira" la curva tonale attorno al grigio medio (128):</p><ul><li><strong>+Contrast:</strong> Pixel > 128 diventano più chiari, pixel < 128 più scuri (curva a S)</li><li><strong>-Contrast:</strong> Tutti i pixel si avvicinano a 128 (curva appiattita)</li><li><strong>Punto di ancoraggio:</strong> Il grigio medio (128) resta invariato</li></ul></div><div class="help-box-success"><strong> Workflow con Altri Controlli:</strong><ol class="help-list"><li><strong>Exposure:</strong> Correggi prima la luminosità generale</li><li><strong>Highlights/Shadows:</strong> Recupera dettagli persi</li><li><strong>Contrast:</strong> Ora regola il contrasto per "punch" finale</li><li><strong>Perché quest'ordine?</strong> Contrast amplifica differenze già presenti, quindi meglio dopo aver bilanciato toni</li></ol></div><div class="help-box-warning"><strong>🆚 Contrast vs Clarity:</strong><ul><li><strong>Contrast:</strong> Contrasto GLOBALE (tutta l'immagine uniformemente)</li><li><strong>Clarity:</strong> Contrasto LOCALE (solo nelle transizioni tonali medie)</li><li><strong>Risultato:</strong> Contrast = più "drammatico", Clarity = più "texture e dettagli"</li><li>Spesso si usano insieme: Contrast +20, Clarity +40</li></ul></div><div class="help-box-danger"><strong>️ Errori Comuni:</strong><ul><li><strong>Contrasto eccessivo (+70/+100):</strong> Perde dettagli, colori saturi innaturali, posterizzazione</li><li><strong>Su ritratti beauty:</strong> +Contrast enfatizza imperfezioni e rughe</li><li><strong>Prima di Exposure:</strong> Può creare clipping (zone completamente nere/bianche)</li><li><strong>Regola d'oro:</strong> Meno è meglio. +15 a +25 è spesso sufficiente</li></ul></div><p><strong> Pro Tip:</strong> Foto sembra "flat" e noiosa? Prova: Contrast +20, Clarity +35, Vibrance +15. È la combo più usata dai professionisti per dare "vita" alle foto!</p>`,
levels:`<h3 style="color:#4f46e5"> Cos'è Levels (Livelli Tonali)?</h3><p>Controllo avanzato della distribuzione tonale tramite regolazione indipendente di neri (blacks), ombre (shadows), mezzitoni (midtones), luci (highlights) e bianchi (whites). È lo strumento più potente e preciso per correzioni tonali professionali. Fondamentale per:</p><ul><li>Correzione precisa dell'istogramma</li><li>Recuperare dettagli in zone sovra/sotto-esposte</li><li>Calibrare il punto di nero e bianco</li><li>Creare look cinematografici custom</li><li>Massimizzare la gamma dinamica dell'immagine</li></ul><h3 style="color:#4f46e5;margin-top:16px">️ I 5 Controlli Indipendenti</h3><p><strong>1. Blacks / Neri (0-255):</strong> Imposta il punto di nero puro</p><ul><li><strong>Valore basso (0-50):</strong> Neri profondi, contrasto forte</li><li><strong>Valore medio (51-100):</strong> Bilanciato, uso generale</li><li><strong>Valore alto (101-255):</strong> "Alza i neri" = look washed/faded, vintage</li></ul><p><strong>2. Shadows / Ombre (0-255):</strong> Controlla le zone scure (non nero puro)</p><ul><li><strong>0-85:</strong> Ombre più scure (drammatico)</li><li><strong>86-170:</strong> Range naturale</li><li><strong>171-255:</strong> Ombre schiarite (recupera dettagli)</li></ul><p><strong>3. Midtones / Mezzitoni (0-255):</strong> Il "cuore" dell'immagine, toni medi</p><ul><li><strong>0-100:</strong> Scurisce mezzitoni (mood scuro)</li><li><strong>101-155:</strong> Range naturale</li><li><strong>156-255:</strong> Schiarisce mezzitoni (luminoso, airy)</li></ul><p><strong>4. Highlights / Luci (0-255):</strong> Zone chiare (non bianco puro)</p><ul><li><strong>0-85:</strong> Luci ridotte drasticamente</li><li><strong>86-170:</strong> Range naturale</li><li><strong>171-255:</strong> Luci potenziate (glow, overexposure)</li></ul><p><strong>5. Whites / Bianchi (0-255):</strong> Imposta il punto di bianco puro</p><ul><li><strong>Valore basso (0-200):</strong> "Abbassa i bianchi" = riduce highlights estremi</li><li><strong>Valore medio (201-235):</strong> Bilanciato</li><li><strong>Valore alto (236-255):</strong> Bianchi luminosi, high-key</li></ul><table class="help-table"><tr style="background:#e0e7ff"><th style="padding:6px;border:1px solid #4f46e5">Controllo</th><th style="padding:6px;border:1px solid #4f46e5">Range Tonale</th><th style="padding:6px;border:1px solid #4f46e5">Istogramma</th></tr><tr><td class="help-table-cell"><strong>Blacks</strong></td><td class="help-table-cell">0-50 (estremo sinistro)</td><td class="help-table-cell">⬛⬛⬛</td></tr><tr><td class="help-table-cell"><strong>Shadows</strong></td><td class="help-table-cell">51-100 (sinistra)</td><td class="help-table-cell">⬛⬛◼️</td></tr><tr><td class="help-table-cell"><strong>Midtones</strong></td><td class="help-table-cell">101-155 (centro)</td><td class="help-table-cell">◼️◽◻️</td></tr><tr><td class="help-table-cell"><strong>Highlights</strong></td><td class="help-table-cell">156-205 (destra)</td><td class="help-table-cell">◻️⬜⬜</td></tr><tr><td class="help-table-cell"><strong>Whites</strong></td><td class="help-table-cell">206-255 (estremo destro)</td><td class="help-table-cell">⬜⬜⬜</td></tr></table><div style="background:#e0e7ff;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset per Scenario:</strong><ul><li><strong>Corr. Standard:</strong> Blacks 20, Shadows 85, Mid 128, Highlights 170, Whites 235</li><li><strong>Faded Film:</strong> Blacks 40, Shadows 70, Mid 140, Highlights 185, Whites 220 (vintage washed)</li><li><strong>Deep Blacks:</strong> Blacks 0, Shadows 60, Mid 120, Highlights 175, Whites 245 (contrasto forte)</li><li><strong>High-Key:</strong> Blacks 50, Shadows 110, Mid 150, Highlights 200, Whites 250 (luminoso)</li><li><strong>Low-Key:</strong> Blacks 10, Shadows 50, Mid 100, Highlights 140, Whites 200 (mood scuro)</li><li><strong>Matte Look:</strong> Blacks 45, Shadows 90, Mid 135, Highlights 180, Whites 225 (cinema flat)</li></ul></div><div class="help-box-info"><strong> Workflow Professionale con Levels:</strong><ol class="help-list"><li><strong>Analizza l'istogramma:</strong> Identifica clipping (picchi agli estremi) e distribuzione tonale</li><li><strong>Imposta Blacks:</strong> Muovi fino a vedere neri puri (ma non clipping!). Valore tipico: 10-30</li><li><strong>Imposta Whites:</strong> Muovi fino a vedere bianchi puri (senza bruciare). Valore tipico: 230-245</li><li><strong>Regola Shadows:</strong> Recupera dettagli ombre se necessario</li><li><strong>Regola Highlights:</strong> Riduci luci eccessive o potenziale per glow</li><li><strong>Fine-tune Midtones:</strong> Aggiusta il "peso" tonale generale (chiaro/scuro)</li></ol></div><div class="help-box-success"><strong> Look Cinematografici Famosi:</strong><ul><li><strong>Bleach Bypass:</strong> Blacks 15, Shadows 70, Mid 115, Highlights 180, Whites 240 (desaturation consigliata)</li><li><strong>Teal & Orange:</strong> (dopo levels) Blacks 25, Shadows 80, Mid 130 + color grading</li><li><strong>Film Noir:</strong> Blacks 0, Shadows 40, Mid 95, Highlights 160, Whites 220</li><li><strong>Wes Anderson Pastel:</strong> Blacks 50, Shadows 95, Mid 140, Highlights 190, Whites 230</li></ul></div><div class="help-box-danger"><strong>️ Errori da Evitare:</strong><ul><li><strong>Blacks troppo alti (>60):</strong> Perde profondità, tutto sembra grigio</li><li><strong>Whites troppo bassi (<200):</strong> Immagine cupa, manca "aria"</li><li><strong>Tutti i controlli verso il centro:</strong> Appiattisce contrasto completamente</li><li><strong>Inversione ordine:</strong> Es: Shadows > Midtones > Highlights (crea posterizzazione!)</li><li><strong>Cambiamenti estremi:</strong> ±50 in un singolo controllo = solitamente troppo</li></ul></div><div class="help-box-warning"><strong>🆚 Levels vs Altri Controlli:</strong><table class="help-table"><tr><th style="padding:6px;border:1px solid #f59e0b">Tool</th><th style="padding:6px;border:1px solid #f59e0b">Controllo</th><th style="padding:6px;border:1px solid #f59e0b">Precisione</th><th style="padding:6px;border:1px solid #f59e0b">Uso</th></tr><tr><td class="help-table-cell"><strong>Brightness</strong></td><td class="help-table-cell">Globale, uniforme</td><td class="help-table-cell"></td><td class="help-table-cell">Quick fix</td></tr><tr><td class="help-table-cell"><strong>Contrast</strong></td><td class="help-table-cell">Espande/comprime</td><td class="help-table-cell"></td><td class="help-table-cell">Generale</td></tr><tr><td class="help-table-cell"><strong>Highlights/Shadows</strong></td><td class="help-table-cell">2 zone separate</td><td class="help-table-cell"></td><td class="help-table-cell">Recupero</td></tr><tr><td class="help-table-cell"><strong>Levels</strong></td><td class="help-table-cell">5 zone indipendenti</td><td class="help-table-cell"></td><td class="help-table-cell">Pro grading</td></tr></table></div><p><strong> Pro Tip:</strong> Per il massimo controllo, usa Levels per impostare distribuzione tonale globale, POI usa Clarity per micro-contrasto locale, INFINE Sharpen per dettagli. Questa è la sequenza usata dai color grader professionisti!</p>`,
duotone:`<h3 style="color:#be185d"> Cos'è Duotone (Due Tonalità)?</h3><p>Effetto di color grading che rimappa l'immagine su due colori: uno per le ombre e uno per le luci. Diverso da Gradient Map, Duotone crea un look più "flat" e grafico, molto popolare su Instagram e nei poster vintage. Perfetto per:</p><ul><li>Design grafico moderno e minimalista</li><li>Estetica Instagram e social media</li><li>Poster e artwork stile anni '60-'80</li><li>Branding e identità visiva distintiva</li><li>Effetti artistici e sperimentali</li></ul><h3 style="color:#be185d;margin-top:16px"> Come Funziona</h3><p>Converte l'immagine in scala di grigi, poi applica un gradiente tra due colori scelti. A differenza di Gradient Map che preserva la saturazione originale, Duotone sostituisce completamente i colori.</p><table class="help-table"><tr style="background:#fce7f3"><th style="padding:6px;border:1px solid #be185d">Componente</th><th style="padding:6px;border:1px solid #be185d">Effetto</th></tr><tr><td class="help-table-cell"><strong>Colore Ombre</strong></td><td class="help-table-cell">Applicato alle zone più scure (toni bassi 0-127)</td></tr><tr><td class="help-table-cell"><strong>Colore Luci</strong></td><td class="help-table-cell">Applicato alle zone più chiare (toni alti 128-255)</td></tr><tr><td class="help-table-cell"><strong>Mezzitoni</strong></td><td class="help-table-cell">Sfumatura graduale tra i due colori</td></tr></table><h3 style="color:#be185d;margin-top:16px">️ Intensità (0-100)</h3><ul><li><strong>0-30:</strong> Tinta leggera, colori originali ancora visibili</li><li><strong>31-70:</strong> Bilanciato, duotone evidente ma non estremo</li><li><strong>71-100:</strong> Totale, sostituzione completa dei colori</li></ul><div style="background:#fce7f3;padding:12px;border-radius:6px;margin:12px 0"><strong> Combinazioni Colori Popolari:</strong><ul><li><strong>Blu Navy + Arancio (#1e3a8a → #fb923c):</strong> Instagram classic, caldo/freddo</li><li><strong>Viola + Rosa (#7c3aed → #ec4899):</strong> Vaporwave, synthwave, anni '80</li><li><strong>Verde Scuro + Giallo (#064e3b → #fde047):</strong> Natura, eco-friendly</li><li><strong>Rosso Scuro + Pesca (#7f1d1d → #fed7aa):</strong> Vintage warm, poster '70s</li><li><strong>Nero + Ciano (#000000 → #06b6d4):</strong> Tech, futuristico, cyberpunk</li><li><strong>Marrone + Beige (#78350f → #fef3c7):</strong> Sepia moderno, nostalgia</li></ul></div><div class="help-box-info"><strong> Regole Color Theory:</strong><ol class="help-list"><li><strong>Contrasto Temperatura:</strong> Freddo (blu/ciano) + Caldo (arancio/rosa) = dinamico</li><li><strong>Monocromatico:</strong> Stesso colore, diversa luminosità = elegante, minimal</li><li><strong>Complementari:</strong> Opposti sulla ruota (blu/arancio, rosso/verde) = massimo impatto</li><li><strong>Analoghi:</strong> Colori vicini (viola/rosa, blu/verde) = armonioso</li></ol></div><div class="help-box-warning"><strong>🆚 Duotone vs Gradient Map:</strong><table class="help-table"><tr><th style="padding:6px;border:1px solid #f59e0b">Aspetto</th><th style="padding:6px;border:1px solid #f59e0b">Duotone</th><th style="padding:6px;border:1px solid #f59e0b">Gradient Map</th></tr><tr><td class="help-table-cell"><strong>Colori originali</strong></td><td class="help-table-cell">Rimossi completamente</td><td class="help-table-cell">Mescolati con nuovi</td></tr><tr><td class="help-table-cell"><strong>Look finale</strong></td><td class="help-table-cell">Flat, grafico, poster</td><td class="help-table-cell">Più fotografico</td></tr><tr><td class="help-table-cell"><strong>Uso tipico</strong></td><td class="help-table-cell">Design, social media</td><td class="help-table-cell">Cinema, fotografia pro</td></tr></table></div><div class="help-box-success"><strong> Applicazioni Specifiche:</strong><ul><li><strong>Instagram Feed Coerente:</strong> Usa stessa combo duotone su tutte le foto per look unificato</li><li><strong>Poster Musicali:</strong> Duotone intenso (90-100) con colori vivaci</li><li><strong>Branding Aziendale:</strong> Duotone con colori corporate per consistenza visiva</li><li><strong>Ritratti Artistici:</strong> Intensità media (50-70) per effetto drammatico ma riconoscibile</li></ul></div><div class="help-box-danger"><strong>️ Considerazioni:</strong><ul><li>Duotone intenso (>80) perde dettagli fini e texture</li><li>Non ideale per fotografia naturalistica o ritratti beauty</li><li>Funziona meglio su immagini con contrasto già buono</li><li>Colori troppo simili = risultato monotono, scegli colori distinti</li></ul></div><p><strong> Pro Tip:</strong> Per duotone vintage perfetto: 1) Aggiungi Noise leggero (15-20), 2) Applica Duotone (Int. 70-80), 3) Riduci leggermente Contrast (-10). Ottieni look pellicola Polaroid istantaneo!</p>`,
hslshift:`<h3 style="color:#0e7490"> Cos'è HSL Shift (Hue/Saturation/Lightness)?</h3><p>Controllo avanzato dei colori tramite i tre canali fondamentali del modello HSL: Tonalità (Hue), Saturazione (Saturation) e Luminosità (Lightness). Permette manipolazioni creative impossibili con RGB. Essenziale per:</p><ul><li>Color grading professionale e creative</li><li>Correzione dominanti colore selettive</li><li>Trasformazioni cromatiche artistiche</li><li>Conversione stagionale (estate→autunno)</li><li>Matching colori tra diverse foto</li></ul><h3 style="color:#0e7490;margin-top:16px">️ I 3 Controlli HSL</h3><p><strong>1. Hue / Tonalità (-180° a +180°):</strong> Ruota la ruota cromatica</p><table class="help-table"><tr style="background:#cffafe"><th style="padding:6px;border:1px solid #0e7490">Shift</th><th style="padding:6px;border:1px solid #0e7490">Trasformazione Colore</th><th style="padding:6px;border:1px solid #0e7490">Uso Creativo</th></tr><tr><td class="help-table-cell">-180° / +180°</td><td class="help-table-cell">Colori complementari opposti</td><td class="help-table-cell">Inversione totale</td></tr><tr><td class="help-table-cell">-60° / +60°</td><td class="help-table-cell">Rosso→Viola, Blu→Ciano, Verde→Giallo</td><td class="help-table-cell">Effetti creativi moderati</td></tr><tr><td class="help-table-cell">-30° / +30°</td><td class="help-table-cell">Shift tonale leggero</td><td class="help-table-cell">Correzioni fini, warm/cool</td></tr></table><p><strong>Esempi Trasformazioni Hue:</strong></p><ul><li><strong>0°:</strong> Nessun cambiamento</li><li><strong>+30°:</strong> Rosso→Arancio, Verde→Giallo-verde, Blu→Ciano</li><li><strong>+60°:</strong> Rosso→Giallo, Verde→Ciano, Blu→Viola</li><li><strong>+120°:</strong> Rosso→Verde, Verde→Blu, Blu→Rosso (triade)</li><li><strong>+180°:</strong> Inversione completa (rosso→ciano, giallo→blu)</li></ul><p><strong>2. Saturation / Saturazione (-100% a +100%):</strong> Intensità/vivacità colori</p><table class="help-table"><tr style="background:#cffafe"><th style="padding:6px;border:1px solid #0e7490">Valore</th><th style="padding:6px;border:1px solid #0e7490">Effetto</th></tr><tr><td class="help-table-cell">-100%</td><td class="help-table-cell"> Bianco e nero completo</td></tr><tr><td class="help-table-cell">-50% a -70%</td><td class="help-table-cell">Desaturato, vintage, faded</td></tr><tr><td class="help-table-cell">-20% a -40%</td><td class="help-table-cell">Muted, pastello, elegante</td></tr><tr><td class="help-table-cell">0%</td><td class="help-table-cell">Originale</td></tr><tr><td class="help-table-cell">+20% a +40%</td><td class="help-table-cell">Vivace, social media</td></tr><tr><td class="help-table-cell">+50% a +80%</td><td class="help-table-cell">Iper-saturo, poster, pop art</td></tr><tr><td class="help-table-cell">+90% a +100%</td><td class="help-table-cell"> Estremo, psichedelico</td></tr></table><p><strong>3. Lightness / Luminosità (-100% a +100%):</strong> Chiaro/scuro senza alterare hue</p><ul><li><strong>-100%:</strong> Nero puro (tutto scuro)</li><li><strong>-50%:</strong> Scurisce, shadow-heavy, moody</li><li><strong>0%:</strong> Originale</li><li><strong>+50%:</strong> Schiarisce, high-key, airy</li><li><strong>+100%:</strong> Bianco puro (tutto chiaro)</li></ul><div style="background:#cffafe;padding:12px;border-radius:6px;margin:12px 0"><strong> Preset Creativi:</strong><ul><li><strong>Autumn Boost:</strong> Hue +10°, Sat +30%, Light 0% (enfatizza toni caldi)</li><li><strong>Cool Teal:</strong> Hue -20°, Sat +20%, Light -10% (look cinematografico freddo)</li><li><strong>Vintage Fade:</strong> Hue 0°, Sat -40%, Light +15% (film sbiadito)</li><li><strong>Candy Pop:</strong> Hue +30°, Sat +60%, Light +10% (colori caramella)</li><li><strong>Nordic Mood:</strong> Hue -15°, Sat -30%, Light -5% (scandinavo, muted)</li><li><strong>Infrared Sim:</strong> Hue +180°, Sat +50%, Light +20% (effetto infrarosso)</li></ul></div><div class="help-box-info"><strong> Tecniche Avanzate:</strong><ol class="help-list"><li><strong>Cambio Stagione:</strong> Estate→Autunno: Hue +15° (verdi verso giallo/arancio)</li><li><strong>Cielo Drammatico:</strong> Se cielo è blu, Hue -20° lo rende più intenso/ciano</li><li><strong>Correzione Dominante Verde:</strong> Hue +30° rimuove cast verde da luci fluorescenti</li><li><strong>Look Analogico:</strong> Sat -25%, Light +10% simula pellicola sovraesposta</li><li><strong>Matching Colors:</strong> Usa Hue shift per uniformare tonalità tra foto diverse</li></ol></div><div class="help-box-warning"><strong>🆚 HSL vs RGB:</strong><ul><li><strong>RGB:</strong> Manipola rosso/verde/blu → intuitivo per tecnici, meno per artisti</li><li><strong>HSL:</strong> Manipola tonalità/saturazione/luminosità → intuitivo per color grading creativo</li><li><strong>Vantaggio HSL:</strong> Puoi cambiare colore (Hue) senza toccare luminosità, impossibile con RGB</li></ul></div><div class="help-box-success"><strong> Quando Usare Quale Controllo:</strong><ul><li><strong>Solo Hue:</strong> Vuoi cambiare il "colore" ma non l'intensità (es: verde→blu)</li><li><strong>Solo Saturation:</strong> Vuoi più/meno vivacità senza cambiare il colore base</li><li><strong>Solo Lightness:</strong> Vuoi schiarire/scurire mantenendo il colore identico</li><li><strong>Hue + Sat:</strong> Trasformazione creativa completa (es: look cinematografico)</li><li><strong>Tutti e 3:</strong> Massimo controllo per effetti artistici estremi</li></ul></div><div class="help-box-danger"><strong>️ Errori Comuni:</strong><ul><li><strong>Hue shift >±90°:</strong> Colori innaturali su ritratti (pelle verde/viola)</li><li><strong>Sat +70%+:</strong> Poster colori, clipping digitale, perdita dettagli</li><li><strong>Light ±80%+:</strong> Perde informazione tonale, clipping estremo</li><li><strong>Regola d'oro:</strong> Per look naturali, resta entro ±30° Hue, ±40% Sat, ±30% Light</li></ul></div><p><strong> Pro Tip:</strong> Combina HSL Shift con Selective Color per controllo totale: 1) HSL per look globale, 2) Selective Color per aggiustare specifici canali colore. È il workflow dei color grader Hollywood!</p>`,
oilpainting:`<h3 style="color:#a16207"> Cos'è Oil Painting (Pittura a Olio)?</h3><p>Algoritmo che trasforma la fotografia in un dipinto ad olio simulando pennellate artistiche. Analizza l'immagine e ridistribuisce i colori in "macchie" che imitano il tocco del pennello su tela. Perfetto per:</p><ul><li>Trasformare foto in opere d'arte pittoriche</li><li>Ritratti artistici e regalo personalizzato</li><li>Copertine album, poster artistici</li><li>Nascondere imperfezioni foto mantenendo estetica</li><li>Effetti per illustrazioni e concept art</li></ul><h3 style="color:#a16207;margin-top:16px">️ I Parametri</h3><p><strong>1. Dimensione Pennellata / Brush Size (1-10):</strong></p><table class="help-table"><tr style="background:#fef9c3"><th style="padding:6px;border:1px solid #a16207">Valore</th><th style="padding:6px;border:1px solid #a16207">Effetto</th><th style="padding:6px;border:1px solid #a16207">Stile Artistico</th></tr><tr><td class="help-table-cell">1-3</td><td class="help-table-cell">Pennellate fini, dettagliate</td><td class="help-table-cell">Realismo, ritratti ravvicinati</td></tr><tr><td class="help-table-cell">4-6</td><td class="help-table-cell">Media, bilanciata</td><td class="help-table-cell">Impressionismo classico</td></tr><tr><td class="help-table-cell">7-9</td><td class="help-table-cell">Pennellate larghe, espressioniste</td><td class="help-table-cell">Van Gogh, Monet</td></tr><tr><td class="help-table-cell">10</td><td class="help-table-cell">Molto grossolano, astratto</td><td class="help-table-cell">Espressionismo astratto</td></tr></table><p><strong>2. Intensità / Intensity (1-5):</strong> Quanto è marcato l'effetto pittorico</p><ul><li><strong>1-2:</strong> Leggero, foto-realismo con tocco pittorico sottile</li><li><strong>3:</strong> Bilanciato, chiaro effetto olio ma riconoscibile</li><li><strong>4-5:</strong> Forte, pittura marcata, meno fotografico</li></ul><div style="background:#fef9c3;padding:12px;border-radius:6px;margin:12px 0"><strong> Stili Pittorici Famosi:</strong><ul><li><strong>Impressionismo (Monet):</strong> Brush 6-7, Intensity 3-4</li><li><strong>Post-Impressionismo (Van Gogh):</strong> Brush 8-9, Intensity 4-5</li><li><strong>Realismo Romantico:</strong> Brush 3-4, Intensity 2-3</li><li><strong>Espressionismo:</strong> Brush 7-10, Intensity 4-5</li><li><strong>Ritratto Classico:</strong> Brush 4-5, Intensity 3</li></ul></div><div class="help-box-info"><strong> Come Funziona (Tecnico):</strong><ol class="help-list"><li>Analizza i bordi e le aree di colore uniforme nell'immagine</li><li>Raggruppa pixel simili in "macchie" di dimensione definita da Brush Size</li><li>Applica sfumatura tra macchie adiacenti per simulare mescolanza colori</li><li>Intensity controlla quanto i bordi originali vengono preservati vs sfumati</li></ol></div><div class="help-box-success"><strong> Applicazioni Specifiche:</strong><ul><li><strong>Ritratto Regalo:</strong> Brush 4, Int 3 (bilanciato, riconoscibile ma artistico)</li><li><strong>Paesaggio Impressionista:</strong> Brush 7, Int 4 (pennellate visibili, colori vivaci)</li><li><strong>Pet Portrait:</strong> Brush 5, Int 3 (texture pelo diventa pennellate naturali)</li><li><strong>Abstract Art:</strong> Brush 9-10, Int 5 (massima stilizzazione)</li><li><strong>Cover Album:</strong> Brush 6, Int 4 (artistico ma leggibile)</li></ul></div><div class="help-box-warning"><strong>🆚 Oil Painting vs Altri Effetti Artistici:</strong><ul><li><strong>vs Watercolor:</strong> Oil = pennellate dense e coprenti, Watercolor = trasparente e fluido</li><li><strong>vs Sketch:</strong> Oil mantiene colori pieni, Sketch converte in linee</li><li><strong>vs Pixelate:</strong> Oil crea forme organiche, Pixelate crea blocchi geometrici</li></ul></div><div class="help-box-danger"><strong>️ Considerazioni:</strong><ul><li>Effetto computazionalmente intenso - può richiedere tempo su immagini grandi</li><li>Dettagli fini (testo piccolo, texture minute) vengono persi</li><li>Funziona meglio su foto con contrasto buono e colori definiti</li><li>Foto molto scure o sovraesposte danno risultati meno convincenti</li><li><strong>Tip:</strong> Applica prima correzioni tonali (Exposure, Contrast, Vibrance) per risultato ottimale</li></ul></div><p><strong> Pro Tip:</strong> Per ritratto Oil Painting da stampa professionale: 1) Correggi esposizione e colori, 2) Applica Oil (Brush 4-5, Int 3), 3) Aggiungi leggero Clarity (+20) per "texture tela", 4) Vignette sottile (30) per focus. Risultato: ritratto artistico degno di galleria!</p>`,motionblur:`<h3 style="color:#667eea"> Cos'è il Motion Blur (Sfocatura di Movimento)?</h3><p>Simula l'effetto di movimento veloce catturato durante l'esposizione fotografica, creando una scia direzionale che comunica velocità e dinamismo. Questa tecnica, usata professionalmente in fotografia sportiva e cinematografica, trasforma immagini statiche in scene cariche di energia. Perfetto per:</p><ul><li>Creare senso di velocità su veicoli, atleti, oggetti in movimento</li><li>Effetti dinamici per poster, copertine, pubblicità sportive</li><li>Simulare panning fotografico (soggetto fermo, sfondo mosso)</li><li>Aggiungere energia visiva a composizioni statiche</li><li>Effetti cinematici e videoludici</li></ul><h3 style="color:#667eea;margin-top:16px">️ I Parametri</h3><p><strong>1. Distanza / Distance (1-50 px):</strong> Lunghezza della scia di movimento</p><table class="help-table"><tr style="background:#e0e7ff"><th style="padding:6px;border:1px solid #667eea">Valore</th><th style="padding:6px;border:1px solid #667eea">Effetto Visivo</th><th style="padding:6px;border:1px solid #667eea">Quando Usare</th></tr><tr><td class="help-table-cell">1-10 px</td><td class="help-table-cell">Movimento leggero, sottile</td><td class="help-table-cell">Ritratti artistici, leggera dinamica</td></tr><tr><td class="help-table-cell">11-25 px</td><td class="help-table-cell">Velocità media, bilanciata</td><td class="help-table-cell">Auto in città, ciclisti, uso generale</td></tr><tr><td class="help-table-cell">26-40 px</td><td class="help-table-cell">Velocità alta, drammatico</td><td class="help-table-cell">Auto da corsa, moto, sport estremi</td></tr><tr><td class="help-table-cell">41-50 px</td><td class="help-table-cell">Velocità estrema, astratto</td><td class="help-table-cell">Effetti speciali, design futuristico</td></tr></table><p><strong>2. Angolo / Angle (0-360°):</strong> Direzione del movimento</p><table class="help-table"><tr style="background:#e0e7ff"><th style="padding:6px;border:1px solid #667eea">Angolo</th><th style="padding:6px;border:1px solid #667eea">Direzione</th><th style="padding:6px;border:1px solid #667eea">Effetto Percepito</th></tr><tr><td class="help-table-cell">0°</td><td class="help-table-cell">→ Orizzontale destra</td><td class="help-table-cell">Veicolo che va verso destra</td></tr><tr><td class="help-table-cell">90°</td><td class="help-table-cell">↓ Verticale basso</td><td class="help-table-cell">Caduta, discesa, gravità</td></tr><tr><td class="help-table-cell">180°</td><td class="help-table-cell">← Orizzontale sinistra</td><td class="help-table-cell">Veicolo che va verso sinistra</td></tr><tr><td class="help-table-cell">270°</td><td class="help-table-cell">↑ Verticale alto</td><td class="help-table-cell">Salto, decollo, ascesa</td></tr><tr><td class="help-table-cell">45°, 135°, 225°, 315°</td><td class="help-table-cell">↗ ↘ ↙ ↖ Diagonali</td><td class="help-table-cell">Movimenti complessi, dinamica extra</td></tr></table><div style="background:#e0e7ff;padding:12px;border-radius:6px;margin:12px 0"><strong>️ Preset per Genere:</strong><ul><li><strong>Auto da Corsa:</strong> Distance 30-40px, Angle 0° o 180° (orizzontale)</li><li><strong>Atleta in Salto:</strong> Distance 20px, Angle 270° (verso alto)</li><li><strong>Ciclista Urbano:</strong> Distance 15-20px, Angle 0° o 180°</li><li><strong>Moto in Curva:</strong> Distance 35px, Angle 45° o 315° (diagonale)</li><li><strong>Snowboarder Discesa:</strong> Distance 25px, Angle 90° o 135° (verso basso)</li><li><strong>Ballerino/a:</strong> Distance 10-15px, Angle qualsiasi (dipende dal movimento)</li></ul></div><div class="help-box-info"><strong> Tecniche Fotografiche Simulate:</strong><ul><li><strong>Panning Shot:</strong> Usa 180° se oggetto va a sinistra, 0° se va a destra. Distance 20-30px.</li><li><strong>Zoom Burst:</strong> Non simulabile direttamente (usa Radial Blur invece)</li><li><strong>Slow Shutter:</strong> Distance alto (30-50px) per tempi di esposizione lunghi</li><li><strong>Freeze Frame Effect:</strong> Applica su sfondo, mantieni soggetto originale (tecnica compositing)</li></ul></div><div class="help-box-success"><strong> Composizione Avanzata:</strong><ol class="help-list"><li><strong>Soggetto + Sfondo Dinamico:</strong> Crea due layer, applica Motion Blur solo allo sfondo (tecnica panning)</li><li><strong>Trail Effect:</strong> Duplica layer, applica Motion Blur con opacità ridotta al 50%</li><li><strong>Multi-direzionale:</strong> Applica Motion Blur multipli con angoli diversi per caos dinamico</li><li><strong>Fade Out:</strong> Combina con Opacity gradient per scia che svanisce</li></ol></div><div class="help-box-warning"><strong>🆚 Motion Blur vs Altri Effetti Blur:</strong><ul><li><strong>vs Gaussian Blur:</strong> Motion = direzionale/lineare, Gaussian = uniforme in tutte direzioni</li><li><strong>vs Radial Blur:</strong> Motion = lineare, Radial = circolare attorno a un punto (zoom/spin)</li><li><strong>vs Tilt-Shift:</strong> Motion = tutto sfocato uniformemente, Tilt-Shift = fascia centrale a fuoco</li><li>Motion Blur comunica MOVIMENTO, altri blur comunicano profondità/distanza</li></ul></div><div class="help-box-danger"><strong>️ Considerazioni Importanti:</strong><ul><li>Motion Blur funziona meglio su soggetti ben definiti con contrasto netto</li><li>Su immagini molto dettagliate (texture fini) può creare rumore visivo</li><li>Distance oltre 40px può rendere l'immagine illeggibile se applicato a tutto</li><li><strong>Regola del Realismo:</strong> Distance deve essere proporzionale alla velocità percepita</li><li>Per risultato professionale: combina con correzione tonale (Contrast +10-20)</li></ul></div><p><strong> Pro Tip:</strong> Per effetto panning cinematografico perfetto: 1) Isola soggetto principale, 2) Applica Motion Blur solo allo sfondo (Distance 25-35px), 3) Aggiungi leggero Vignette (30) per focus, 4) Contrast +15 sul soggetto per farlo risaltare. Risultato: foto sportiva da copertina National Geographic!</p>`,tiltshift:`<h3 style="color:#f5576c"> Cos'è il Tilt-Shift (Effetto Miniatura)?</h3><p>Tecnica fotografica che simula l'effetto delle lenti decentrabili (tilt-shift lens) usate in fotografia architettonica e di paesaggio. Crea l'illusione che scene reali siano modellini in miniatura, sfruttando la profondità di campo ridotta tipica della fotografia macro. Questo effetto inganna il cervello facendogli percepire scale e proporzioni alterate. Perfetto per:</p><ul><li>Trasformare paesaggi urbani in villaggi giocattolo</li><li>Creare atmosfera surreale e giocosa</li><li>Time-lapse con effetto miniatura (stile "Tiny World")</li><li>Enfatizzare soggetto centrale isolandolo dallo sfondo</li><li>Design poster, copertine, pubblicità creative</li><li>Video tutorial stile "Come Funziona" con visuale dall'alto</li></ul><h3 style="color:#f5576c;margin-top:16px">️ I Parametri</h3><p><strong>1. Intensità Blur (1-30):</strong> Quanto sono sfocate le zone fuori fuoco</p><table class="help-table"><tr style="background:#ffe5ec"><th style="padding:6px;border:1px solid #f5576c">Valore</th><th style="padding:6px;border:1px solid #f5576c">Effetto Profondità Campo</th><th style="padding:6px;border:1px solid #f5576c">Quando Usare</th></tr><tr><td class="help-table-cell">1-8</td><td class="help-table-cell">DOF leggero, sottile</td><td class="help-table-cell">Ritratti, focus selettivo discreto</td></tr><tr><td class="help-table-cell">9-15</td><td class="help-table-cell">DOF medio, bilanciato</td><td class="help-table-cell">Paesaggi urbani, uso generale miniatura</td></tr><tr><td class="help-table-cell">16-23</td><td class="help-table-cell">DOF forte, marcato</td><td class="help-table-cell">Effetto toy camera, miniatura estrema</td></tr><tr><td class="help-table-cell">24-30</td><td class="help-table-cell">DOF estremo, artistico</td><td class="help-table-cell">Effetti speciali, astrattismo</td></tr></table><p><strong>2. Dimensione Focus (10-80%):</strong> Larghezza della fascia centrale a fuoco</p><table class="help-table"><tr style="background:#ffe5ec"><th style="padding:6px;border:1px solid #f5576c">Percentuale</th><th style="padding:6px;border:1px solid #f5576c">Area Nitida</th><th style="padding:6px;border:1px solid #f5576c">Effetto Finale</th></tr><tr><td class="help-table-cell">10-25%</td><td class="help-table-cell">Fascia stretta</td><td class="help-table-cell">Miniatura estrema, toy-like</td></tr><tr><td class="help-table-cell">30-50%</td><td class="help-table-cell">Bilanciata</td><td class="help-table-cell">Classico tilt-shift, uso generale</td></tr><tr><td class="help-table-cell">55-70%</td><td class="help-table-cell">Ampia</td><td class="help-table-cell">Sottile, elegante, enfasi centrale</td></tr><tr><td class="help-table-cell">75-80%</td><td class="help-table-cell">Molto ampia</td><td class="help-table-cell">Quasi tutto a fuoco, effetto minimo</td></tr></table><div style="background:#ffe5ec;padding:12px;border-radius:6px;margin:12px 0"><strong>️ Soggetti Ideali per Tilt-Shift:</strong><ul><li><strong> PERFETTI:</strong> Paesaggi urbani dall'alto, traffico cittadino, parchi giochi, porti con barche, stazioni ferroviarie, aeroporti, eventi sportivi ripresi da stadio</li><li><strong> MOLTO BUONI:</strong> Architettura, piazze affollate, mercati, fiere, campeggi, parcheggi</li><li><strong>️ DIFFICILI:</strong> Primi piani ravvicinati (troppo pochi piani di profondità), cieli vuoti, superfici piatte uniformi</li><li><strong> DA EVITARE:</strong> Ritratti frontali (distorce volti), macro esistenti (già sfocato), scene indoor chiuse</li></ul></div><div class="help-box-info"><strong> Come Massimizzare l'Effetto Miniatura:</strong><ol class="help-list"><li><strong>Angolazione:</strong> Foto dall'alto (45-80°) funzionano meglio che frontali</li><li><strong>Colori:</strong> Aumenta Saturation (+15-25) per look toy-like vivace</li><li><strong>Contrasto:</strong> Aggiungi Contrast (+10-20) per look "plastilina"</li><li><strong>Vignette:</strong> Leggera vignette (20-30) aumenta effetto tunnel/modellino</li><li><strong>Brightness:</strong> Leggermente sovraesposto (+0.3 EV) per atmosfera giocosa</li></ol></div><div class="help-box-success"><strong> Preset per Uso Specifico:</strong><ul><li><strong>Città Miniatura Classica:</strong> Blur 12, Focus 40%, Saturation +20, Contrast +15</li><li><strong>Toy Camera Vintage:</strong> Blur 18, Focus 30%, Vignette 40, Temperature +10</li><li><strong>Aerial Photography:</strong> Blur 10, Focus 50%, Clarity +25 (enfatizza texture modellino)</li><li><strong>Street Life Miniature:</strong> Blur 15, Focus 35%, Vibrance +30 (persone sembrano figurine)</li><li><strong>Architectural Model:</strong> Blur 8, Focus 60%, Sharpen +20 (dettagli costruzione)</li></ul></div><div class="help-box-warning"><strong> Psicologia dell'Effetto (Perché Funziona?):</strong><p>Il cervello umano associa profondità di campo ridotta a fotografia macro di oggetti piccoli:</p><ul><li>Macro lens = f/2.8-f/5.6 = DOF ristretto = soggetto piccolo</li><li>Paesaggio reale = f/8-f/16 = tutto a fuoco</li><li>Tilt-Shift inverte la logica: paesaggio + DOF ristretto = cervello pensa "è piccolo!"</li><li>Colori saturi rafforzano illusione (giocattoli hanno colori vivaci)</li></ul></div><div class="help-box-danger"><strong>️ Errori Comuni da Evitare:</strong><ul><li><strong>Focus troppo stretto (<30%):</strong> Rende illeggibile, perde contesto</li><li><strong>Blur eccessivo (>25):</strong> Sembra errore tecnico, non effetto voluto</li><li><strong>Su foto già sfocate:</strong> Accentua difetti invece di creare effetto</li><li><strong>Soggetti troppo vicini:</strong> Non hanno piani multipli per creare illusione profondità</li><li><strong>Combinare con Vignette forte (>50):</strong> Troppi effetti competono, risultato confuso</li></ul></div><p><strong> Pro Tip Ultra:</strong> Per time-lapse Tilt-Shift stile BBC "Human Planet" o "Tiny World": 1) Riprendi dall'alto (almeno 30° angolazione), 2) Tilt-Shift Blur 14, Focus 38%, 3) Saturation +25, Contrast +18, Brightness +0.4, 4) Speed up video 8-12x, 5) Aggiungi soundtrack giocoso. Risultato: realtà sembra stop-motion LEGO!</p>`,gaussianblur:`<h3 style="color:#4facfe"> Cos'è il Gaussian Blur Pro (Sfocatura Gaussiana)?</h3><p>Algoritmo matematico avanzato di sfocatura che simula il comportamento ottico di una lente fuori fuoco, distribuendo i pixel secondo una curva di Gauss (campana). A differenza del box blur semplice, il gaussian blur produce sfocature più naturali e piacevoli all'occhio perché rispetta la fisica della diffrazione luminosa. È lo standard industriale in fotografia, cinematografia, e computer graphics. Perfetto per:</p><ul><li>Creare profondità di campo (DOF) artificiale simulando bokeh</li><li>Sfocare sfondi per privacy (volti, targhe, documenti)</li><li>Preparare immagini per effetti glow, bloom, soft focus</li><li>Ridurre rumore digitale preservando forme generali</li><li>Background blur per ritratti (simula apertura ampia f/1.4-f/2.8)</li><li>Motion graphics e transizioni smooth</li></ul><h3 style="color:#4facfe;margin-top:16px">️ I Parametri</h3><p><strong>1. Raggio / Radius (1-100 px):</strong> Intensità della sfocatura</p><table class="help-table"><tr style="background:#e0f2fe"><th style="padding:6px;border:1px solid #4facfe">Raggio</th><th style="padding:6px;border:1px solid #4facfe">Effetto Visivo</th><th style="padding:6px;border:1px solid #4facfe">Applicazioni Tipiche</th></tr><tr><td class="help-table-cell">1-10 px</td><td class="help-table-cell">Leggero, soft focus</td><td class="help-table-cell">Skin smoothing, anti-aliasing, riduzione rumore</td></tr><tr><td class="help-table-cell">11-30 px</td><td class="help-table-cell">Medio, sfocatura bilanciata</td><td class="help-table-cell">Background blur ritratti, privacy media</td></tr><tr><td class="help-table-cell">31-60 px</td><td class="help-table-cell">Forte, marcato</td><td class="help-table-cell">DOF profondo, privacy totale, effetti artistici</td></tr><tr><td class="help-table-cell">61-100 px</td><td class="help-table-cell">Estremo, astratto</td><td class="help-table-cell">Glow base, backdrop completamente sfocato, design</td></tr></table><p><strong>2. Qualità:</strong> Numero di passaggi algoritmici</p><table class="help-table"><tr style="background:#e0f2fe"><th style="padding:6px;border:1px solid #4facfe">Qualità</th><th style="padding:6px;border:1px solid #4facfe">Passaggi</th><th style="padding:6px;border:1px solid #4facfe">Velocità</th><th style="padding:6px;border:1px solid #4facfe">Risultato</th></tr><tr><td class="help-table-cell">Veloce</td><td class="help-table-cell">1 pass</td><td class="help-table-cell"> Istantanea</td><td class="help-table-cell">Buona, possibile banding leggero</td></tr><tr><td class="help-table-cell">Bilanciata</td><td class="help-table-cell">2 pass</td><td class="help-table-cell"> Rapida</td><td class="help-table-cell">Eccellente, uso generale professionale</td></tr><tr><td class="help-table-cell">Alta</td><td class="help-table-cell">3 pass</td><td class="help-table-cell"> Più lenta</td><td class="help-table-cell">Perfetta, zero artefatti, stampa</td></tr></table><div style="background:#e0f2fe;padding:12px;border-radius:6px;margin:12px 0"><strong> Applicazioni Professionali per Raggio:</strong><ul><li><strong>Radius 3-5px:</strong> Skin softening ritratti beauty (riduce pori senza sembrare finto)</li><li><strong>Radius 8-12px:</strong> Background blur medio (simula f/2.8 portrait lens)</li><li><strong>Radius 15-25px:</strong> Privacy blur (volti, targhe) riconoscibilità zero</li><li><strong>Radius 20-30px:</strong> DOF forte (simula f/1.4 apertura ampia)</li><li><strong>Radius 40-60px:</strong> Backdrop completamente fuori fuoco (simula macro f/2.8)</li><li><strong>Radius 80-100px:</strong> Base per glow/bloom effects</li></ul></div><div class="help-box-info"><strong> Come Funziona (Tecnico Dettagliato):</strong><p>Gaussian Blur applica una matrice di convoluzione con pesi distribuiti secondo formula gaussiana:</p><ul><li><strong>Formula:</strong> G(x,y) = (1/2πσ²)e^(-(x²+y²)/2σ²) dove σ = radius</li><li><strong>Kernel:</strong> Matrice peso centrale alto, periferia bassa (curva a campana)</li><li><strong>Processo:</strong> Ogni pixel diventa media ponderata dei vicini secondo kernel</li><li><strong>Separabilità:</strong> Si può fare in 2 pass (H+V) invece di 1 pass 2D (più veloce)</li><li><strong>Multi-pass:</strong> Qualità Alta applica blur 3 volte riducendo radius → smoother</li></ul></div><div class="help-box-success"><strong>🆚 Gaussian Blur vs Altri Tipi di Blur:</strong><table class="help-table"><tr style="background:#f0f9ff"><th style="padding:6px;border:1px solid #0ea5e9">Tipo Blur</th><th style="padding:6px;border:1px solid #0ea5e9">Distribuzione</th><th style="padding:6px;border:1px solid #0ea5e9">Uso Ideale</th></tr><tr><td class="help-table-cell"><strong>Gaussian</strong></td><td class="help-table-cell">Campana, smooth</td><td class="help-table-cell">DOF, ritratti, tutto</td></tr><tr><td class="help-table-cell"><strong>Box Blur</strong></td><td class="help-table-cell">Uniforme, squadrato</td><td class="help-table-cell">Velocità su HW limitato</td></tr><tr><td class="help-table-cell"><strong>Motion</strong></td><td class="help-table-cell">Lineare direzionale</td><td class="help-table-cell">Velocità, movimento</td></tr><tr><td class="help-table-cell"><strong>Radial</strong></td><td class="help-table-cell">Circolare da centro</td><td class="help-table-cell">Zoom burst, vortice</td></tr><tr><td class="help-table-cell"><strong>Lens Blur</strong></td><td class="help-table-cell">Bokeh shapes (▽ ◯ ⬡)</td><td class="help-table-cell">Simulazione bokeh ottico</td></tr></table><p><strong>Perché Gaussian è Standard?</strong> Più naturale all'occhio, no artefatti squadrati, matematicamente perfetto.</p></div><div class="help-box-warning"><strong> Workflow Compositing Avanzato:</strong><ol class="help-list"><li><strong>DOF Simulato:</strong> Crea depth map, applica Gaussian progressivo per distanza</li><li><strong>Glow Effect:</strong> Duplica layer → Gaussian 50-80px → Blend mode Screen → Opacity 40%</li><li><strong>Soft Focus Portrait:</strong> Gaussian 5px → Blend con originale 50% → Contrast +10</li><li><strong>Privacy Blur Intelligente:</strong> Maschera volti → Gaussian 20px solo su maschera</li><li><strong>Dreamy Haze:</strong> Gaussian 30px → Brightness +0.5 → Blend Lighten 60%</li></ol></div><div class="help-box-danger"><strong>️ Limiti e Considerazioni:</strong><ul><li><strong>Radius eccessivo (>80px):</strong> Perde completamente dettagli, può creare artefatti colore</li><li><strong>Su immagini piccole:</strong> Radius dovrebbe scalare con risoluzione (es: 800px wide max radius 30-40)</li><li><strong>Qualità Alta su 4K+:</strong> Può richiedere tempo elaborazione significativo</li><li><strong>Non recuperabile:</strong> Blur è irreversibile, salva sempre copia originale prima</li><li><strong>Banding su gradienti:</strong> Se radius molto alto + qualità veloce, possibile posterizzazione</li></ul></div><p><strong> Pro Tip Master:</strong> Per ritratto DOF professionale stile 85mm f/1.4: 1) Isola soggetto dal background con selezione precisa, 2) Applica Gaussian Blur Radius 25-35px solo a sfondo (Qualità Alta), 3) Aggiungi leggero Chromatic Aberration simulato sui bordi sfocati (shift rosso-ciano 1-2px), 4) Subtle Vignette 15-20 per richiamare attenzione centrale. Risultato: indistinguibile da bokeh reale Zeiss Planar!</p>`};


// Gestore F2 per advanced effects
document.addEventListener("keydown",(e=>{if("F2"===e.key){const t=document.getElementById("advanced-effects-panel");if(!t||"none"===t.style.display)return;e.preventDefault();const n=document.activeElement;let a=null;if(n.id.includes("pixelate")||n.closest("[id*=pixelate]"))a="pixelate";else if(n.id.includes("glow")||n.closest("[id*=glow]"))a="glow";else if(n.id.includes("vignette")||n.closest("[id*=vignette]"))a="vignette";else if(n.id.includes("sharpen")||n.closest("[id*=sharpen]"))a="sharpen";else if(n.id.includes("autolevels")||n.closest("[id*=autolevels]"))a="autolevels";else if(n.id.includes("noise")||n.closest("[id*=noise]"))a="noise";else if(n.id.includes("temperature")||n.closest("[id*=temperature]")||n.id.includes("tint"))a="temperature";else if(n.id.includes("gradient-text")||n.closest("[id*=gradient-text]"))a="gradienttext";else if(n.id.includes("blur")||n.closest("[id*=blur]"))a="blur";else if(n.id.includes("emboss")||n.closest("[id*=emboss]"))a="emboss";else if(n.id.includes("edge")||n.closest("[id*=edge]"))a="edgedetect";else if(n.id.includes("clarity")||n.closest("[id*=clarity]"))a="clarity";else if(n.id.includes("denoise")||n.closest("[id*=denoise]"))a="denoise";else if(n.id.includes("gradmap")||n.closest("[id*=gradmap]"))a="gradientmap";else if(n.id.includes("vibrance")||n.closest("[id*=vibrance]"))a="vibrance";else if(n.id.includes("whitebalance")||n.closest("[id*=whitebalance]"))a="whitebalance";else if(n.id.includes("highlights")||n.id.includes("shadows")||n.closest("[id*=highlights]")||n.closest("[id*=shadows]"))a="highlights";else if(n.id.includes("bloom")||n.closest("[id*=bloom]"))a="bloom";else if(n.id.includes("blurpro")||n.closest("[id*=blurpro]"))a="blurpro";else if(n.id.includes("exposure")||n.closest("[id*=exposure]"))a="exposure";else if(n.id.includes("threshold")||n.closest("[id*=threshold]"))a="threshold";else if(n.id.includes("invert")||n.closest("[id*=invert]"))a="invert";else if(n.id.includes("brightness")||n.closest("[id*=brightness]"))a="brightness";else if(n.id.includes("contrast")||n.closest("[id*=contrast]"))a="contrast";else if(n.id.includes("levels")||n.id.includes("blacks")||n.id.includes("whites")||n.id.includes("midtones")||n.closest("[id*=levels]"))a="levels";else if(n.id.includes("duotone")||n.closest("[id*=duotone]"))a="duotone";else if(n.id.includes("hsl")||n.id.includes("hue")||n.id.includes("saturation")||n.id.includes("lightness")||n.closest("[id*=hsl]"))a="hslshift";else if(n.id.includes("oil")||n.closest("[id*=oil]"))a="oilpainting";else if(n.id.includes("motionblur")||n.closest("[id*=motionblur]"))a="motionblur";else if(n.id.includes("tiltshift")||n.closest("[id*=tiltshift]"))a="tiltshift";else if(n.id.includes("gaussianblur")||n.closest("[id*=gaussianblur]"))a="gaussianblur";else if(n.id.includes("chromatic")||n.closest("[id*=chromatic]"))a="chromatic";else if(n.id.includes("glitch")||n.closest("[id*=glitch]"))a="glitch";else if(n.id.includes("vhs")||n.closest("[id*=vhs]"))a="vhs";if(a&&window.EffectF2Helps&&window.EffectF2Helps[a]){let modal=document.querySelector(".f2-help-modal");modal||(modal=document.createElement("div"),modal.className="f2-help-modal",modal.innerHTML='<div class="f2-help-content"></div>',document.body.appendChild(modal),modal.addEventListener("click",(t=>{t.target===modal&&modal.classList.remove("active")}))),modal.querySelector(".f2-help-content").innerHTML=`<div style="padding:24px;max-height:80vh;overflow-y:auto"><h2 style="color:var(--primary-color);margin-bottom:20px;font-size:24px">Guida ${a.toUpperCase()}</h2>${window.EffectF2Helps[a]}<button onclick="this.closest('.f2-help-modal').classList.remove('active')" style="margin-top:20px;padding:10px 20px;background:var(--primary-color);color:white;border:none;border-radius:6px;cursor:pointer;font-size:15px;font-weight:600">Chiudi (ESC)</button></div>`,modal.classList.add("active"),document.addEventListener("keydown",(function t(n){"Escape"===n.key&&(modal.classList.remove("active"),document.removeEventListener("keydown",t))}))}}}));

console.log(" Sistema Help F2 per Effetti Avanzati caricato");

})();


 // ═══════════════════════════════════════════════════════════════════════
 // GPU EFFECTS - Event Listeners
 // ═══════════════════════════════════════════════════════════════════════
 
 // Funzione per aggiornare il pannello stato GPU
 function updateGpuStatusPanel(isSupported, gpuInfo = null) {
 const panel = document.getElementById('gpu-status-panel');
 const icon = document.getElementById('gpu-status-icon');
 const title = document.getElementById('gpu-status-title');
 const renderer = document.getElementById('gpu-renderer');
 const vendor = document.getElementById('gpu-vendor');
 
 if (!panel || !icon || !title || !renderer || !vendor) return;
 
 if (isSupported) {
 icon.textContent = '';
 title.textContent = 'GPU Attiva e Funzionante';
 panel.style.background = 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)';
 panel.style.borderLeft = '4px solid #fff';
 
 if (gpuInfo) {
 renderer.textContent = `Renderer: ${gpuInfo.renderer || 'Non disponibile'}`;
 vendor.textContent = `Vendor: ${gpuInfo.vendor || 'Non disponibile'}`;
 } else {
 renderer.textContent = 'GPU WebGL rilevata e pronta';
 vendor.textContent = 'Tutti gli effetti GPU sono disponibili';
 }
 
 // Annuncio accessibile
 announceGemini('GPU attiva. Tutti gli effetti GPU sono disponibili e funzionanti.', 'polite');
 } else {
 icon.textContent = '';
 title.textContent = 'GPU Non Disponibile';
 panel.style.background = 'linear-gradient(135deg, #ee0979 0%, #ff6a00 100%)';
 panel.style.borderLeft = '4px solid #ffd700';
 renderer.textContent = 'WebGL non supportato dal browser';
 vendor.textContent = 'Gli effetti GPU non saranno disponibili';
 
 // Annuncio accessibile
 announceGemini('Attenzione: GPU non disponibile. WebGL non supportato. Gli effetti GPU non funzioneranno.', 'assertive');
 }
 }
 
 // Funzione per ottenere informazioni dettagliate GPU
 function getGpuInfo() {
 try {
 const canvas = document.createElement('canvas');
 const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
 
 if (!gl) return null;
 
 const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
 const info = {
 renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : 'Non disponibile',
 vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : 'Non disponibile',
 version: gl.getParameter(gl.VERSION),
 shadingLanguage: gl.getParameter(gl.SHADING_LANGUAGE_VERSION),
 maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
 maxViewport: gl.getParameter(gl.MAX_VIEWPORT_DIMS)
 };
 
 return info;
 } catch (error) {
 console.error('Errore nel rilevamento GPU:', error);
 return null;
 }
 }
 
 // Mostra dettagli GPU in un alert accessibile
 function showGpuDetails() {
 const gpuInfo = getGpuInfo();
 
 if (!gpuInfo) {
 alert('Informazioni GPU non disponibili.\n\nIl tuo browser potrebbe non supportare WebGL o le estensioni necessarie per rilevare i dettagli della GPU.');
 return;
 }
 
 const details = `INFORMAZIONI GPU DETTAGLIATE

 Renderer: ${gpuInfo.renderer}

 Vendor: ${gpuInfo.vendor}

 Versione WebGL: ${gpuInfo.version}

 Shading Language: ${gpuInfo.shadingLanguage}

 Dimensione Max Texture: ${gpuInfo.maxTextureSize}px

 Dimensioni Max Viewport: ${gpuInfo.maxViewport[0]}x${gpuInfo.maxViewport[1]}px

Tutti gli effetti GPU in questo editor utilizzano questa GPU per l'elaborazione accelerata delle immagini.`;
 
 alert(details);
 
 // Annuncio per screen reader
 announceGemini('Dettagli GPU mostrati. Leggi il contenuto del dialogo per informazioni complete.', 'polite');
 }
 
 // Event listener per pulsante dettagli GPU
 if (document.getElementById('btn-gpu-details')) {
 document.getElementById('btn-gpu-details').addEventListener('click', showGpuDetails);
 }
 
 // Inizializza WebGL al caricamento con delay per sistema fallback glfx
 setTimeout(() => {
 const webglSuccess = window.GpuEffects ? window.GpuEffects.init() : false;
 const gpuInfo = getGpuInfo();
 
 // Aggiorna il pannello stato GPU
 updateGpuStatusPanel(webglSuccess, gpuInfo);
 
 if (!webglSuccess) {
 // Determina il motivo del fallimento per messaggio più preciso
 let reason = 'WebGL non disponibile';
 if (!window.glfxAvailable) {
 reason = 'glfx.js non caricato (tutti i fallback falliti)';
 } else if (typeof fx === 'undefined') {
 reason = 'fx object non definito';
 }
 
 announceGemini(`️ Effetti GPU disabilitati: ${reason}. Le funzioni base funzionano normalmente.`, 'polite');
 
 // Disabilita tutti i pulsanti GPU
 document.querySelectorAll('.gpu-apply-btn').forEach(btn => {
 btn.disabled = true;
 btn.style.opacity = '0.5';
 btn.style.cursor = 'not-allowed';
 btn.setAttribute('aria-disabled', 'true');
 btn.title = 'GPU non disponibile - effetto non utilizzabile';
 });
 } else {
 announceGemini(' GPU attiva - effetti accelerati disponibili', 'polite');
 }
 }, 500); // 500ms: tempo sufficiente per inline + primo tentativo CDN se necessario
 
 // Slider updaters
 if (document.getElementById('vibrance-amount')) {
 document.getElementById('vibrance-amount').addEventListener('input', e => {
 document.getElementById('vibrance-amount-value').textContent = e.target.value;
 });
 }
 
 // 🆕 Motion Blur sliders
 if (document.getElementById('motionblur-distance')) {
 document.getElementById('motionblur-distance').addEventListener('input', e => {
 document.getElementById('motionblur-distance-value').textContent = e.target.value + ' px';
 });
 document.getElementById('motionblur-distance').addEventListener('change', e => {
 // RIMOSSO: announceGemini(`Distanza Motion Blur: ${e.target.value} pixel`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('motionblur-angle')) {
 document.getElementById('motionblur-angle').addEventListener('input', e => {
 document.getElementById('motionblur-angle-value').textContent = e.target.value + '°';
 });
 document.getElementById('motionblur-angle').addEventListener('change', e => {
 const directions = {
 0: 'orizzontale verso destra',
 45: 'diagonale alto-destra',
 90: 'verticale verso il basso',
 135: 'diagonale basso-sinistra',
 180: 'orizzontale verso sinistra',
 225: 'diagonale alto-sinistra',
 270: 'verticale verso l\'alto',
 315: 'diagonale alto-destra'
 };
 const angle = parseInt(e.target.value);
 const nearestKey = Object.keys(directions).reduce((prev, curr) => 
 Math.abs(curr - angle) < Math.abs(prev - angle) ? curr : prev
 );
 const direction = directions[nearestKey] || 'personalizzata';
 // RIMOSSO: announceGemini(`Angolo Motion Blur: ${angle} gradi, direzione ${direction}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 // 🆕 Tilt-Shift sliders
 if (document.getElementById('tiltshift-blur')) {
 document.getElementById('tiltshift-blur').addEventListener('input', e => {
 document.getElementById('tiltshift-blur-value').textContent = e.target.value;
 });
 document.getElementById('tiltshift-blur').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let intensity = 'leggera';
 if (value >= 16) intensity = 'forte';
 else if (value >= 9) intensity = 'media';
 // RIMOSSO: announceGemini(`Intensità blur Tilt-Shift: ${value}, sfocatura ${intensity}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('tiltshift-gradient')) {
 document.getElementById('tiltshift-gradient').addEventListener('input', e => {
 document.getElementById('tiltshift-gradient-value').textContent = e.target.value + '%';
 });
 document.getElementById('tiltshift-gradient').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let size = 'stretta';
 if (value >= 55) size = 'ampia';
 else if (value >= 30) size = 'media';
 // RIMOSSO: announceGemini(`Dimensione focus Tilt-Shift: ${value} percento, fascia ${size}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 // 🆕 Gaussian Blur slider
 if (document.getElementById('gaussianblur-radius')) {
 document.getElementById('gaussianblur-radius').addEventListener('input', e => {
 document.getElementById('gaussianblur-radius-value').textContent = e.target.value + ' px';
 });
 document.getElementById('gaussianblur-radius').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let intensity = 'leggera';
 if (value >= 61) intensity = 'estrema';
 else if (value >= 31) intensity = 'forte';
 else if (value >= 11) intensity = 'media';
 // RIMOSSO: announceGemini(`Raggio Gaussian Blur: ${value} pixel, sfocatura ${intensity}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('gaussianblur-quality')) {
 document.getElementById('gaussianblur-quality').addEventListener('change', e => {
 const qualityNames = {
 'fast': 'veloce',
 'balanced': 'bilanciata',
 'high': 'alta'
 };
 // RIMOSSO: announceGemini(`Qualità Gaussian Blur: ${qualityNames[e.target.value]}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 // ═══════════════════════════════════════════════════════════════════════
 // 🆕 v44.0 - SLIDER LISTENER NUOVI EFFETTI
 // ═══════════════════════════════════════════════════════════════════════
 
 // 🆕 Chromatic Shift sliders
 if (document.getElementById('chromatic-intensity')) {
 document.getElementById('chromatic-intensity').addEventListener('input', e => {
 document.getElementById('chromatic-intensity-value').textContent = e.target.value + ' px';
 });
 document.getElementById('chromatic-intensity').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let level = 'leggera';
 if (value >= 15) level = 'estrema';
 else if (value >= 10) level = 'forte';
 else if (value >= 5) level = 'media';
 // RIMOSSO: announceGemini(`Intensità Chromatic Shift: ${value} pixel, separazione ${level}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('chromatic-angle')) {
 document.getElementById('chromatic-angle').addEventListener('input', e => {
 const value = parseInt(e.target.value);
 let direction = 'orizzontale';
 if (value === 45) direction = 'diagonale destra-alto';
 else if (value === 90) direction = 'verticale';
 else if (value === 135) direction = 'diagonale sinistra-alto';
 else if (value === 180) direction = 'orizzontale inverso';
 else if (value === 225) direction = 'diagonale sinistra-basso';
 else if (value === 270) direction = 'verticale inverso';
 else if (value === 315) direction = 'diagonale destra-basso';
 else if (value === 0) direction = 'orizzontale';
 document.getElementById('chromatic-angle-value').textContent = `${value}° (${direction})`;
 });
 }
 
 // 🆕 Glitch sliders
 if (document.getElementById('glitch-intensity')) {
 document.getElementById('glitch-intensity').addEventListener('input', e => {
 document.getElementById('glitch-intensity-value').textContent = e.target.value;
 });
 document.getElementById('glitch-intensity').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let level = 'leggera';
 if (value >= 70) level = 'estrema';
 else if (value >= 50) level = 'forte';
 else if (value >= 30) level = 'media';
 // RIMOSSO: announceGemini(`Intensità Glitch: ${value}, distorsione ${level}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('glitch-blocks')) {
 document.getElementById('glitch-blocks').addEventListener('input', e => {
 document.getElementById('glitch-blocks-value').textContent = e.target.value;
 });
 document.getElementById('glitch-blocks').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let chaos = 'ordinato';
 if (value >= 15) chaos = 'molto caotico';
 else if (value >= 10) chaos = 'caotico';
 else if (value >= 5) chaos = 'moderato';
 // RIMOSSO: announceGemini(`Blocchi Glitch: ${value}, effetto ${chaos}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 // 🆕 VHS Light sliders
 if (document.getElementById('vhs-intensity')) {
 document.getElementById('vhs-intensity').addEventListener('input', e => {
 document.getElementById('vhs-intensity-value').textContent = e.target.value;
 });
 document.getElementById('vhs-intensity').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 let vintage = 'leggero';
 if (value >= 70) vintage = 'estremo anni 80';
 else if (value >= 50) vintage = 'forte vintage';
 else if (value >= 30) vintage = 'vintage moderato';
 // RIMOSSO: announceGemini(`Disturbo VHS: ${value}, effetto ${vintage}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('vhs-lines')) {
 document.getElementById('vhs-lines').addEventListener('input', e => {
 document.getElementById('vhs-lines-value').textContent = e.target.value;
 });
 document.getElementById('vhs-lines').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 if (value === 0) {
 // RIMOSSO: announceGemini('Righe VHS: nessuna riga di scansione', 'polite'); // NVDA già legge il valore dello slider
 } else {
 // RIMOSSO: announceGemini(`Righe VHS: ${value} righe di scansione`, 'polite'); // NVDA già legge il valore dello slider
 }
 });
 }
 
 // 🆕 v44.1 - DEHAZE / DEFOG LISTENERS
 if (document.getElementById('dehaze-strength')) {
 document.getElementById('dehaze-strength').addEventListener('input', e => {
 document.getElementById('dehaze-strength-value').textContent = e.target.value;
 });
 document.getElementById('dehaze-strength').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 // RIMOSSO: announceGemini(`Intensità Dehaze: ${value}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('dehaze-saturation')) {
 document.getElementById('dehaze-saturation').addEventListener('input', e => {
 document.getElementById('dehaze-saturation-value').textContent = e.target.value;
 });
 document.getElementById('dehaze-saturation').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 // RIMOSSO: announceGemini(`Recupero saturazione Dehaze: ${value}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 // 🆕 v44.1 - BLOOM SOFT LISTENERS
 if (document.getElementById('bloomsoft-threshold')) {
 document.getElementById('bloomsoft-threshold').addEventListener('input', e => {
 document.getElementById('bloomsoft-threshold-value').textContent = e.target.value;
 });
 document.getElementById('bloomsoft-threshold').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 // RIMOSSO: announceGemini(`Soglia luminosità Bloom Soft: ${value}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('bloomsoft-intensity')) {
 document.getElementById('bloomsoft-intensity').addEventListener('input', e => {
 document.getElementById('bloomsoft-intensity-value').textContent = e.target.value;
 });
 document.getElementById('bloomsoft-intensity').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 // RIMOSSO: announceGemini(`Intensità bagliore Bloom Soft: ${value}`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('bloomsoft-radius')) {
 document.getElementById('bloomsoft-radius').addEventListener('input', e => {
 document.getElementById('bloomsoft-radius-value').textContent = e.target.value + ' px';
 });
 document.getElementById('bloomsoft-radius').addEventListener('change', e => {
 const value = parseInt(e.target.value);
 // RIMOSSO: announceGemini(`Raggio diffusione Bloom Soft: ${value} pixel`, 'polite'); // NVDA già legge il valore dello slider
 });
 }
 
 if (document.getElementById('wb-temperature')) {
 document.getElementById('wb-temperature').addEventListener('input', e => {
 document.getElementById('wb-temperature-value').textContent = e.target.value;
 });
 document.getElementById('wb-tint').addEventListener('input', e => {
 document.getElementById('wb-tint-value').textContent = e.target.value;
 });
 }
 
 if (document.getElementById('hs-shadows')) {
 document.getElementById('hs-shadows').addEventListener('input', e => {
 document.getElementById('hs-shadows-value').textContent = e.target.value;
 });
 document.getElementById('hs-highlights').addEventListener('input', e => {
 document.getElementById('hs-highlights-value').textContent = e.target.value;
 });
 }
 
 if (document.getElementById('balance-shadows')) {
 document.getElementById('balance-shadows').addEventListener('input', e => {
 document.getElementById('balance-shadows-value').textContent = e.target.value;
 });
 document.getElementById('balance-highlights').addEventListener('input', e => {
 document.getElementById('balance-highlights-value').textContent = e.target.value;
 });
 }
 
 if (document.getElementById('gpu-blur-radius')) {
 document.getElementById('gpu-blur-radius').addEventListener('input', e => {
 document.getElementById('gpu-blur-radius-value').textContent = e.target.value + ' px';
 });
 }
 
 if (document.getElementById('bloom-threshold')) {
 document.getElementById('bloom-threshold').addEventListener('input', e => {
 document.getElementById('bloom-threshold-value').textContent = e.target.value;
 });
 document.getElementById('bloom-intensity').addEventListener('input', e => {
 document.getElementById('bloom-intensity-value').textContent = e.target.value;
 });
 }
 
 // Button listeners - VERSIONE CORRETTA con supporto multi-layer
 if (document.getElementById('btn-apply-curves')) {
 document.getElementById('btn-apply-curves').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const preset = document.getElementById('curves-preset').value;
 
 // Applica l'effetto GPU al layer specifico (con conversione automatica)
 const success = await applyGpuEffectToLayer(
 layer,
 GpuEffects.applyCurves.bind(GpuEffects),
 [preset]
 );
 
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Curves Pro applicato (${preset})`);
 } else {
 announceGemini('Errore durante l\'applicazione di Curves Pro', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-color-balance')) {
 document.getElementById('btn-apply-color-balance').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const shadows = parseInt(document.getElementById('balance-shadows').value);
 const highlights = parseInt(document.getElementById('balance-highlights').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Color Balance in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyColorBalance.bind(GpuEffects), [shadows, highlights]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce('Color Balance Pro applicato');
 // RIMOSSO (ridondante): announceGemini('Effetto Color Balance applicato con successo', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Color Balance');
 announceGemini('Errore durante l\'applicazione di Color Balance', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-gpu-blur')) {
 document.getElementById('btn-apply-gpu-blur').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const radius = parseInt(document.getElementById('gpu-blur-radius').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Blur Pro in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyBlurPro.bind(GpuEffects), [radius]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Blur Pro applicato (${radius}px)`);
 // RIMOSSO (ridondante): announceGemini(`Effetto Blur Pro applicato con successo. Raggio: ${radius} pixel`, 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Blur Pro');
 announceGemini('Errore durante l\'applicazione di Blur Pro', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-bloom')) {
 document.getElementById('btn-apply-bloom').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const threshold = parseInt(document.getElementById('bloom-threshold').value);
 const intensity = parseInt(document.getElementById('bloom-intensity').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Bloom in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyBloom.bind(GpuEffects), [threshold, intensity]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce('Bloom Pro applicato');
 // RIMOSSO (ridondante): announceGemini('Effetto Bloom applicato con successo', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Bloom Pro');
 announceGemini('Errore durante l\'applicazione di Bloom', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-vibrance')) {
 document.getElementById('btn-apply-vibrance').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const amount = parseInt(document.getElementById('vibrance-amount').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Vibrance in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyVibrance.bind(GpuEffects), [amount]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Vibrance applicato (${amount})`);
 // RIMOSSO (ridondante): announceGemini('Effetto Vibrance applicato con successo', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Vibrance');
 announceGemini('Errore durante l\'applicazione di Vibrance', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-white-balance')) {
 document.getElementById('btn-apply-white-balance').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const temperature = parseInt(document.getElementById('wb-temperature').value);
 const tint = parseInt(document.getElementById('wb-tint').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto White Balance in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyWhiteBalance.bind(GpuEffects), [temperature, tint]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce('White Balance Pro applicato');
 // RIMOSSO (ridondante): announceGemini('Effetto White Balance applicato con successo', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando White Balance');
 announceGemini('Errore durante l\'applicazione di White Balance', 'assertive');
 }
 });
 }
 
 if (document.getElementById('btn-apply-highlights-shadows')) {
 document.getElementById('btn-apply-highlights-shadows').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const shadows = parseInt(document.getElementById('hs-shadows').value);
 const highlights = parseInt(document.getElementById('hs-highlights').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Highlights & Shadows in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyHighlightsShadows.bind(GpuEffects), [shadows, highlights]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce('Highlights & Shadows applicato');
 // RIMOSSO (ridondante): announceGemini('Effetto Highlights & Shadows applicato con successo', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Highlights & Shadows');
 announceGemini('Errore durante l\'applicazione di Highlights & Shadows', 'assertive');
 }
 });
 }
 
 // 🆕 v43.0 - MOTION BLUR
 if (document.getElementById('btn-apply-motionblur')) {
 document.getElementById('btn-apply-motionblur').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const distance = parseInt(document.getElementById('motionblur-distance').value);
 const angle = parseInt(document.getElementById('motionblur-angle').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Motion Blur in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyMotionBlur.bind(GpuEffects), [distance, angle]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Motion Blur applicato (${distance}px @ ${angle}°)`);
 // RIMOSSO (ridondante): announceGemini('Motion Blur applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Motion Blur');
 announceGemini('Errore durante l\'applicazione di Motion Blur', 'assertive');
 }
 });
 }
 
 // 🆕 v43.0 - TILT-SHIFT
 if (document.getElementById('btn-apply-tiltshift')) {
 document.getElementById('btn-apply-tiltshift').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const blur = parseInt(document.getElementById('tiltshift-blur').value);
 const gradient = parseInt(document.getElementById('tiltshift-gradient').value);
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Tilt-Shift in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyTiltShift.bind(GpuEffects), [blur, gradient]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Tilt-Shift applicato (blur ${blur}, focus ${gradient}%)`);
 // RIMOSSO (ridondante): announceGemini('Tilt-Shift applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Tilt-Shift');
 announceGemini('Errore durante l\'applicazione di Tilt-Shift', 'assertive');
 }
 });
 }
 
 // 🆕 v43.0 - GAUSSIAN BLUR PRO
 if (document.getElementById('btn-apply-gaussianblur')) {
 document.getElementById('btn-apply-gaussianblur').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const radius = parseInt(document.getElementById('gaussianblur-radius').value);
 const quality = document.getElementById('gaussianblur-quality').value;
 // RIMOSSO (ridondante): // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Gaussian Blur in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyGaussianBlur.bind(GpuEffects), [radius, quality]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announce(`Gaussian Blur applicato (${radius}px, ${quality})`);
 // RIMOSSO (ridondante): announceGemini('Gaussian Blur applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Gaussian Blur');
 announceGemini('Errore durante l\'applicazione di Gaussian Blur', 'assertive');
 }
 });
 }
 
 // ═══════════════════════════════════════════════════════════════════════
 // 🆕 v44.0 - NUOVI EFFETTI GPU: Chromatic Shift, Glitch, VHS Light
 // ═══════════════════════════════════════════════════════════════════════
 
 // 🆕 v44.0 - CHROMATIC SHIFT
 if (document.getElementById('btn-apply-chromatic')) {
 document.getElementById('btn-apply-chromatic').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const intensity = parseInt(document.getElementById('chromatic-intensity').value);
 const angle = parseInt(document.getElementById('chromatic-angle').value);
 
 // Validazione input
 if (isNaN(intensity) || intensity < 1 || intensity > 20) {
 announceGemini('Errore: valore intensità non valido. Inserire un numero tra 1 e 20', 'assertive');
 return;
 }
 if (isNaN(angle) || angle < 0 || angle > 360) {
 announceGemini('Errore: valore angolo non valido. Inserire un numero tra 0 e 360', 'assertive');
 return;
 }
 
 // Controllo esistenza metodo GpuEffects
 if (typeof GpuEffects === 'undefined' || typeof GpuEffects.applyChromatic !== 'function') {
 announceGemini('Errore: modulo effetti GPU non disponibile. Verificare WebGL.', 'assertive');
 return;
 }
 
 // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Chromatic Shift in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyChromatic.bind(GpuEffects), [intensity, angle]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce(`Chromatic Shift applicato (${intensity}px @ ${angle}°)`);
 announceGemini('Chromatic Shift applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Chromatic Shift');
 announceGemini('Errore durante l\'applicazione di Chromatic Shift', 'assertive');
 }
 });
 }
 
 // 🆕 v44.0 - GLITCH EFFECT
 if (document.getElementById('btn-apply-glitch')) {
 document.getElementById('btn-apply-glitch').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const intensity = parseInt(document.getElementById('glitch-intensity').value);
 const blocks = parseInt(document.getElementById('glitch-blocks').value);
 
 // Validazione input
 if (isNaN(intensity) || intensity < 1 || intensity > 100) {
 announceGemini('Errore: valore intensità non valido. Inserire un numero tra 1 e 100', 'assertive');
 return;
 }
 if (isNaN(blocks) || blocks < 2 || blocks > 20) {
 announceGemini('Errore: numero blocchi non valido. Inserire un numero tra 2 e 20', 'assertive');
 return;
 }
 
 // Controllo esistenza metodo GpuEffects
 if (typeof GpuEffects === 'undefined' || typeof GpuEffects.applyGlitch !== 'function') {
 announceGemini('Errore: modulo effetti GPU non disponibile. Verificare WebGL.', 'assertive');
 return;
 }
 
 // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Glitch in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyGlitch.bind(GpuEffects), [intensity, blocks]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce(`Glitch applicato (intensità ${intensity}, ${blocks} blocchi)`);
 announceGemini('Effetto Glitch applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Glitch');
 announceGemini('Errore durante l\'applicazione di Glitch', 'assertive');
 }
 });
 }
 
 // 🆕 v44.0 - VHS LIGHT EFFECT
 if (document.getElementById('btn-apply-vhs')) {
 document.getElementById('btn-apply-vhs').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const intensity = parseInt(document.getElementById('vhs-intensity').value);
 const lines = parseInt(document.getElementById('vhs-lines').value);
 
 // Validazione input
 if (isNaN(intensity) || intensity < 0 || intensity > 100) {
 announceGemini('Errore: valore intensità disturbo non valido. Inserire un numero tra 0 e 100', 'assertive');
 return;
 }
 if (isNaN(lines) || lines < 0 || lines > 10) {
 announceGemini('Errore: numero righe non valido. Inserire un numero tra 0 e 10', 'assertive');
 return;
 }
 
 // Controllo esistenza metodo GpuEffects
 if (typeof GpuEffects === 'undefined' || typeof GpuEffects.applyVHS !== 'function') {
 announceGemini('Errore: modulo effetti GPU non disponibile. Verificare WebGL.', 'assertive');
 return;
 }
 
 // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto VHS Light in corso...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyVHS.bind(GpuEffects), [intensity, lines]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce(`VHS Light applicato (disturbo ${intensity}, ${lines} righe scan)`);
 announceGemini('Effetto VHS applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando VHS Light');
 announceGemini('Errore durante l\'applicazione di VHS Light', 'assertive');
 }
 });
 }
 
 // ═══════════════════════════════════════════════════════════════════════
 // 🆕 v44.1 - NUOVI EFFETTI GPU: Dehaze, Bloom Soft
 // ═══════════════════════════════════════════════════════════════════════
 
 // 🆕 v44.1 - DEHAZE / DEFOG
 if (document.getElementById('btn-apply-dehaze')) {
 document.getElementById('btn-apply-dehaze').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const strength = parseInt(document.getElementById('dehaze-strength').value);
 const saturation = parseInt(document.getElementById('dehaze-saturation').value);
 
 // Validazione input
 if (isNaN(strength) || strength < 0 || strength > 100) {
 announceGemini('Errore: valore forza dehaze non valido. Inserire un numero tra 0 e 100', 'assertive');
 return;
 }
 if (isNaN(saturation) || saturation < 0 || saturation > 100) {
 announceGemini('Errore: valore recupero saturazione non valido. Inserire un numero tra 0 e 100', 'assertive');
 return;
 }
 
 // Controllo esistenza metodo GpuEffects
 if (typeof GpuEffects === 'undefined' || typeof GpuEffects.applyDehaze !== 'function') {
 announceGemini('Errore: modulo effetti GPU non disponibile. Verificare WebGL.', 'assertive');
 return;
 }
 
 // RIMOSSO (ridondante - già c'è annuncio completamento): announce('Applicando...');
 // RIMOSSO (ridondante): announceGemini('Applicazione effetto Dehaze in corso. Rimozione foschia e nebbia...', 'assertive');
 const success = await applyGpuEffectToLayer(layer, GpuEffects.applyDehaze.bind(GpuEffects), [strength, saturation]);
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 // RIMOSSO (ridondante): announce(`Dehaze applicato (intensità ${strength}, recupero sat ${saturation})`);
 announceGemini('Effetto Dehaze applicato', 'polite');
 } else {
 // RIMOSSO (ridondante): announce(' Errore applicando Dehaze');
 announceGemini('Errore durante l\'applicazione di Dehaze', 'assertive');
 }
 });
 }
 
 // 🆕 v44.1 - BLOOM SOFT
 if (document.getElementById('btn-apply-bloomsoft')) {
 document.getElementById('btn-apply-bloomsoft').addEventListener('click', async () => {
 const layer = getSelectedLayer();
 if (!layer) {
 announceGemini('Seleziona un layer prima di applicare effetti', 'assertive');
 return;
 }
 
 const threshold = parseInt(document.getElementById('bloomsoft-threshold').value);
 const intensity = parseInt(document.getElementById('bloomsoft-intensity').value);
 const radius = parseInt(document.getElementById('bloomsoft-radius').value);
 
 // Validazione input
 if (isNaN(threshold) || threshold < 0 || threshold > 100) {
 announceGemini('Errore: valore soglia luminosità non valido. Inserire un numero tra 0 e 100', 'assertive');
 return;
 }
 if (isNaN(intensity) || intensity < 1 || intensity > 50) {
 announceGemini('Errore: valore intensità bagliore non valido. Inserire un numero tra 1 e 50', 'assertive');
 return;
 }
 if (isNaN(radius) || radius < 2 || radius > 20) {
 announceGemini('Errore: valore raggio diffusione non valido. Inserire un numero tra 2 e 20', 'assertive');
 return;
 }
 
 // Controllo esistenza metodo GpuEffects
 if (typeof GpuEffects === 'undefined' || typeof GpuEffects.applyBloomSoft !== 'function') {
 announceGemini('Errore: modulo effetti GPU non disponibile. Verificare WebGL.', 'assertive');
 return;
 }
 
 // Applica l'effetto GPU al layer specifico (con conversione automatica)
 const success = await applyGpuEffectToLayer(
 layer,
 GpuEffects.applyBloomSoft.bind(GpuEffects),
 [threshold, intensity, radius]
 );
 
 if (success) {
 saveHistory();
 scheduleRender();
 updateUI();
 announceGemini(`Effetto Bloom Soft applicato con successo. Bagliore morbido con soglia ${threshold}, intensità ${intensity}, raggio ${radius} pixel`, 'polite');
 } else {
 announceGemini('Errore durante l\'applicazione di Bloom Soft', 'assertive');
 }
 });
 }
 
 // ═══════════════════════════════════════════════════════════════════════
 // SISTEMA F2 HELP - Modal
 // ═══════════════════════════════════════════════════════════════════════
 
 const helpModal = document.getElementById('help-modal');
 const helpCloseBtn = document.getElementById('help-close-btn');
 
 if (helpModal && helpCloseBtn) {
 function toggleHelpModal() {
 helpModal.classList.toggle('active');
 if (helpModal.classList.contains('active')) {
 helpCloseBtn.focus();
 // RIMOSSO (ridondante): announce('Guida effetti GPU aperta. Premi F2 o Esc per chiudere.');
 } else {
 announce('Guida effetti GPU chiusa.');
 }
 }
 
 // F2 per aprire/chiudere help
 document.addEventListener('keydown', (e) => {
 if (e.key === 'F2') {
 e.preventDefault();
 toggleHelpModal();
 }
 
 // ESC per chiudere help
 if (e.key === 'Escape' && helpModal.classList.contains('active')) {
 toggleHelpModal();
 }
 });
 
 helpCloseBtn.addEventListener('click', () => {
 toggleHelpModal();
 });
 
 helpModal.addEventListener('click', (e) => {
 if (e.target === helpModal) {
 toggleHelpModal();
 }
 });
 }

 </script>
<script>
// ═══════════════════════════════════════════════════════════════════
// FIX ACCESSIBILITÀ - Tutti i problemi risolti
// ═══════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', function() {
 
 // ────────────────────────────────────────────────────────────────
 // FIX 1: SKIP LINK per saltare l'header e andare direttamente ai controlli
 // ────────────────────────────────────────────────────────────────
 const skipLink = document.createElement('a');
 skipLink.href = '#main-controls';
 skipLink.textContent = 'Salta al contenuto principale (Premi Invio)';
 skipLink.className = 'skip-link';
 skipLink.style.cssText = `
 position: absolute;
 top: -100px;
 left: 0;
 background: #3b82f6;
 color: white;
 padding: 12px 20px;
 z-index: 10000;
 font-weight: bold;
 text-decoration: none;
 border-radius: 0 0 8px 0;
 `;
 
 // Mostra quando ha focus
 skipLink.addEventListener('focus', () => {
 skipLink.style.top = '0';
 });
 skipLink.addEventListener('blur', () => {
 skipLink.style.top = '-100px';
 });
 
 document.body.insertBefore(skipLink, document.body.firstChild);
 
 // Aggiungi ID al primo pannello per il target
 const firstPanel = document.querySelector('.section-panel');
 if (firstPanel && !firstPanel.id) {
 firstPanel.id = 'main-controls';
 firstPanel.setAttribute('tabindex', '-1'); // Permette focus programmatico
 }
 
 // ────────────────────────────────────────────────────────────────
 // FIX 2: RIMUOVI tutti gli aria-label e title con valore "null"
 // ────────────────────────────────────────────────────────────────
 function removeNullAttributes() {
 let fixed = 0;
 
 // Trova tutti gli elementi con aria-label o title
 document.querySelectorAll('[aria-label], [title]').forEach(el => {
 const ariaLabel = el.getAttribute('aria-label');
 const title = el.getAttribute('title');
 
 // Rimuovi aria-label se è "null" o stringa vuota
 if (ariaLabel === 'null' || ariaLabel === '' || ariaLabel === 'undefined') {
 el.removeAttribute('aria-label');
 fixed++;
 console.log(' Rimosso aria-label nullo da:', el.id || el.tagName);
 }
 
 // Rimuovi title se è "null" o stringa vuota
 if (title === 'null' || title === '' || title === 'undefined') {
 el.removeAttribute('title');
 fixed++;
 console.log(' Rimosso title nullo da:', el.id || el.tagName);
 }
 });
 
 console.log(` Rimossi ${fixed} attributi null/vuoti`);
 return fixed;
 }
 
 // Esegui la pulizia
 removeNullAttributes();
 
 // Riesegui dopo 1 secondo per contenuti caricati dinamicamente
 setTimeout(removeNullAttributes, 1000);
 
 // ────────────────────────────────────────────────────────────────
 // FIX 3: MIGLIORA annunci pulsanti effetti GPU
 // ────────────────────────────────────────────────────────────────
 document.querySelectorAll('.gpu-apply-btn').forEach(btn => {
 // Rimuovi eventuali role="button" ridondanti (già sono <button>)
 if (btn.getAttribute('role') === 'button') {
 btn.removeAttribute('role');
 }
 
 // Migliora aria-label per essere più descrittivo
 const currentLabel = btn.getAttribute('aria-label');
 if (currentLabel && currentLabel.includes('Applica effetto')) {
 // Cambia da "Applica effetto X" a "Applica X al canvas"
 const effectName = currentLabel.replace('Applica effetto ', '').replace(' GPU', '');
 btn.setAttribute('aria-label', `Applica ${effectName} al canvas`);
 }
 
 // Previeni che i click espandano sezioni invece di applicare effetti
 btn.addEventListener('click', (e) => {
 e.stopPropagation(); // Non propagare a parent che potrebbero essere toggle
 console.log(' Applicazione effetto GPU:', btn.id);
 }, true); // Use capture per essere sicuri di intercettare prima
 });
 
 // ────────────────────────────────────────────────────────────────
 // FIX 4: AGGIUNGI descrizione differenza Centra Canvas vs Safe Zone
 // ────────────────────────────────────────────────────────────────
 
 // Trova pulsanti centra (se esistono)
 const btnCenterCanvas = document.getElementById('btn-center-in-canvas');
 const btnCenterSafeZone = document.getElementById('btn-center-in-safe-zone');
 
 if (btnCenterCanvas) {
 btnCenterCanvas.setAttribute('aria-label', 'Centra elemento nel canvas completo');
 btnCenterCanvas.title = 'Centra nel canvas completo (occupa tutto lo spazio disponibile)';
 }
 
 if (btnCenterSafeZone) {
 btnCenterSafeZone.setAttribute('aria-label', 'Centra elemento nella zona sicura social');
 btnCenterSafeZone.title = 'Centra nella safe zone (evita che contenuti vengano tagliati da UI Instagram/TikTok)';
 }
 
 // ────────────────────────────────────────────────────────────────
 // FIX 5: MIGLIORA feedback vocale per select
 // ────────────────────────────────────────────────────────────────
 // RIMOSSO: Listener globale sui select - NVDA già annuncia i cambiamenti
 // document.querySelectorAll('select').forEach(select => {
 // select.addEventListener('change', (e) => {
 // const label = document.querySelector(`label[for="${select.id}"]`);
 // const labelText = label ? label.textContent.trim() : select.getAttribute('aria-label') || 'Opzione';
 // const value = e.target.options[e.target.selectedIndex].text;
 // 
 // // Annuncia in modo chiaro
 // if (window.announce) {
 // window.announceGemini(`${labelText}: ${value}`, 'polite');
 // }
 // });
 // });
 
 console.log(' Fix accessibilità applicati con successo');
});
</script>
<script>
// ═══════════════════════════════════════════════════════════════════
// FIX FINALE: Focus automatico + Annunci effetti GPU
// ═══════════════════════════════════════════════════════════════════

document.addEventListener('DOMContentLoaded', function() {
 
 // ────────────────────────────────────────────────────────────────
 // FIX: FOCUS AUTOMATICO sul primo pannello (evita trap su body)
 // ────────────────────────────────────────────────────────────────
 setTimeout(() => {
 // Trova il primo elemento interattivo nella sidebar
 const firstInteractive = document.querySelector('.sidebar button, .sidebar input, .sidebar select, .sidebar textarea, .section-header[tabindex="0"]');
 
 if (firstInteractive) {
 firstInteractive.focus();
 console.log(' Focus automatico impostato su:', firstInteractive.id || firstInteractive.tagName);
 
 // Annuncia che l'app è pronta
 if (window.announce) {
 window.announceGemini('Editor Grafico caricato. Usa Tab per navigare tra i controlli. Premi F1 per la guida completa.', 'polite');
 }
 }
 }, 500); // Aspetta che tutto sia caricato
 
 // ────────────────────────────────────────────────────────────────
 // ────────────────────────────────────────────────────────────────
 // ANNUNCI NVDA: Gli annunci sono gestiti direttamente negli handler
 // specifici di ogni pulsante (non serve listener globale duplicato)
 // ────────────────────────────────────────────────────────────────
 
 console.log(' Fix focus automatico attivato');
});
</script>

<!-- ========================================
 COSTRUTTORE PROMPT - JAVASCRIPT
 ======================================== -->
<script>
// Schema dati per costruttore prompt
const PROMPT_SCHEMA = {
 families: {
 photo_real: {
 desc: "FOTOGRAFIA REALISTICA: Come una foto vera scattata con una macchina fotografica. Colori naturali, dettagli precisi.",
 text: "una fotografia realistica"
 },
 cinematic: {
 desc: "CINEMATOGRAFICA: Atmosfera drammatica come in un film, con luci e ombre marcate.",
 text: "una scena cinematografica con luci drammatiche"
 },
 digital_illustration: {
 desc: "ILLUSTRAZIONE DIGITALE: Un disegno fatto al computer, linee pulite, come nei fumetti moderni.",
 text: "un'illustrazione digitale pulita e leggibile"
 }
 },
 flavors: {
 minimal: {
 desc: "MINIMALE: Sfondo semplice e pulito, pochi elementi. Massima chiarezza.",
 text: "con uno sfondo semplice e pulito"
 },
 rich_ordered: {
 desc: "DETTAGLIATA: Più elementi ma ordinati, non caotico. Ricca ma armoniosa.",
 text: "ricca di dettagli ma ordinata e armoniosa"
 }
 }
};

// Apri costruttore
document.getElementById('btn-open-prompt-builder')?.addEventListener('click', function() {
 const modal = document.getElementById('prompt-builder-modal');
 if (modal) {
 modal.style.display = 'flex';
 updatePromptHelp();
 generatePrompt();
 document.getElementById('pb-subject')?.focus();
 }
});

// Chiudi costruttore
document.getElementById('btn-close-prompt-builder')?.addEventListener('click', function() {
 const modal = document.getElementById('prompt-builder-modal');
 if (modal) modal.style.display = 'none';
});

// Chiudi con ESC
document.addEventListener('keydown', function(e) {
 if (e.key === 'Escape') {
 const modal = document.getElementById('prompt-builder-modal');
 if (modal && modal.style.display === 'flex') {
 modal.style.display = 'none';
 }
 }
});

// Toggle testo - semplificato (controllo testo accurato è automatico)
document.getElementById('pb-text-enabled')?.addEventListener('change', function() {
 const container = document.getElementById('pb-text-container');
 
 if (this.checked) {
 // TESTO ABILITATO: mostra campo testo
 container.style.display = 'block';
 } else {
 // TESTO DISABILITATO: nascondi campo
 container.style.display = 'none';
 }
 generatePrompt();
});

// Update help text per lo stile
function updatePromptHelp() {
 const style = document.getElementById('pb-style')?.value || 'photo_real';
 const styleHelp = document.getElementById('pb-style-help');
 
 if (styleHelp && PROMPT_SCHEMA.families[style]) {
 styleHelp.textContent = PROMPT_SCHEMA.families[style].desc;
 }
}

// Update listeners
document.getElementById('pb-style')?.addEventListener('change', function() {
 updatePromptHelp();
 generatePrompt();
});

document.getElementById('pb-subject')?.addEventListener('input', generatePrompt);
document.getElementById('pb-text-content')?.addEventListener('input', generatePrompt);

// Listeners per i nuovi radio buttons
document.querySelectorAll('input[name="pb-framing"]').forEach(radio => {
 radio.addEventListener('change', generatePrompt);
});

document.querySelectorAll('input[name="pb-lighting"]').forEach(radio => {
 radio.addEventListener('change', generatePrompt);
});

document.querySelectorAll('input[name="pb-mood"]').forEach(radio => {
 radio.addEventListener('change', generatePrompt);
});

document.querySelectorAll('input[name="pb-colors"]').forEach(radio => {
 radio.addEventListener('change', generatePrompt);
});

// Genera prompt COMPLETO con tutte le opzioni
function generatePrompt() {
 const subject = document.getElementById('pb-subject')?.value.trim() || '';
 const style = document.getElementById('pb-style')?.value || 'photo_real';
 const textEnabled = document.getElementById('pb-text-enabled')?.checked || false;
 const textContent = document.getElementById('pb-text-content')?.value.trim() || '';
 
 // Nuove opzioni
 const framing = document.querySelector('input[name="pb-framing"]:checked')?.value || 'full_body';
 const lighting = document.querySelector('input[name="pb-lighting"]:checked')?.value || 'golden_hour';
 const mood = document.querySelector('input[name="pb-mood"]:checked')?.value || 'cheerful';
 const colors = document.querySelector('input[name="pb-colors"]:checked')?.value || 'warm';
 
 if (!subject) {
 document.getElementById('pb-final-prompt').value = 'Inserisci prima un soggetto per generare il prompt!';
 return;
 }
 
 const parts = [];
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 1: STILE BASE
 // ═══════════════════════════════════════════════════════════
 
 if (PROMPT_SCHEMA.families[style]) {
 parts.push(PROMPT_SCHEMA.families[style].text);
 }
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 2: SOGGETTO
 // ═══════════════════════════════════════════════════════════
 
 parts.push("di " + subject);
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 3: INQUADRATURA
 // ═══════════════════════════════════════════════════════════
 
 const framingMap = {
 'extreme_closeup': 'extreme close-up shot, focusing on a single detail',
 'closeup': 'close-up shot, subject fills 80-90% of frame',
 'medium_shot': 'medium shot from waist up, subject fills 60-70% of frame',
 'full_body': 'full body shot showing subject from head to toe',
 'wide_shot': 'wide shot with subject at distance, environment visible',
 'extreme_wide': 'extreme wide establishing shot, vast landscape'
 };
 
 if (framingMap[framing]) {
 parts.push(framingMap[framing]);
 }
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 4: ILLUMINAZIONE
 // ═══════════════════════════════════════════════════════════
 
 const lightingMap = {
 'golden_hour': 'golden hour lighting with warm soft glow and long shadows',
 'natural_daylight': 'natural daylight with clear even illumination',
 'soft_diffused': 'soft diffused lighting from overcast sky, no harsh shadows',
 'blue_hour': 'blue hour twilight with deep blue tones',
 'dramatic': 'dramatic hard lighting with strong contrasts and deep shadows',
 'backlight': 'backlit with rim light creating a glowing halo effect'
 };
 
 if (lightingMap[lighting]) {
 parts.push(lightingMap[lighting]);
 }
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 5: ATMOSFERA
 // ═══════════════════════════════════════════════════════════
 
 const moodMap = {
 'cheerful': 'cheerful and bright atmosphere, positive energy',
 'dramatic': 'dramatic and intense mood, powerful tension',
 'serene': 'calm and serene atmosphere, peaceful tranquility',
 'energetic': 'energetic and dynamic mood, vibrant action',
 'mysterious': 'mysterious and dark atmosphere, enigmatic shadows'
 };
 
 if (moodMap[mood]) {
 parts.push(moodMap[mood]);
 }
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 6: COLORI
 // ═══════════════════════════════════════════════════════════
 
 const colorsMap = {
 'warm': 'warm color palette with reds, oranges, yellows',
 'cool': 'cool color palette with blues, greens, purples',
 'neutral': 'neutral monochromatic palette with grays, blacks, whites',
 'vibrant': 'vibrant saturated colors with high intensity',
 'pastel': 'soft pastel colors with delicate tones'
 };
 
 if (colorsMap[colors]) {
 parts.push(colorsMap[colors]);
 }
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 7: QUALITÀ
 // ═══════════════════════════════════════════════════════════
 
 parts.push("professional quality, sharp focus, crisp details");
 
 // ═══════════════════════════════════════════════════════════
 // PARTE 8: TESTO (se richiesto)
 // ═══════════════════════════════════════════════════════════
 
 if (textEnabled && textContent) {
 parts.push(`with the exact text "${textContent}" written in clear legible typography with high contrast`);
 }
 
 let prompt = parts.join(', ');
 
 // ═══════════════════════════════════════════════════════════
 // CONTROLLI QUALITÀ PROFESSIONALI (sempre attivi)
 // ═══════════════════════════════════════════════════════════
 
 const qualityStandards = [
 // QUALITÀ TECNICA
 "high quality, best quality, masterpiece",
 "no blur, no out of focus areas",
 "no noise, no grain, no artifacts, no jpeg compression",
 "proper exposure, balanced lighting",
 "accurate colors",
 
 // COMPOSIZIONE
 "clean composition, well-balanced frame",
 "correct perspective, realistic proportions",
 "professional framing",
 
 // ELEMENTI INDESIDERATI
 "no watermark, no logo, no signature, no branding",
 "no text overlays, no labels, no captions",
 "clean corners",
 
 // DUPLICATI
 "no duplicates, no clones",
 "no glitches, no distortions",
 
 // ANATOMIA (L'AI applica solo se pertinente)
 "correct human anatomy if people present",
 "well-formed hands with proper number of fingers",
 "symmetrical face with natural proportions",
 "realistic eyes, natural skin texture",
 "no extra limbs, no missing limbs, no deformed body parts",
 
 // ANIMALI (L'AI applica solo se pertinente)
 "correct animal anatomy if animals present",
 
 // OGGETTI
 "symmetrical objects where appropriate",
 "clean edges, proper geometry"
 ];
 
 // CONTROLLO TESTO
 if (!textEnabled) {
 qualityStandards.push("no text, no letters, no words, no writing of any kind");
 } else {
 qualityStandards.push("accurate text rendering, correct spelling, clear typography");
 qualityStandards.push("no gibberish, no random characters");
 }
 
 // STILE-SPECIFICO
 if (style === 'photo_real') {
 qualityStandards.push("photorealistic quality");
 qualityStandards.push("natural colors, realistic lighting");
 } else if (style === 'cinematic') {
 qualityStandards.push("cinematic quality");
 qualityStandards.push("film-like atmosphere");
 } else if (style === 'digital_illustration') {
 qualityStandards.push("clean digital art");
 qualityStandards.push("consistent art style");
 }
 
 // Aggiungi gli standard al prompt
 prompt += ". Quality standards: " + qualityStandards.join(', ') + ".";
 
 document.getElementById('pb-final-prompt').value = prompt;
}

// Copia prompt
function copyPromptToClipboard() {
 const textarea = document.getElementById('pb-final-prompt');
 if (textarea) {
 textarea.select();
 try {
 document.execCommand('copy');
 announce('Prompt copiato negli appunti! Pronto per essere incollato nel tuo generatore AI.', 'polite');
 } catch (err) {
 announce('Errore durante la copia. Usa Ctrl+C per copiare manualmente.', 'assertive');
 }
 }
}
</script>
</body>
</html>