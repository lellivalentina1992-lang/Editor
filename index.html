<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio/Video Editor PRO - Timeline Verticale</title>
    <style>

        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background-color: #0d1117;
            color: #c9d1d9;
            height: 100vh;
            overflow: hidden;
        }
        
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 20px;
            gap: 15px;
        }
        
        /* HEADER */
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            border-radius: 12px;
        }
        
        .header h1 {
            font-size: 1.8rem;
            font-weight: 600;
            color: #58a6ff;
        }
        
        .header-buttons {
            display: flex;
            gap: 10px;
        }
        
        .btn {
            padding: 12px 24px;
            background-color: #238636;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: #2ea043;
        }
        
        .btn-secondary {
            background-color: #30363d;
        }
        
        .btn-secondary:hover {
            background-color: #484f58;
        }
        
        /* STATUS BAR */
        .status-bar {
            padding: 15px 20px;
            background-color: #161b22;
            border-radius: 10px;
            border: 1px solid #30363d;
            font-size: 1.05rem;
        }
        
        /* TIMELINE RULER */
        .timeline-ruler-container {
            background-color: #161b22;
            border-radius: 10px;
            border: 1px solid #30363d;
            padding: 20px;
            height: 100px;
        }
        
        .timeline-ruler {
            overflow-x: auto;
            position: relative;
            height: 60px;
            background-color: #0d1117;
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .timeline-markers {
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 0.85rem;
            color: #8b949e;
            margin-bottom: 5px;
        }
        
        .timeline-cursor {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background-color: #f85149;
            z-index: 100;
            pointer-events: none;
        }
        
        .timeline-cursor::before {
            content: '‚ñº';
            position: absolute;
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
            color: #f85149;
            font-size: 0.8rem;
        }
        
        /* TRACKS CONTAINER */
        .tracks-container {
            flex: 1;
            background-color: #161b22;
            border-radius: 10px;
            border: 1px solid #30363d;
            padding: 20px;
            overflow-y: auto;
            overflow-x: hidden;
        }
        
        .track {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 15px;
        }
        
        .track.selected {
            border-color: #58a6ff;
            box-shadow: 0 0 0 1px #58a6ff;
        }
        
        .track-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .track-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .track-icon {
            font-size: 1.5rem;
        }
        
        .track-name {
            font-weight: 600;
            color: #c9d1d9;
        }
        
        .track-actions {
            display: flex;
            gap: 8px;
        }
        
        .track-btn {
            padding: 6px 12px;
            background-color: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            border-radius: 6px;
            font-size: 0.9rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .track-btn:hover {
            background-color: #30363d;
        }
        
        .track-timeline {
            position: relative;
            height: 50px;
            background-color: #161b22;
            border-radius: 6px;
            border: 1px solid #30363d;
            margin-top: 10px;
        }
        
        .track-clip {
            position: absolute;
            top: 5px;
            bottom: 5px;
            background: linear-gradient(135deg, #58a6ff 0%, #1f6feb 100%);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: move;
            user-select: none;
        }
        
        .track-clip.audio {
            background: linear-gradient(135deg, #2ea043 0%, #238636 100%);
        }
        
        .track-clip.video {
            background: linear-gradient(135deg, #f85149 0%, #da3633 100%);
        }
        
        .add-track-btn {
            width: 100%;
            padding: 20px;
            background-color: #21262d;
            border: 2px dashed #30363d;
            border-radius: 8px;
            color: #8b949e;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .add-track-btn:hover {
            background-color: #30363d;
            border-color: #58a6ff;
            color: #58a6ff;
        }
        
        /* HIDDEN FILE INPUT */
        #fileInput {
            display: none;
        }
    
    
        
        .selection-label {
            position: absolute;
            font-size: 0.7rem;
            font-weight: bold;
            pointer-events: none;
        }
    
        
        .track-clip {
            cursor: move;
            user-select: none;
            transition: opacity 0.2s;
        }
        
        .track-clip:hover {
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- HEADER -->
        <div class="header">
            <h1>Audio/Video Editor PRO - Timeline Verticale</h1>
            <div class="header-buttons">
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    Carica File
                </button>
                <button class="btn" onclick="app.openEffectsMenu()">üé® Effetti (E)</button>
                <button class="btn" onclick="app.exportProject()" style="margin-right: 10px;">üíæ Export</button>
                <button class="btn-secondary btn" onclick="document.getElementById('helpDialog').showModal()">
                    Aiuto
                </button>
            </div>
        </div>
        
        <!-- STATUS BAR -->
        <div class="status-bar" id="statusBar">
            Premi T per aggiungere traccia vuota
        </div>
        
        <!-- TIMELINE RULER -->
        <div class="timeline-ruler-container">
            <div class="timeline-markers" id="timelineMarkers"></div>
            <div class="timeline-ruler" id="timelineRuler">
                <div class="timeline-cursor" id="timelineCursor" style="left: 0%;"></div>
            </div>
        </div>
        
        <!-- TRACKS CONTAINER -->
        <div class="tracks-container" id="tracksContainer">
            <button class="add-track-btn" onclick="app.addTrack()">
                + Aggiungi Traccia (T)
            </button>
        </div>
        
        <!-- HIDDEN FILE INPUT -->
        <input type="file" id="fileInput" accept="audio/*,video/*,image/*" multiple>
    </div>
    
    <!-- HELP DIALOG -->
    <dialog id="helpDialog" style="max-width: 750px; padding: 30px;">
        <h2>‚å®Ô∏è Tasti Rapidi</h2>
        <div style="line-height: 2.2; font-size: 1rem; max-height: 70vh; overflow-y: auto;">
            <h3 style="color: #58a6ff; margin-top: 10px;">Timeline</h3>
            <p><strong style="color: #58a6ff;">‚Üí/‚Üê</strong> ¬±1sec | <strong>Shift+‚Üí/‚Üê</strong> ¬±10sec | <strong>Ctrl+‚Üí/‚Üê</strong> ¬±1min</p>
            <p><strong style="color: #58a6ff;">Home/End</strong> Inizio/Fine</p>
            
            <h3 style="color: #58a6ff; margin-top: 15px;">Tracce</h3>
            <p><strong style="color: #58a6ff;">T</strong> Nuova traccia | <strong>‚Üë/‚Üì</strong> Cambia traccia | <strong>Canc</strong> Elimina</p>
            
            <h3 style="color: #58a6ff; margin-top: 15px;">Selezioni Globali (verde)</h3>
            <p><strong style="color: #2ea043;">I</strong> Punto IN | <strong style="color: #2ea043;">O</strong> Punto OUT | <strong>Shift+U</strong> Cancella</p>
            
            <h3 style="color: #ffa657; margin-top: 15px;">Selezioni Locali (arancione)</h3>
            <p><strong style="color: #ffa657;">Shift+I</strong> Punto IN | <strong style="color: #ffa657;">Shift+O</strong> Punto OUT | <strong>U</strong> Cancella</p>
            
            <h3 style="color: #58a6ff; margin-top: 15px;">Editing</h3>
            <p><strong style="color: #58a6ff;">Ctrl+X/C/V</strong> Taglia/Copia/Incolla</p>
            <p><strong style="color: #58a6ff;">R</strong> Trim clip a selezione locale</p>
            <p><strong style="color: #58a6ff;">[  ]</strong> Riduci/Aumenta durata clip (¬±1sec)</p>
            
            <h3 style="color: #58a6ff; margin-top: 15px;">Drag & Drop</h3>
            <p><strong style="color: #58a6ff;">Mouse</strong> Trascina clip per spostarle sulla timeline</p>
            <p><strong style="color: #58a6ff;">S</strong> Toggle Snap to Grid (ON/OFF)</p>
            
            <h3 style="color: #58a6ff; margin-top: 15px;">Export</h3>
            <p><strong style="color: #58a6ff;">Ctrl+E</strong> Esporta progetto</p>
        </div>
        <button class="btn" onclick="document.getElementById('helpDialog').close()" style="margin-top: 20px; width: 100%;">Chiudi</button>
    </dialog>
    
    <script>
const API_URL = 'https://answers-layers-rise-default.trycloudflare.com/api';

class VideoEditorWeb {
    constructor() {
        this.tracks = [];
        this.selectedTrackId = null;
        this.cursorPosition = 0;
        this.globalInPoint = null;
        this.globalOutPoint = null;
        this.clipboard = null;
        this.draggedTrack = null;
        this.snapEnabled = false;
        this.init();
    }
    
    init() {
        console.log('üé¨ Timeline Verticale Inizializzata');
        this.setupEventListeners();
        this.updateDisplay();
    }
    
    setupEventListeners() {
        // File input
        document.getElementById('fileInput').addEventListener('change', (e) => {
            this.handleFileUpload(e.target.files);
        });
        
        // Timeline ruler click
        document.getElementById('timelineRuler').addEventListener('click', (e) => {
            const rect = e.target.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            const maxDuration = this.getMaxDuration();
            this.cursorPosition = percent * maxDuration;
            this.updateDisplay();
        });
        
        // Drag & Drop
        document.body.addEventListener('dragover', (e) => {
            e.preventDefault();
        });
        
        document.body.addEventListener('drop', (e) => {
            e.preventDefault();
            this.handleFileUpload(e.dataTransfer.files);
        });
    }
    
    async handleFileUpload(files) {
        for (const file of files) {
            await this.uploadFile(file);
        }
    }
    
    async uploadFile(file) {
        try {
            // Se c'√® una traccia vuota selezionata, riempi quella
            if (this.selectedTrackId) {
                const selectedTrack = this.tracks.find(t => t.id === this.selectedTrackId);
                if (selectedTrack && selectedTrack.type === 'empty') {
                    await this.fillTrack(selectedTrack.id, file);
                    return;
                }
            }
            
            // Altrimenti crea nuova traccia
            const trackId = Date.now() + Math.random();
            
            const track = {
                id: trackId,
                name: file.name,
                type: file.type.startsWith('audio/') ? 'audio' : 
                      file.type.startsWith('video/') ? 'video' : 'image',
                duration: 0,
                startTime: this.globalInPoint !== null ? this.globalInPoint : this.cursorPosition,
                filePath: null,
                size: file.size
            };
            
            this.tracks.push(track);
            this.selectedTrackId = trackId;
            this.renderTracks();
            
            this.updateStatus(`üì§ Upload ${file.name}...`);
            
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Upload fallito: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            track.filePath = data.filePath;
            track.duration = data.duration || 10;
            track.fileId = data.fileId;
            
            this.updateStatus(`‚úÖ ${file.name} caricato`);
            this.renderTracks();
            
        } catch (error) {
            console.error('Upload error:', error);
            this.updateStatus(`‚ùå Errore: ${error.message}`, true);
        }
    }
    
    async fillTrack(trackId, file) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track) return;
        
        try {
            this.updateStatus(`üì§ Caricamento ${file.name}...`);
            
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch(`${API_URL}/upload`, {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                throw new Error(`Upload fallito`);
            }
            
            const data = await response.json();
            
            track.name = file.name;
            track.type = file.type.startsWith('audio/') ? 'audio' : 
                         file.type.startsWith('video/') ? 'video' : 'image';
            track.filePath = data.filePath;
            track.duration = data.duration || 10;
            track.fileId = data.fileId;
            track.size = file.size;
            
            if (this.globalInPoint !== null) {
                track.startTime = this.globalInPoint;
            }
            
            this.updateStatus(`‚úÖ ${file.name} caricato`);
            this.renderTracks();
            
        } catch (error) {
            console.error('Fill error:', error);
            this.updateStatus(`‚ùå Errore: ${error.message}`, true);
        }
    }
    
    renderTracks() {
        const container = document.getElementById('tracksContainer');
        if (!container) return;
        
        container.innerHTML = '';
        
        const maxDuration = this.getMaxDuration();
        
        this.tracks.forEach(track => {
            const trackEl = document.createElement('div');
            trackEl.className = 'track' + (track.id === this.selectedTrackId ? ' selected' : '');
            trackEl.onclick = () => this.selectTrack(track.id);
            
            let icon = 'üìã';
            if (track.type === 'audio') icon = 'üéµ';
            else if (track.type === 'video') icon = 'üé¨';
            else if (track.type === 'image') icon = 'üñºÔ∏è';
            
            trackEl.innerHTML = `
                <div class="track-header">
                    <div class="track-info">
                        <span class="track-icon">${icon}</span>
                        <span class="track-name">${track.name}</span>
                        <span style="color: #8b949e; font-size: 0.9rem; margin-left: 10px;">
                            ${this.formatTime(track.duration || 0)}
                        </span>
                    </div>
                    <div class="track-actions">
                        <button class="track-btn" onclick="event.stopPropagation(); app.deleteTrack(${track.id})">Del</button>
                    </div>
                </div>
                <div class="track-timeline" id="track-timeline-${track.id}"></div>
            `;
            
            container.appendChild(trackEl);
            
            // Aggiungi clip
            const timeline = document.getElementById(`track-timeline-${track.id}`);
            if (timeline && track.duration > 0 && maxDuration > 0) {
                const clip = document.createElement('div');
                clip.className = 'track-clip ' + track.type;
                
                const startPercent = ((track.startTime || 0) / maxDuration) * 100;
                const widthPercent = (track.duration / maxDuration) * 100;
                
                clip.style.left = startPercent + '%';
                clip.style.width = widthPercent + '%';
                clip.textContent = track.name;
                
                timeline.appendChild(clip);
                
                // Marker locali
                this.renderLocalMarkers(track.id);
            }
        });
        
        const addBtn = document.createElement('button');
        addBtn.className = 'add-track-btn';
        addBtn.textContent = '+ Aggiungi Traccia (T)';
        addBtn.onclick = () => this.addTrack();
        container.appendChild(addBtn);
        
        // Setup drag & drop
        this.setupDragDrop();
    }
    
    selectTrack(trackId) {
        this.selectedTrackId = trackId;
        this.renderTracks();
        const track = this.tracks.find(t => t.id === trackId);
        this.updateStatus(`Traccia selezionata: ${track?.name || ''}`);
    }
    
    addTrack() {
        const trackId = Date.now();
        const track = {
            id: trackId,
            name: `Traccia ${this.tracks.length + 1}`,
            type: 'empty',
            duration: 0,
            startTime: this.cursorPosition || 0,
            filePath: null
        };
        this.tracks.push(track);
        this.selectedTrackId = trackId;
        this.renderTracks();
        this.updateStatus('Traccia vuota creata - Carica un file (Ctrl+Click "Carica File")');
    }
    
    deleteTrack(trackId) {
        if (!confirm('Eliminare questa traccia?')) return;
        
        this.tracks = this.tracks.filter(t => t.id !== trackId);
        if (this.selectedTrackId === trackId) {
            this.selectedTrackId = null;
        }
        this.renderTracks();
        this.updateStatus('Traccia eliminata');
    }
    
    setGlobalIn() {
        this.globalInPoint = this.cursorPosition;
        this.updateStatus(`Punto IN: ${this.formatTime(this.globalInPoint)}`);
        this.updateDisplay();
    }
    
    setGlobalOut() {
        this.globalOutPoint = this.cursorPosition;
        this.updateStatus(`Punto OUT: ${this.formatTime(this.globalOutPoint)}`);
        this.updateDisplay();
    }
    
    updateDisplay() {
        const maxDuration = this.getMaxDuration();
        const percent = maxDuration > 0 ? (this.cursorPosition / maxDuration) * 100 : 0;
        document.getElementById('timelineCursor').style.left = `${percent}%`;
        
        this.updateTimelineMarkers();
        this.renderSelectionMarkers();
    }
    
    updateTimelineMarkers() {
        const maxDuration = this.getMaxDuration();
        const markers = document.getElementById('timelineMarkers');
        if (!markers) return;
        
        markers.innerHTML = '';
        const numMarkers = 7;
        for (let i = 0; i < numMarkers; i++) {
            const time = (maxDuration / (numMarkers - 1)) * i;
            const span = document.createElement('span');
            span.textContent = this.formatTime(time);
            markers.appendChild(span);
        }
    }
    
    renderSelectionMarkers() {
        const ruler = document.getElementById('timelineRuler');
        if (!ruler) return;
        
        const existing = ruler.querySelectorAll('.selection-marker, .selection-overlay, .selection-label');
        existing.forEach(el => el.remove());
        
        const maxDuration = this.getMaxDuration();
        if (maxDuration === 0) return;
        
        if (this.globalInPoint !== null) {
            const percent = (this.globalInPoint / maxDuration) * 100;
            const marker = document.createElement('div');
            marker.className = 'selection-marker';
            marker.style.cssText = `position: absolute; left: ${percent}%; top: 0; bottom: 0; width: 2px; background-color: #2ea043; z-index: 10; pointer-events: none;`;
            ruler.appendChild(marker);
            
            const label = document.createElement('div');
            label.className = 'selection-label';
            label.textContent = 'IN';
            label.style.cssText = `position: absolute; left: ${percent}%; top: -20px; font-size: 0.7rem; color: #2ea043; font-weight: bold; transform: translateX(-50%); pointer-events: none;`;
            ruler.appendChild(label);
        }
        
        if (this.globalOutPoint !== null) {
            const percent = (this.globalOutPoint / maxDuration) * 100;
            const marker = document.createElement('div');
            marker.className = 'selection-marker';
            marker.style.cssText = `position: absolute; left: ${percent}%; top: 0; bottom: 0; width: 2px; background-color: #f85149; z-index: 10; pointer-events: none;`;
            ruler.appendChild(marker);
            
            const label = document.createElement('div');
            label.className = 'selection-label';
            label.textContent = 'OUT';
            label.style.cssText = `position: absolute; left: ${percent}%; top: -20px; font-size: 0.7rem; color: #f85149; font-weight: bold; transform: translateX(-50%); pointer-events: none;`;
            ruler.appendChild(label);
        }
        
        if (this.globalInPoint !== null && this.globalOutPoint !== null) {
            const startPercent = (this.globalInPoint / maxDuration) * 100;
            const endPercent = (this.globalOutPoint / maxDuration) * 100;
            const width = endPercent - startPercent;
            
            const overlay = document.createElement('div');
            overlay.className = 'selection-overlay';
            overlay.style.cssText = `position: absolute; left: ${startPercent}%; width: ${width}%; top: 0; bottom: 0; background-color: rgba(46, 160, 67, 0.15); z-index: 5; pointer-events: none;`;
            ruler.appendChild(overlay);
        }
    }
    
    updateStatus(message, isError = false) {
        const statusBar = document.getElementById('statusBar');
        if (statusBar) {
            statusBar.textContent = message;
            statusBar.style.color = isError ? '#f85149' : '#c9d1d9';
        }
    }
    
    getMaxDuration() {
        if (this.tracks.length === 0) return 60;
        return Math.max(...this.tracks.map(t => (t.startTime || 0) + (t.duration || 0)), 60);
    }


    selectNextTrack() {
        if (this.tracks.length === 0) return;
        
        const currentIndex = this.tracks.findIndex(t => t.id === this.selectedTrackId);
        const nextIndex = (currentIndex + 1) % this.tracks.length;
        this.selectedTrackId = this.tracks[nextIndex].id;
        this.renderTracks();
    }
    
    selectPreviousTrack() {
        if (this.tracks.length === 0) return;
        
        const currentIndex = this.tracks.findIndex(t => t.id === this.selectedTrackId);
        const prevIndex = currentIndex <= 0 ? this.tracks.length - 1 : currentIndex - 1;
        this.selectedTrackId = this.tracks[prevIndex].id;
        this.renderTracks();
    }
    // === FASE 2: CLIPBOARD & SELEZIONI LOCALI ===
    
    cutSelection() {
        if (!this.selectedTrackId) {
            this.updateStatus('Nessuna traccia selezionata', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track || !track.localInPoint || !track.localOutPoint) {
            this.updateStatus('Nessuna selezione sulla traccia', true);
            return;
        }
        
        this.clipboard = {
            type: 'cut',
            trackData: JSON.parse(JSON.stringify(track)),
            inPoint: track.localInPoint,
            outPoint: track.localOutPoint
        };
        
        this.updateStatus(`‚úÇÔ∏è Tagliato: ${this.formatTime(this.clipboard.outPoint - this.clipboard.inPoint)}`);
        this.deleteLocalSelection();
    }
    
    copySelection() {
        if (!this.selectedTrackId) {
            this.updateStatus('Nessuna traccia selezionata', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track || !track.localInPoint || !track.localOutPoint) {
            this.updateStatus('Nessuna selezione sulla traccia', true);
            return;
        }
        
        this.clipboard = {
            type: 'copy',
            trackData: JSON.parse(JSON.stringify(track)),
            inPoint: track.localInPoint,
            outPoint: track.localOutPoint
        };
        
        this.updateStatus(`üìã Copiato: ${this.formatTime(this.clipboard.outPoint - this.clipboard.inPoint)}`);
    }
    
    async pasteSelection() {
        if (!this.clipboard) {
            this.updateStatus('Clipboard vuota', true);
            return;
        }
        
        const newTrack = {
            id: Date.now(),
            name: this.clipboard.trackData.name + ' (Copia)',
            type: this.clipboard.trackData.type,
            filePath: this.clipboard.trackData.filePath,
            duration: this.clipboard.outPoint - this.clipboard.inPoint,
            startTime: this.cursorPosition,
            fileId: this.clipboard.trackData.fileId,
            size: this.clipboard.trackData.size
        };
        
        this.tracks.push(newTrack);
        this.selectedTrackId = newTrack.id;
        this.renderTracks();
        this.updateStatus(`‚úÖ Incollato alla posizione ${this.formatTime(this.cursorPosition)}`);
    }
    
    async deleteLocalSelection() {
        if (!this.selectedTrackId) {
            this.updateStatus('Nessuna traccia selezionata', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track || !track.localInPoint || !track.localOutPoint) {
            this.updateStatus('Nessuna selezione da cancellare', true);
            return;
        }
        
        if (!confirm(`Cancellare selezione dalla traccia?`)) return;
        
        track.localInPoint = null;
        track.localOutPoint = null;
        this.renderTracks();
        this.updateStatus('‚úÖ Selezione locale cancellata');
    }
    
    async deleteGlobalSelection() {
        if (this.globalInPoint === null || this.globalOutPoint === null) {
            this.updateStatus('Nessuna selezione globale', true);
            return;
        }
        
        if (!confirm(`Cancellare selezione da TUTTE le tracce?`)) return;
        
        this.globalInPoint = null;
        this.globalOutPoint = null;
        this.updateDisplay();
        this.updateStatus('‚úÖ Selezione globale cancellata');
    }
    
    setLocalIn() {
        if (!this.selectedTrackId) {
            this.updateStatus('Nessuna traccia selezionata', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track) return;
        
        track.localInPoint = this.cursorPosition;
        this.updateStatus(`IN locale: ${this.formatTime(track.localInPoint)}`);
        this.renderTracks();
    }
    
    setLocalOut() {
        if (!this.selectedTrackId) {
            this.updateStatus('Nessuna traccia selezionata', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track) return;
        
        track.localOutPoint = this.cursorPosition;
        this.updateStatus(`OUT locale: ${this.formatTime(track.localOutPoint)}`);
        this.renderTracks();
    }
    
    clearLocalSelection() {
        if (!this.selectedTrackId) return;
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track) return;
        
        track.localInPoint = null;
        track.localOutPoint = null;
        this.updateStatus('Selezione locale cancellata');
        this.renderTracks();
    }
    
    clearGlobalSelection() {
        this.globalInPoint = null;
        this.globalOutPoint = null;
        this.updateStatus('Selezione globale cancellata');
        this.updateDisplay();
    }
    
    renderLocalMarkers(trackId) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track) return;
        
        const timeline = document.getElementById(`track-timeline-${trackId}`);
        if (!timeline) return;
        
        const maxDuration = this.getMaxDuration();
        const existing = timeline.querySelectorAll('.local-marker, .local-overlay');
        existing.forEach(el => el.remove());
        
        if (track.localInPoint !== null) {
            const percent = (track.localInPoint / maxDuration) * 100;
            const marker = document.createElement('div');
            marker.className = 'local-marker';
            marker.style.cssText = `position: absolute; left: ${percent}%; top: 0; bottom: 0; width: 2px; background-color: #ffa657; z-index: 15; pointer-events: none;`;
            timeline.appendChild(marker);
        }
        
        if (track.localOutPoint !== null) {
            const percent = (track.localOutPoint / maxDuration) * 100;
            const marker = document.createElement('div');
            marker.className = 'local-marker';
            marker.style.cssText = `position: absolute; left: ${percent}%; top: 0; bottom: 0; width: 2px; background-color: #ffa657; z-index: 15; pointer-events: none;`;
            timeline.appendChild(marker);
        }
        
        if (track.localInPoint !== null && track.localOutPoint !== null) {
            const startPercent = (track.localInPoint / maxDuration) * 100;
            const endPercent = (track.localOutPoint / maxDuration) * 100;
            const width = endPercent - startPercent;
            
            const overlay = document.createElement('div');
            overlay.className = 'local-overlay';
            overlay.style.cssText = `position: absolute; left: ${startPercent}%; width: ${width}%; top: 0; bottom: 0; background-color: rgba(255, 166, 87, 0.2); z-index: 10; pointer-events: none;`;
            timeline.appendChild(overlay);
        }
    }
    
    async exportProject() {
        if (this.tracks.length === 0) {
            this.updateStatus('Nessuna traccia da esportare', true);
            return;
        }
        
        const dialog = document.getElementById('exportDialog');
        if (dialog) dialog.showModal();
    }
    
    async startExport(exportType) {
        const dialog = document.getElementById('exportDialog');
        if (dialog) dialog.close();
        
        this.updateStatus('üé¨ Export in preparazione...');
        
        alert('Export richiede endpoint backend /export-project - da implementare nel server');
        this.updateStatus('‚ö†Ô∏è Funzionalit√† export da completare lato backend');
    }

    
    formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        const ms = Math.floor((seconds % 1) * 1000);
        return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0').slice(0, 2)}`;
    }
    // === FASE 3: DRAG & DROP ===
    
    setupDragDrop() {
        // Questo metodo sar√† chiamato dopo ogni renderTracks
        // per riattivare gli event listeners sulle clip
        
        this.tracks.forEach(track => {
            const timeline = document.getElementById(`track-timeline-${track.id}`);
            if (!timeline) return;
            
            const clip = timeline.querySelector('.track-clip');
            if (!clip) return;
            
            clip.draggable = true;
            
            clip.addEventListener('dragstart', (e) => {
                this.draggedTrack = track;
                e.dataTransfer.effectAllowed = 'move';
                clip.style.opacity = '0.5';
            });
            
            clip.addEventListener('dragend', (e) => {
                clip.style.opacity = '1';
                this.draggedTrack = null;
            });
            
            // Drop zone sulla timeline
            timeline.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            
            timeline.addEventListener('drop', (e) => {
                e.preventDefault();
                
                if (!this.draggedTrack) return;
                
                // Calcola nuova posizione in base al drop
                const rect = timeline.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percent = x / rect.width;
                const maxDuration = this.getMaxDuration();
                const newStartTime = percent * maxDuration;
                
                // Aggiorna startTime della traccia
                this.draggedTrack.startTime = Math.max(0, newStartTime);
                
                this.updateStatus(`üìç Clip spostata a ${this.formatTime(this.draggedTrack.startTime)}`);
                this.renderTracks();
            });
        });
    }
    
    resizeClip(trackId, newDuration) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track) return;
        
        track.duration = Math.max(0.1, newDuration);
        this.renderTracks();
        this.updateStatus(`‚è±Ô∏è Durata modificata: ${this.formatTime(track.duration)}`);
    }
    
    trimClipToSelection(trackId) {
        const track = this.tracks.find(t => t.id === trackId);
        if (!track || !track.localInPoint || !track.localOutPoint) {
            this.updateStatus('Nessuna selezione sulla traccia', true);
            return;
        }
        
        const newDuration = track.localOutPoint - track.localInPoint;
        const newStart = track.startTime + track.localInPoint;
        
        track.startTime = newStart;
        track.duration = newDuration;
        track.localInPoint = null;
        track.localOutPoint = null;
        
        this.renderTracks();
        this.updateStatus(`‚úÇÔ∏è Clip tagliata: ${this.formatTime(newDuration)}`);
    }
    
    // ============================================
    // NUOVO: Funzioni per gli effetti
    // ============================================
    
    openEffectsMenu() {
        if (!this.selectedTrackId) {
            this.updateStatus('‚ö†Ô∏è Seleziona prima una traccia per applicare effetti', true);
            return;
        }
        
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track || track.type === 'empty') {
            this.updateStatus('‚ö†Ô∏è Carica un file nella traccia prima di applicare effetti', true);
            return;
        }
        
        this.updateStatus(`üé® Menu effetti per: ${track.name}`);
        document.getElementById('effectsDialog').showModal();
    }
    
    async applyEffect(effectType) {
        const track = this.tracks.find(t => t.id === this.selectedTrackId);
        if (!track) return;
        
        // Controlla che ci sia un file caricato
        if (!track.fileId) {
            this.updateStatus('‚ö†Ô∏è Nessun file caricato su questa traccia', true);
            return;
        }
        
        try {
            // Controlla se c'√® una selezione IN-OUT
            const hasSelection = track.localInPoint !== null && track.localOutPoint !== null && track.localInPoint < track.localOutPoint;
            
            // Mostra loading con info selezione
            if (hasSelection) {
                this.updateStatus(`‚è≥ Applicando ${effectType} su selezione ${this.formatTime(track.localInPoint)}-${this.formatTime(track.localOutPoint)}...`);
            } else {
                this.updateStatus(`‚è≥ Applicando ${effectType} su tutto il file...`);
            }
            
            document.getElementById('effectsDialog').close();
            
            // Inizializza array effetti se non esiste
            if (!track.effects) {
                track.effects = [];
            }
            
            // Aggiungi l'effetto alla lista
            const newEffect = {
                type: effectType,
                timestamp: Date.now()
            };
            track.effects.push(newEffect);
            
            // Chiama il backend per applicare l'effetto REALMENTE con supporto selezione
            const response = await fetch(`${API_URL}/apply-effects`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    fileId: track.fileId,
                    effects: track.effects,
                    inPoint: track.localInPoint,              // ‚Üê NUOVO: Punto IN
                    outPoint: track.localOutPoint,            // ‚Üê NUOVO: Punto OUT
                    applyToSelection: hasSelection            // ‚Üê NUOVO: Flag selezione
                })
            });
            
            if (!response.ok) {
                throw new Error(`Errore ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            
            if (data.success) {
                // Aggiorna il file della traccia con quello processato
                track.fileId = data.outputFile;
                track.filePath = data.outputPath;
                
                // Messaggio di successo differenziato
                if (hasSelection) {
                    this.updateStatus(`‚úÖ ${effectType} applicato su selezione!`);
                } else {
                    this.updateStatus(`‚úÖ ${effectType} applicato con successo!`);
                }
                
                this.renderTracks();
            } else {
                throw new Error(data.error || 'Errore sconosciuto');
            }
            
        } catch (error) {
            console.error('Errore apply effect:', error);
            this.updateStatus(`‚ùå Errore: ${error.message}`, true);
            
            // Rimuovi l'effetto dalla lista se fallisce
            if (track.effects) {
                track.effects.pop();
            }
        }
    }

}

// Init
const app = new VideoEditorWeb();
window.app = app;

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    const key = e.key.toLowerCase();
    
    if (key === 't') {
        e.preventDefault();
        app.addTrack();
    }
    
    
    if (key === 'arrowup') {
        e.preventDefault();
        app.selectPreviousTrack();
    }
    
    if (key === 'arrowdown') {
        e.preventDefault();
        app.selectNextTrack();
    }
    
    if (key === 'arrowright') {
        e.preventDefault();
        const ctrl = e.ctrlKey;
        const shift = e.shiftKey;
        
        if (ctrl) {
            // Ctrl+‚Üí = +1 minuto
            app.cursorPosition = Math.min(app.cursorPosition + 60, app.getMaxDuration());
        } else if (shift) {
            // Shift+‚Üí = +10 secondi
            app.cursorPosition = Math.min(app.cursorPosition + 10, app.getMaxDuration());
        } else {
            // ‚Üí = +1 secondo
            app.cursorPosition = Math.min(app.cursorPosition + 1, app.getMaxDuration());
        }
        app.updateDisplay();
    }
    
    if (key === 'arrowleft') {
        e.preventDefault();
        const ctrl = e.ctrlKey;
        const shift = e.shiftKey;
        
        if (ctrl) {
            // Ctrl+‚Üê = -1 minuto
            app.cursorPosition = Math.max(app.cursorPosition - 60, 0);
        } else if (shift) {
            // Shift+‚Üê = -10 secondi
            app.cursorPosition = Math.max(app.cursorPosition - 10, 0);
        } else {
            // ‚Üê = -1 secondo
            app.cursorPosition = Math.max(app.cursorPosition - 1, 0);
        }
        app.updateDisplay();
    }
    
    if (key === 'home') {
        e.preventDefault();
        app.cursorPosition = 0;
        app.updateDisplay();
    }
    
    if (key === 'end') {
        e.preventDefault();
        app.cursorPosition = app.getMaxDuration();
        app.updateDisplay();
    }
    
    if (key === 'i') {
        e.preventDefault();
        app.setGlobalIn();
    }
    
    if (key === 'o') {
        e.preventDefault();
        app.setGlobalOut();
    }
    
    
    // Ctrl+X = Taglia
    if (key === 'x' && ctrl && !shift) {
        e.preventDefault();
        app.cutSelection();
    }
    
    // Ctrl+C = Copia  
    if (key === 'c' && ctrl && !shift) {
        e.preventDefault();
        app.copySelection();
    }
    
    // Ctrl+V = Incolla
    if (key === 'v' && ctrl) {
        e.preventDefault();
        app.pasteSelection();
    }
    
    // Shift+I = IN locale
    if (key === 'i' && shift) {
        e.preventDefault();
        app.setLocalIn();
    }
    
    // Shift+O = OUT locale
    if (key === 'o' && shift) {
        e.preventDefault();
        app.setLocalOut();
    }
    
    // U = Cancella selezione
    if (key === 'u') {
        e.preventDefault();
        if (shift) {
            app.clearGlobalSelection();
        } else {
            app.clearLocalSelection();
        }
    }
    
    // E o Ctrl+E = Apri menu effetti
    if (key === 'e') {
        e.preventDefault();
        app.openEffectsMenu();
    }

    if (key === 'delete') {
        e.preventDefault();
        if (app.selectedTrackId) {
            app.deleteTrack(app.selectedTrackId);
        }

    
    // R = Trim clip to selection
    if (key === 'r') {
        e.preventDefault();
        if (app.selectedTrackId) {
            app.trimClipToSelection(app.selectedTrackId);
        }
    }
    
    // S = Toggle Snap to Grid
    if (key === 's' && !ctrl && !shift) {
        e.preventDefault();
        const newState = !app.snapEnabled;
        app.enableSnapToGrid(newState);
    }
    
    // [ e ] = Riduce/Aumenta durata clip
    if (key === '[') {
        e.preventDefault();
        if (app.selectedTrackId) {
            const track = app.tracks.find(t => t.id === app.selectedTrackId);
            if (track) {
                app.resizeClip(app.selectedTrackId, track.duration - 1);
            }
        }
    }
    
    if (key === ']') {
        e.preventDefault();
        if (app.selectedTrackId) {
            const track = app.tracks.find(t => t.id === app.selectedTrackId);
            if (track) {
                app.resizeClip(app.selectedTrackId, track.duration + 1);
            }
        }
    }
    }
});

console.log('üé¨ Editor pronto!');

    </script>

    <dialog id="exportDialog" style="max-width: 500px; padding: 30px;">
        <h2>üíæ Esporta Progetto</h2>
        <p style="margin: 20px 0;">Scegli cosa esportare:</p>
        
        <button class="btn" onclick="app.startExport('all')" style="width: 100%; margin: 10px 0; padding: 15px;">
            üìπ Esporta Tutto
        </button>
        
        <button class="btn" onclick="app.startExport('selection')" style="width: 100%; margin: 10px 0; padding: 15px;">
            ‚úÇÔ∏è Esporta Selezione (IN-OUT)
        </button>
        
        <button class="btn-secondary btn" onclick="document.getElementById('exportDialog').close()" style="width: 100%; margin-top: 20px;">
            Annulla
        </button>
    </dialog>

    <dialog id="effectsDialog" style="max-width: 600px; padding: 30px; background-color: #161b22; border: 1px solid #30363d; border-radius: 12px; color: #c9d1d9;">
        <h2 style="color: #58a6ff;">üé® Effetti Audio/Video</h2>
        <p style="margin: 20px 0; color: #8b949e;">Seleziona un effetto da applicare alla traccia:</p>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin: 20px 0;">
            <button class="btn" onclick="app.applyEffect('Fade In')" style="padding: 15px;">
                üìà Fade In
            </button>
            
            <button class="btn" onclick="app.applyEffect('Fade Out')" style="padding: 15px;">
                üìâ Fade Out
            </button>
            
            <button class="btn" onclick="app.applyEffect('Reverse')" style="padding: 15px;">
                ‚è™ Reverse
            </button>
            
            <button class="btn" onclick="app.applyEffect('Speed Up')" style="padding: 15px;">
                ‚è© Speed Up
            </button>
            
            <button class="btn" onclick="app.applyEffect('Slow Down')" style="padding: 15px;">
                üêå Slow Down
            </button>
            
            <button class="btn" onclick="app.applyEffect('Echo')" style="padding: 15px;">
                üîä Echo
            </button>
            
            <button class="btn" onclick="app.applyEffect('Normalize')" style="padding: 15px;">
                üìä Normalize
            </button>
            
            <button class="btn" onclick="app.applyEffect('Equalizer')" style="padding: 15px;">
                üéöÔ∏è Equalizer
            </button>
            
            <button class="btn" onclick="app.applyEffect('Grayscale')" style="padding: 15px; background-color: #484f58;">
                ‚¨õ Grayscale
            </button>
            
            <button class="btn" onclick="app.applyEffect('Brightness')" style="padding: 15px; background-color: #484f58;">
                ‚òÄÔ∏è Brightness
            </button>
            
            <button class="btn" onclick="app.applyEffect('Contrast')" style="padding: 15px; background-color: #484f58;">
                üîÜ Contrast
            </button>
            
            <button class="btn" onclick="app.applyEffect('Sepia')" style="padding: 15px; background-color: #484f58;">
                üìú Sepia
            </button>
            
            <button class="btn" onclick="app.applyEffect('Saturation')" style="padding: 15px; background-color: #484f58;">
                üé® Saturation
            </button>
            
            <button class="btn" onclick="app.applyEffect('Blur')" style="padding: 15px; background-color: #484f58;">
                üí® Blur
            </button>
        </div>
        
        <button class="btn-secondary btn" onclick="document.getElementById('effectsDialog').close()" style="width: 100%; margin-top: 20px;">
            Chiudi
        </button>
    </dialog>

    </body>
</html>